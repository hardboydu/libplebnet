To re-create this export-controlled program from eBones:

1) Copy ksrvutil.c from the kadmin directory.
2) perl -spi.bak -e 's/\$(Header[^\$]*)\$/$1/g' *.[ch]
3) Apply this patch:

*** ksrvutil.c.orig	Fri Jan 20 17:19:45 1995
--- ksrvutil.c	Fri Jan 20 17:27:38 1995
***************
*** 1,10 ****
  /*
-  * $Source: /afs/athena.mit.edu/astaff/project/kerberos/src/kadmin/RCS/ksrvutil.c,v $
-  * $Author: jtkohl $
-  *
   * Copyright 1989 by the Massachusetts Institute of Technology.
   *
   * For copying and distribution information, please see the file
!  * <mit-copyright.h>.
   *
   * list and update contents of srvtab files
--- 1,7 ----
  /*
   * Copyright 1989 by the Massachusetts Institute of Technology.
   *
   * For copying and distribution information, please see the file
!  * Copyright.MIT.
   *
   * list and update contents of srvtab files
***************
*** 12,20 ****
  
  #ifndef	lint
  static char rcsid_ksrvutil_c[] =
! "BonesHeader: /afs/athena.mit.edu/astaff/project/kerberos/src/kadmin/RCS/ksrvutil.c,v 4.1 89/09/26 09:33:49 jtkohl Exp ";
  #endif	lint
  
- #include <mit-copyright.h>
  /*
   * ksrvutil
--- 9,20 ----
  
  #ifndef	lint
+ #if 0
  static char rcsid_ksrvutil_c[] =
! "BonesHeader: /afs/athena.mit.edu/astaff/project/kerberos/src/kadmin/RCS/ksrvutil.c,v 4.1 89/09/26 09:33:49 jtkohl Exp ";
! #endif
! static const char rcsid[] =
! 	"$Id$";
  #endif	lint
  
  /*
   * ksrvutil
***************
*** 37,40 ****
--- 37,41 ----
  #include <errno.h>
  #include <kadm.h>
+ #include <err.h>
  
  #ifdef NOENCRYPTION
***************
*** 54,58 ****
  
  extern int errno;
- extern char *sys_errlist[];
  
  extern void krb_set_tkt_string();
--- 55,58 ----
***************
*** 79,85 ****
  	if ((keyfile_fd = open(keyfile, O_RDONLY, 0)) < 0) {
  	    if (errno != ENOENT) {
! 		(void)fprintf(stderr, "%s: Unable to read %s: %s\n", progname, 
! 			      keyfile, sys_errlist[errno]);
! 		exit(1);
  	    }
  	    else {
--- 79,83 ----
  	if ((keyfile_fd = open(keyfile, O_RDONLY, 0)) < 0) {
  	    if (errno != ENOENT) {
! 		    err(1, "unable to read %s", keyfile);
  	    }
  	    else {
***************
*** 88,100 ****
  		     open(keyfile, 
  			  O_WRONLY | O_TRUNC | O_CREAT, SRVTAB_MODE)) < 0) {
! 		    (void) fprintf(stderr, "%s: Unable to create %s: %s\n", 
! 				   progname, keyfile, sys_errlist[errno]);
! 		    exit(1);
  		}
  		else
  		    if (close(keyfile_fd) < 0) {
! 			(void) fprintf(stderr, "%s: Failure closing %s: %s\n",
! 				       progname, keyfile, sys_errlist[errno]);
! 			exit(1);
  		    }
  	    }
--- 86,94 ----
  		     open(keyfile, 
  			  O_WRONLY | O_TRUNC | O_CREAT, SRVTAB_MODE)) < 0) {
! 			err(1, "unable to create %s", keyfile);
  		}
  		else
  		    if (close(keyfile_fd) < 0) {
! 			    err(1, "failure closing %s", keyfile);
  		    }
  	    }
***************
*** 107,135 ****
  	 open(backup_keyfile, O_WRONLY | O_TRUNC | O_CREAT, 
  	      keyfile_mode)) < 0) {
! 	(void) fprintf(stderr, "%s: Unable to write %s: %s\n", progname, 
! 		       backup_keyfile, sys_errlist[errno]);
! 	exit(1);
      }
      do {
  	if ((rcount = read(keyfile_fd, (char *)buf, sizeof(buf))) < 0) {
! 	    (void) fprintf(stderr, "%s: Error reading %s: %s\n", progname,
! 			   keyfile, sys_errlist[errno]);
! 	    exit(1);
  	}
  	if (rcount && (write(backup_keyfile_fd, buf, rcount) != rcount)) {
! 	    (void) fprintf(stderr, "%s: Error writing %s: %s\n", progname,
! 			   backup_keyfile, sys_errlist[errno]);
! 	    exit(1);
  	}
      } while (rcount);
      if (close(backup_keyfile_fd) < 0) {
! 	(void) fprintf(stderr, "%s: Error closing %s: %s\n", progname,
! 		       backup_keyfile, sys_errlist[errno]);
! 	exit(1);
      }
      if (close(keyfile_fd) < 0) {
! 	(void) fprintf(stderr, "%s: Error closing %s: %s\n", progname,
! 		       keyfile, sys_errlist[errno]);
! 	exit(1);
      }
  }
--- 101,119 ----
  	 open(backup_keyfile, O_WRONLY | O_TRUNC | O_CREAT, 
  	      keyfile_mode)) < 0) {
! 	    err(1, "unable to write %s", backup_keyfile);
      }
      do {
  	if ((rcount = read(keyfile_fd, (char *)buf, sizeof(buf))) < 0) {
! 		err(1, "error reading %s", keyfile);
  	}
  	if (rcount && (write(backup_keyfile_fd, buf, rcount) != rcount)) {
! 		err(1, "error writing %s", backup_keyfile);
  	}
      } while (rcount);
      if (close(backup_keyfile_fd) < 0) {
! 	    err(1, "error closing %s", backup_keyfile);
      }
      if (close(keyfile_fd) < 0) {
! 	    err(1, "error closing %s", keyfile);
      }
  }
***************
*** 145,151 ****
      (void) bzero(buf, size);
      if (read(0, buf, size - 1) < 0) {
! 	(void) fprintf(stderr, "Failure reading from stdin: %s\n", 
! 		       sys_errlist[errno]);
! 	leave((char *)NULL, 1);
      }
      fflush(stdin);
--- 129,134 ----
      (void) bzero(buf, size);
      if (read(0, buf, size - 1) < 0) {
! 	    warn("failure reading from stdin");
! 	    leave((char *)NULL, 1);
      }
      fflush(stdin);
***************
*** 163,170 ****
  {
      if (write(fd, buf, len) != len) {
! 	(void) fprintf(stderr, "%s: Failure writing to %s: %s\n", progname,
! 		       filename, sys_errlist[errno]);
! 	(void) close(fd);
! 	leave("In progress srvtab in this file.", 1);
      }
  }	
--- 146,152 ----
  {
      if (write(fd, buf, len) != len) {
! 	    warn("failure writing %s", filename);
! 	    close(fd);
! 	    leave("In progress srvtab in this file.", 1);
      }
  }	
***************
*** 343,349 ****
      if (change || list) {
  	if ((backup_keyfile_fd = open(backup_keyfile, O_RDONLY, 0)) < 0) {
! 	    (void) fprintf(stderr, "%s: Unable to read %s: %s\n", argv[0],
! 			   backup_keyfile, sys_errlist[errno]);
! 	    exit(1);
  	}
      }
--- 325,329 ----
      if (change || list) {
  	if ((backup_keyfile_fd = open(backup_keyfile, O_RDONLY, 0)) < 0) {
! 		err(1, "unable to read %s", backup_keyfile);
  	}
      }
***************
*** 353,359 ****
  	     open(work_keyfile, O_WRONLY | O_CREAT | O_TRUNC, 
  		  SRVTAB_MODE)) < 0) {
! 	    (void) fprintf(stderr, "%s: Unable to write %s: %s\n", argv[0],
! 			   work_keyfile, sys_errlist[errno]);
! 	    exit(1);
  	}
      }
--- 333,337 ----
  	     open(work_keyfile, O_WRONLY | O_CREAT | O_TRUNC, 
  		  SRVTAB_MODE)) < 0) {
! 		err(1, "unable to write %s", work_keyfile);
  	}
      }
***************
*** 361,367 ****
  	if ((work_keyfile_fd =
  	     open(work_keyfile, O_APPEND | O_WRONLY, SRVTAB_MODE)) < 0) {
! 	    (void) fprintf(stderr, "%s: Unable to open %s for append: %s\n",
! 			   argv[0], work_keyfile, sys_errlist[errno]);
! 	    exit(1);
  	}
      }
--- 339,343 ----
  	if ((work_keyfile_fd =
  	     open(work_keyfile, O_APPEND | O_WRONLY, SRVTAB_MODE)) < 0) {
! 		err(1, "unable to append to %s", work_keyfile);
  	}
      }
***************
*** 456,463 ****
  			}
  			else {
! 			    (void)fprintf(stderr, 
! 					  "%s: Unable to revert keyfile: %s\n",
! 					  argv[0], sys_errlist[errno]);
! 			    leave("", 1);
  			}
  		    }
--- 432,437 ----
  			}
  			else {
! 				warn("unable to revert keyfile");
! 				leave("", 1);
  			}
  		    }
***************
*** 499,518 ****
      if (change || list) 
  	if (close(backup_keyfile_fd) < 0) {
! 	    (void) fprintf(stderr, "%s: Failure closing %s: %s\n",
! 			   argv[0], backup_keyfile, sys_errlist[errno]);
! 	    (void) fprintf(stderr, "continuing...\n");
  	}
      
      if (change || add) {
  	if (close(work_keyfile_fd) < 0) {
! 	    (void) fprintf(stderr, "%s: Failure closing %s: %s\n",
! 			   argv[0], work_keyfile, sys_errlist[errno]);
! 	    exit(1);
  	}
  	if (rename(work_keyfile, keyfile) < 0) {
! 	    (void) fprintf(stderr, "%s: Failure renaming %s to %s: %s\n",
! 			   argv[0], work_keyfile, keyfile, 
! 			   sys_errlist[errno]);
! 	    exit(1);
  	}
  	(void) chmod(backup_keyfile, keyfile_mode);
--- 473,485 ----
      if (change || list) 
  	if (close(backup_keyfile_fd) < 0) {
! 		warn("failure closing %s, continuing", backup_keyfile);
  	}
      
      if (change || add) {
  	if (close(work_keyfile_fd) < 0) {
! 		err(1, "failure closing %s", work_keyfile);
  	}
  	if (rename(work_keyfile, keyfile) < 0) {
! 		err(1, "failure renaming %s to %s", work_keyfile, keyfile);
  	}
  	(void) chmod(backup_keyfile, keyfile_mode);
