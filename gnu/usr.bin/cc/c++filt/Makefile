#
# $Id$
#

PROG =	c++filt
SRCS =	cplus-dem.c getopt.c getopt1.c
OBJS+=  underscore.o		# defeat 'make depend'
BINDIR=	/usr/bin
NOMAN=	1
CFLAGS+= -DMAIN -DIN_GCC -DVERSION=\"$(version)\"


#
# XXX This is a hack, but it seems to work.  libgcc1.a is supposed to be
# compiled by the native compiler, and libgcc2.a is meant to be compiled
# by *this* version of gcc.
#
# Normally, this does not make any difference, since we only have gcc, but
# when bootstrapping from gcc-2.6.3, we have to use the freshly built 2.7.2
# compiler for some of the libgcc2.c __attribute__ stuff.
#
.if exists(${.OBJDIR}/../cc)
XCC=	${.OBJDIR}/../cc/cc
.else
XCC=	${.CURDIR}/../cc/cc
.endif

.if exists(${.OBJDIR}/../cc1)
XCC+=	-B${.OBJDIR}/../cc1/
.else
XCC+=	-B${.CURDIR}/../cc1/
.endif

.if exists(${.OBJDIR}/../cpp)
XCC+=	-B${.OBJDIR}/../cpp/
.else
XCC+=	-B${.CURDIR}/../cpp/
.endif

CLEANFILES+= underscore.c
underscore.o: underscore.c

underscore.c:
	echo "int xxy_us_dummy;" >tmp-dum.c
	${XCC} -S tmp-dum.c
	echo '/*WARNING: This file is automatically generated!*/' >underscore.c
	if grep _xxy_us_dummy tmp-dum.s > /dev/null ; then \
	  echo "int prepends_underscore = 1;" >>underscore.c; \
	else \
	  echo "int prepends_underscore = 0;" >>underscore.c; \
	fi
	rm -f tmp-dum.c tmp-dum.s

.include <bsd.prog.mk>

