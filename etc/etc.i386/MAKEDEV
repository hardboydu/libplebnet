#!/bin/sh -
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Written and contributed by W. Jolitz 12/90
#
# Redistribution and use in source and binary forms are permitted provided
# that: (1) source distributions retain this entire copyright notice and
# comment, and (2) distributions including binaries display the following
# acknowledgement:  ``This product includes software developed by the
# University of California, Berkeley and its contributors'' in the
# documentation or other materials provided with the distribution and in
# all advertising materials mentioning features or use of this software.
# Neither the name of the University nor the names of its contributors may
# be used to endorse or promote products derived from this software without
# specific prior written permission.
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
#	@(#)MAKEDEV	5.2 (Berkeley) 6/22/90
#
# Device "make" file.  Valid arguments:
#	all	makes all known devices, standard number of units (or close)
#	std	standard devices
#	local	configuration specific devices
#
# Tapes:
#	wt*	QIC-interfaced (e.g. not SCSI) 3M cartridge tape
#	st*	"NEW type scsi tapes" (old driver uses the
#		block devices of the disks to get access)
#	ft*	QIC-40/QIC-80 3M cartridge tape (interfaced
#		via the floppy disk controller)
#
# Disks:
#	wd*	"winchester" disk drives (ST506,IDE,ESDI,RLL,...)
#	fd*	"floppy" disk drives (3 1/2", 5 1/4")
#	sd*	"scsi disks"
#	cd*	"scsi cdrom disks"
#	mcd*	"mitsumi cdrom disks"
#	scd*	"sony cdrom disks"
#	pcd*	"panasonic cdrom disks"
#	vn*	"vnode disks"
#
# Console ports:
#	vty*	virtual console devices for syscons/pcvt/codrv
# 
# Pointing devices:
#	mse*	Logitech and ATI Inport bus mouse
#	psm*	PS/2 mouse
#
# Terminal ports:
#       tty*    general purpose serial ports
#       cua*    dialout serial ports
#
# Pseudo terminals:
#	pty*	set of 32 master and slave pseudo terminals
#	vty*	virtual terminals using syscons/pcvt/codrv console
#
# Printers:
#	lpt*	stock lp
#
# Call units:
#
# Special purpose devices:
#	bpf*	packet filter
#	speaker	pc speaker
#	tw*	xten power controller
#	snd*	various sound cards
#	pcaudio PCM audio driver 
#	socksys iBCS2 socket system driver
#	vat	VAT compatibility audio driver (requires snd*)
#	gsc	Genius GS-4500 hand scanner
#	joy	pc joystick
#	tun	Tunneling IP device
#	spigot	Video Spigot video aquisition card
#	isdn*	ISDN devices
#
#	$Id: MAKEDEV,v 1.68 1995/02/14 21:13:14 ugen Exp $
#

PATH=/sbin:/bin/:/usr/bin:/usr/sbin:
umask 77

# Convert integer to partition number
dkitop() {
	local p

	case $1 in
	0) p=a;; 1) p=b;; 2) p=c;; 3) p=d;; 4) p=e;; 5) p=f;; 6) p=g;; 7) p=h;;
	default) p="?";;
	esac
	echo $p
}

# Convert disk (type, unit, slice, partition) to minor number
dkminor()
{
	echo $((32 * 65536 * $1 + 8 * $2 + 65536 * $3 + $4))
}

# Convert the last character of a tty name to a minor number.
ttyminor()
{
	case $unit in
	[0-9]) m=$unit;;
	a) m=10;; b) m=11;; c) m=12;; d) m=13;; e) m=14;; f) m=15;; g) m=16;;
	h) m=17;; i) m=18;; j) m=19;; k) m=20;; l) m=21;; m) m=22;; n) m=23;;
	o) m=24;; p) m=25;; q) m=26;; r) m=27;; s) m=28;; t) m=29;; u) m=30;;
	v) m=31;;
	default) m="?";;
	esac
	echo $m
}

# Raw partition for disks
dkrawpart=2

# Raw slice for disks
dkrawslice=0

for i
do
case $i in

all)
	sh MAKEDEV std						# standard
	sh MAKEDEV wd0 wd1 wd2 wd3 fd0 fd1 sd0 sd1 sd2 sd3 	# bdev, disk
	sh MAKEDEV cd0 mcd0 scd0 pcd0				# bdev, cdrom
	sh MAKEDEV ft0 wt0 st0 					# bdev, tape
	sh MAKEDEV ttyd0 ttyd1 ttyd2 ttyd3			# cdev, serial
	sh MAKEDEV cuaa0 cuaa1 cuaa2 cuaa3			# cdev, serial
	sh MAKEDEV lpt0 lpt1 lpt2				# cdev, printer
	sh MAKEDEV pty0 ch0 tw0 bpf0 				# cdev
	sh MAKEDEV speaker pcaudio psm0 mse0			# cdev
	sh MAKEDEV vty4						# cdev
	;;
std)
	rm -f console drum mem kmem null zero io tty klog stdin stdout stderr
	rm -f lkm
	mknod console	c 0 0;	chmod 600 console;	chown root.wheel console
	mknod drum	c 4 0;	chmod 640 drum;		chown root.kmem drum
	mknod kmem	c 2 1;	chmod 640 kmem;		chown root.kmem kmem
	mknod mem	c 2 0;	chmod 640 mem;		chown root.kmem mem
	mknod null	c 2 2;	chmod 666 null;		chown root.wheel null
	mknod zero	c 2 12;	chmod 666 zero;		chown root.wheel zero
	mknod io	c 2 14;	chmod 640 io;		chown root.kmem io
	mknod tty	c 1 0;	chmod 666 tty;		chown root.wheel tty
	mknod klog	c 7 0;	chmod 600 klog;		chown root.wheel klog
	mknod stdin	c 22 0; chmod 666 stdin;	chown root.wheel stdin
	mknod stdout	c 22 1; chmod 666 stdout;	chown root.wheel stdout
	mknod stderr	c 22 2; chmod 666 stderr;	chown root.wheel stderr
	mknod lkm	c 32 0;	chmod 644 lkm;		chown root.wheel lkm
	rm -f fd/*
	mkdir fd > null 2>&1
	(cd fd && eval `echo "" | awk ' BEGIN { \
		for (i = 0; i < 64; i++) \
	 		printf("mknod %d c 22 %d;", i, i)}'`)
	chown -R bin.bin fd
	chmod 555 fd
	chmod 666 fd/*
	;;


# Create device files for new Archive/Wangtek QIC-02 tape driver (vak)
wt*)
	umask 7 ; u=`expr $i : '..\(.*\)'`
	if [ x$u = x ]; then u=0; fi
	rm -f r[Ww]t$u nr[Ww]t$u r[Ww]t$u[a-f] nr[Ww]t$u[a-f]
	mknod rwt${u}   c 10 `expr  0 + $u`	# default density, 512b blocks
	mknod nrwt${u}  c 10 `expr  4 + $u`
#	mknod rWt${u}   c 10 `expr 64 + $u`	# default density, 1024b blocks
#	mknod nrWt${u}  c 10 `expr 68 + $u`
	mknod rwt${u}b  c 10 `expr 16 + $u`	# 60 megabytes
	mknod nrwt${u}b c 10 `expr 20 + $u`
	mknod rwt${u}c  c 10 `expr 24 + $u`     # 120 megabytes
	mknod nrwt${u}c c 10 `expr 28 + $u`
	mknod rwt${u}d  c 10 `expr 32 + $u`	# 150 megabytes
	mknod nrwt${u}d c 10 `expr 36 + $u`
#	mknod rwt${u}e  c 10 `expr 40 + $u`	# 300 megabytes?
#	mknod nrwt${u}e c 10 `expr 44 + $u`
#	mknod rwt${u}f  c 10 `expr 48 + $u`	# 600 megabytes?
#	mknod nrwt${u}f c 10 `expr 52 + $u`
	chown root.operator r[Ww]t$u nr[Ww]t$u r[Ww]t$u[a-f] nr[Ww]t$u[a-f]
	umask 77
	;;

fd*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	name=fd; blk=2; chr=9;
	rm -f $name$unit* r$name$unit*
	case $unit in
	0|1|2|3)
		mknod ${name}${unit}   b $blk `expr $unit '*' 64`
		mknod r${name}${unit}  c $chr `expr $unit '*' 64`
		# Fake BSD partitions
		for i in a b c d e f g h
		do
			ln ${name}${unit} ${name}${unit}$i
			ln r${name}${unit} r${name}${unit}$i
		done
		# User-readable and programmer-readable name sets

		mknod ${name}${unit}.1720  b $blk `expr $unit '*' 64 + 1`
		mknod r${name}${unit}.1720 c $chr `expr $unit '*' 64 + 1`
		# ln ${name}${unit}.1720 ${name}${unit}135hs21
		# ln r${name}${unit}.1720 r${name}${unit}135hs21

		mknod ${name}${unit}.1480  b $blk `expr $unit '*' 64 + 2`
		mknod r${name}${unit}.1480 c $chr `expr $unit '*' 64 + 2`
		# ln ${name}${unit}.1480 ${name}${unit}135hs18
		# ln r${name}${unit}.1480 r${name}${unit}135hs18
		# ln ${name}${unit}.1480 ${name}${unit}96hs18
		# ln r${name}${unit}.1480 r${name}${unit}96hs18

		mknod ${name}${unit}.1440  b $blk `expr $unit '*' 64 + 3`
		mknod r${name}${unit}.1440 c $chr `expr $unit '*' 64 + 3`
		# ln ${name}${unit}.1440 ${name}${unit}135
		# ln r${name}${unit}.1440 r${name}${unit}135
		# ln ${name}${unit}.1440 ${name}${unit}135ds18
		# ln r${name}${unit}.1440 r${name}${unit}135ds18
		# ln ${name}${unit}.1440 ${name}${unit}96ds18
		# ln r${name}${unit}.1440 r${name}${unit}96ds18

		mknod ${name}${unit}.1200  b $blk `expr $unit '*' 64 + 4`
		mknod r${name}${unit}.1200 c $chr `expr $unit '*' 64 + 4`
		# ln ${name}${unit}.1200 ${name}${unit}96
		# ln r${name}${unit}.1200 r${name}${unit}96
		# ln ${name}${unit}.1200 ${name}${unit}96ds15
		# ln r${name}${unit}.1200 r${name}${unit}96ds15
		# ln ${name}${unit}.1200 ${name}${unit}135ds15
		# ln r${name}${unit}.1200 r${name}${unit}135ds15

		mknod ${name}${unit}.820  b $blk `expr $unit '*' 64 + 5`
		mknod r${name}${unit}.820 c $chr `expr $unit '*' 64 + 5`
		# ln ${name}${unit}.820 ${name}${unit}96hs10
		# ln r${name}${unit}.820 r${name}${unit}96hs10
		# ln ${name}${unit}.820 ${name}${unit}135hs10
		# ln r${name}${unit}.820 r${name}${unit}135hs10

		mknod ${name}${unit}.800  b $blk `expr $unit '*' 64 + 6`
		mknod r${name}${unit}.800 c $chr `expr $unit '*' 64 + 6`
		# ln ${name}${unit}.800 ${name}${unit}96ds10
		# ln r${name}${unit}.800 r${name}${unit}96ds10
		# ln ${name}${unit}.800 ${name}${unit}135ds10
		# ln r${name}${unit}.800 r${name}${unit}135ds10

		mknod ${name}${unit}.720  b $blk `expr $unit '*' 64 + 7`
		mknod r${name}${unit}.720 c $chr `expr $unit '*' 64 + 7`
		# ln ${name}${unit}.720 ${name}${unit}96ds9
		# ln r${name}${unit}.720 r${name}${unit}96ds9
		# ln ${name}${unit}.720 ${name}${unit}135ds9
		# ln r${name}${unit}.720 r${name}${unit}135ds9

		mknod ${name}${unit}.360  b $blk `expr $unit '*' 64 + 8`
		mknod r${name}${unit}.360 c $chr `expr $unit '*' 64 + 8`
		# ln ${name}${unit}.360 ${name}${unit}48
		# ln r${name}${unit}.360 r${name}${unit}48
		# ln ${name}${unit}.360 ${name}${unit}48ds9
		# ln r${name}${unit}.360 r${name}${unit}48ds9

		chgrp operator ${name}${unit}* r${name}${unit}*
		chmod 640 ${name}${unit}* r${name}${unit}*
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;


ft*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	name=ft; blk=2; chr=9;
	rm -f $name$unit* r$name$unit*
	case $unit in
	0|1|2|3)
		mknod ${name}${unit}   b $blk `expr $unit '*' 64 + 32`
		mknod r${name}${unit}  c $chr `expr $unit '*' 64 + 32`
		ln ${name}${unit} ${name}${unit}a
		ln r${name}${unit} r${name}${unit}a
		chgrp operator ${name}${unit}* r${name}${unit}*
		chmod 640 ${name}${unit}* r${name}${unit}*
		;;
	*)
		echo bad unit for tape in: $i
		;;
	esac
	umask 77
	;;


sd*|vn*|wd*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	sd*) name=sd; blk=4;  chr=13;;
	wd*) name=wd; blk=0;  chr=3;;
	vn*) name=vn; blk=15; chr=43;;
	esac
	rm -f $name$unit? r$name$unit?
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 8 + 1`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 8 + 2`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 8 + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 8 + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 8 + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 8 + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 8 + 7`
		case $i in
		wd*)
		mknod ${name}${unit}i	b $blk `expr $unit '*' 8 + 64`
		mknod ${name}${unit}j	b $blk `expr $unit '*' 8 + 65`
		mknod ${name}${unit}k	b $blk `expr $unit '*' 8 + 66`
		mknod ${name}${unit}l	b $blk `expr $unit '*' 8 + 67`
		mknod ${name}${unit}m	b $blk `expr $unit '*' 8 + 68`
		esac
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 8 + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + 2`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 8 + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 8 + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 8 + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 8 + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 8 + 7`
		case $i in
		wd*)
		mknod r${name}${unit}i	c $chr `expr $unit '*' 8 + 64`
		mknod r${name}${unit}j	c $chr `expr $unit '*' 8 + 65`
		mknod r${name}${unit}k	c $chr `expr $unit '*' 8 + 66`
		mknod r${name}${unit}l	c $chr `expr $unit '*' 8 + 67`
		mknod r${name}${unit}m	c $chr `expr $unit '*' 8 + 68`
		esac
		chgrp operator ${name}${unit}[a-m] r${name}${unit}[a-m]
		chmod 640 ${name}${unit}[a-m] r${name}${unit}[a-m]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

# Sliced disks.
ssd*|svn*|swd*)
	umask 37
	case $i in
	ssd*) name=sd; blk=4;  chr=13;;
	swd*) name=wd; blk=0;  chr=3;;
	svn*) name=vn; blk=15; chr=43;;
	esac
	unit=`expr $i : '...\(.*\)'`
	rm -f $name$unit* r$name$unit*
	case $unit in
	0|1|2|3|4|5|6)
		# Whole disk is on (non-)slice 0, (non-)partition C.
		minor=`dkminor 0 $unit $dkrawslice $dkrawpart`
		mknod  ${name}${unit} b $blk $minor
		mknod r${name}${unit} c $chr $minor
		for slice in 1 2 3 4
		do
			for part in 0 1 2 3 4 5 6 7
			do
				minor=`dkminor 0 $unit $slice $part`
				partname=`dkitop $part`
				mknod ${name}${unit}s${slice}${partname} \
				      b $blk $minor
				mknod r${name}${unit}s${slice}${partname} \
				      c $chr $minor
			done
			partname=`dkitop $dkrawpart`
			ln ${name}${unit}s${slice}${partname} \
			   ${name}${unit}s${slice}
			ln r${name}${unit}s${slice}${partname} \
			   r${name}${unit}s${slice}
		done
		chgrp operator ${name}${unit}* r${name}${unit}*
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

uk*)
	unit=`expr $i : 'uk\(.*\)'`
	rm -f uk$unit
	mknod uk$unit c 27 $unit
	;;

pty*)
	class=`expr $i : 'pty\(.*\)'`
	case $class in
	0) offset=0 name=p;;
	1) offset=32 name=q;;
	2) offset=64 name=r;;
	3) offset=96 name=s;;
# Note that xterm (at least) only look at p-s.
        4) offset=128 name=P;;
        5) offset=160 name=Q;;
        6) offset=192 name=R;;
        7) offset=224 name=S;;
 	# This still leaves [tuTU].
	*) echo bad unit for pty in: $i;;
	esac
	case $class in
	0|1|2|3|4|5|6|7)
		umask 0
		eval `echo $offset $name | awk ' { b=$1; n=$2 } END { \
			for (i = 0; i < 32; i++) {
				c = substr("0123456789abcdefghijklmnopqrstuv", i + 1, 1); \
				printf("rm -f tty%s%s pty%s%s; \
					mknod tty%s%s c 5 %d; \
					mknod pty%s%s c 6 %d; \
					chown root.wheel tty%s%s pty%s%s;", \
					n, c, n, c, \
					n, c, b+i, \
					n, c, b+i, \
					n, c, n, c); \
			} \
		}'`
		umask 77
		;;
	esac
	;;

st*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	chr=14;

	#remove old stype names
	rm -f [hml]rst[0123456] [hml][en]rst[0123456] [hml]enrst[0123456]  
	#remove new style names
	rm -f rst${unit} [en]rst${unit} enrst${unit}  
	rm -f rst${unit}.[0123] nrst${unit}.[0123]\
		 erst${unit}.[0123] st${unit}ctl.[0123]

	case $unit in
	0|1|2|3|4|5|6)
		for mode in 0 1 2 3
		do
			mknod rst${unit}.${mode} c $chr `expr $unit '*' 16 + $mode '*' 4 + 0`
			mknod nrst${unit}.${mode} c $chr `expr $unit '*' 16 + $mode '*' 4 + 1`
			mknod erst${unit}.${mode} c $chr `expr $unit '*' 16 + $mode '*' 4 + 2`
			mknod st${unit}ctl.${mode} c $chr `expr $unit '*' 16 + $mode '*' 4 + 3`
			chgrp operator 	rst${unit}.${mode}\
					nrst${unit}.${mode} \
					erst${unit}.${mode} \
					st${unit}ctl.${mode}
			chmod 640 	rst${unit}.${mode}\
					nrst${unit}.${mode} \
					erst${unit}.${mode} 
			chmod 660	st${unit}ctl.${mode}
		done
		ln rst${unit}.0 rst${unit}
		ln nrst${unit}.0 nrst${unit}
		ln erst${unit}.0 erst${unit}
		;;
	*)
		echo bad unit for tape in: $i
  		;;
  	esac
  	umask 77
	;;

ch*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	ch*) name=ch;  chr=17;;
	esac
	rm -f $name$unit
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}	c $chr `expr $unit '*' 16 + 0`
		chgrp operator ${name}${unit}
		chmod 640 ${name}${unit}
		;;
	*)
		echo bad unit for media changer in: $i
		;;
	esac
	umask 77
	;;

cd*|mcd*|scd*|pcd*)
	umask 2 ;
	case $i in
	cd*) unit=`expr $i : '..\(.*\)'`; name=cd; blk=6; chr=15;;
	mcd*) unit=`expr $i : '...\(.*\)'`; name=mcd; blk=7; chr=29;;
	scd*) unit=`expr $i : '...\(.*\)'`; name=scd; blk=16; chr=45;;
	pcd*) unit=`expr $i : '...\(.*\)'`; name=pcd; blk=17; chr=46;;
	esac
	rm -f $name$unit? r$name$unit?
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}c   b $blk `expr $unit '*' 8 + 2`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}c  c $chr `expr $unit '*' 8 + 2`
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

lpt*)
	unit=`expr $i : 'lpt\(.*\)'`
	rm -f lpt$unit
	rm -f lpctl$unit
	mknod lpt$unit c 16 $unit
	mknod lpctl$unit c 16 `expr $unit + 128`
	chown root.wheel lpt$unit
	chown root.wheel lpctl$unit
	;;

tw*)
	unit=`expr $i : 'tw\(.*\)'`
	rm -f tw$unit
	mknod tw$unit c 19 $unit
	chown bin.bin tw$unit
	;;

# Use this to create virtual consoles for syscons, pcvt or codrv
# ttyv0-b
# use as MAKEDEV vtyNN to create NN entries
vty*)
	chr=12
	units=`expr $i : 'vty\(.*\)'`
	eval `echo ${chr} ${units} | awk ' { c=$1; n=$2 } END {
		for (i = 0; i < n; i++)
			printf("rm -f ttyv%01x; mknod ttyv%01x c %d %d; \
				chown root.wheel ttyv%01x;", \
				i, i, c, i, i); }'`
	ln -fs ttyv0 vga	# XXX X still needs this pccons relic
	;;

bpf*)
	unit=`expr $i : 'bpf\(.*\)'`
	rm -f bpf$unit
	mknod bpf$unit c 23 $unit
	chown root.wheel bpf$unit
	;;

speaker)
	rm -f speaker
	mknod speaker c 26 0
	chown root.wheel speaker
	;;

cuaa?|cua?)
	umask 7
	unit=`expr $i : 'cua.*\(.\)$'`
	rm -f cua*a$unit
	m=`ttyminor $unit`
	mknod cuaa$unit c 28 `expr $m + 128`
	mknod cuaia$unit c 28 `expr $m + 32 + 128`
	mknod cuala$unit c 28 `expr $m + 64 + 128`
	chown uucp.dialer cua*a$unit
	umask 77
	;;

ttyd?|tty?)
	unit=`expr $i : 'tty.*\(.\)$'`
	rm -f tty*d$unit
	m=`ttyminor $unit`
	mknod ttyd$unit c 28 $m
	mknod ttyid$unit c 28 `expr $m + 32`
	mknod ttyld$unit c 28 `expr $m + 64`
	chown root.wheel tty*d$unit
	;;

mse*)
	unit=`expr $i : 'mse\(.*\)'`
	chr=27
	rm -f mse$unit
	mknod mse$unit c $chr `expr $unit '*' 2 + 1`	# non-blocking for X11
	chown root.wheel mse$unit
	;;

psm*)
	unit=`expr $i : 'psm\(.*\)'`
	chr=21
	rm -f psm$unit
	mknod psm$unit c $chr `expr $unit '*' 2 + 1`	# non-blocking for X11
	chown root.wheel psm$unit
	;;

mouse*)
	name=`expr $i : 'mouse\(.*\)'`
	if [ ! -c $name ]; then
		$0 $name			# make the appropriate device
	fi
	rm -f mouse
	ln -s $name mouse
	;;

pcaudio)
	rm -f pcaudio pcaudioctl
	mknod pcaudio c 24 0
	mknod pcaudioctl c 24 128
	chown root.wheel pcaudio pcaudioctl
	chmod 666 pcaudio pcaudioctl
	;;

socksys)
	rm -f socksys nfsd spx
	mknod socksys c 41 0
	mknod spx c 41 1
	ln -s /dev/socksys /dev/nfsd
	chown root.wheel socksys nfsd spx
	chmod 666 socksys nfsd spx
	;;

snd*)
	chr=30
	rm -f mixer		# Mixer	[ Control ]
	mknod mixer 		c $chr 0
	chmod 666 mixer

	rm -f sequencer		# Sequencer [ FM Synth and MIDI output ]
	mknod sequencer		c $chr 1
	chmod 666 sequencer

	rm -f midi		# Midi input [ Not implemented ]
	mknod midi		c $chr 2

	rm -f dsp		# DSP [ Digitized voice ]
	mknod dsp		c $chr 3
	chmod 666 dsp

	rm -f audio		# SPARC audio [ Not fully implemented ]
	mknod audio		c $chr 4
	chmod 666 audio

	rm -f dsp16		# DSP16 [ Same as dsp, except 16 bits ]
	mknod dsp16		c $chr 5
	chmod 666 dsp16

	rm -f sndstat		# Status Device [ Debugging interface ]
	mknod sndstat		c $chr 6
	chmod 666 sndstat

	rm -f pro_midi		# PRO_MIDI [PAS midi input and output]
	mknod pro_midi		c $chr 15
	chmod 666 pro_midi

	rm -f dsp1		# DSP 1 [ SB emulation of PAS16 or 2nd audio ]
	mknod dsp1		c $chr 19
	chmod 666 dsp1

	rm -f audio1	# Sparc Audio 1 [ SB emulation of PAS16 or 2nd audio ]
	mknod audio1	c $chr 20
	chmod 666 audio1
	;;

vat)
	rm -f vatio
	mknod vatio c 25 128
	chown root.wheel vatio
	chmod 660 vatio
	;;

gsc)
	rm -f gsc0
	mknod gsc0 c 47 0
	chmod 666 gsc0
	;;

apm)
	rm -f apm0
	mknod apm0 c 39 0
	chown root.wheel apm0
	chmod 660 apm0
	;;

ttyx?|ttyy?|ttyz?)
	case $i in
	*0) unit=0;;    *1) unit=1;;    *2) unit=2;;    *3) unit=3;;
	*4) unit=4;;    *5) unit=5;;    *6) unit=6;;    *7) unit=7;;
	*8) unit=8;;    *9) unit=9;;    *a) unit=10;;   *b) unit=11;;
	*c) unit=12;;   *d) unit=13;;   *e) unit=14;;   *f) unit=15;;
	esac
	case $i in
	ttyy?)  unit=`expr $unit \+ 16`;;
	ttyz?)  unit=`expr $unit \+ 32`;;
	esac
	rm -f $i
	mknod $i c 42 $unit
	chown uucp.wheel $i
	;;

cronyx)
	rm -f cronyx
	mknod cronyx c 42 63
	chown 444 cronyx
  	;;

joy)
	rm -f joy0 joy1
	mknod joy0 c 51 0
	mknod joy1 c 51 1
	chmod 444 joy0 joy1
	;;

spigot)
	rm -f spigot
	mknod spigot 11 0
	chmod 444 spigot
	;;

tun?)
	unit=`expr $i : 'tun\(.*\)'`
	rm -f tun$unit
	mknod tun$unit c 52 $unit
	chown uucp.dialer tun$unit
	;;

snp?)
	unit=`expr $i : 'snp\(.*\)'`
	rm -f snp$unit
	mknod snp$unit c 53 $unit
	chown root.wheel snp$unit
	chmod 600 snp$unit
	;;

# Valid arguments to isdn:
#	none	makes all the node but nic0
#	5000	makes nic0 for Niccy 5000
#	3008	makes nic0 for Niccy 3008
#       3009    makes nic0 for Niccy 3009
#       1000    makes nodes for Niccy 1000
#       tel*    makes nodes for TELES S0
#
isdn*)
	type=`expr $i : 'isdn\(.*\)'`
	if [ "X${type}" = "X" ]; then
		type=none
	fi
	unit=54
	rm -f nic0 snic0 n?ic0 isdn isdn? ity?? itel?? ispy
	mknod /dev/n8ic0 c $unit 0
	mknod /dev/snic0 c `expr $unit + 4` 0
	mknod /dev/n9ic0 c `expr $unit + 6` 0
	mknod /dev/isdn c `expr $unit + 1` 0
	mknod /dev/isdn1 c `expr $unit + 1` 1
	mknod /dev/isdn2 c `expr $unit + 1` 2
	mknod /dev/ity00 c `expr $unit + 2` 0
	mknod /dev/ity01 c `expr $unit + 2` 1
	mknod /dev/ityo0 c `expr $unit + 2` 130
	mknod /dev/ityo1 c `expr $unit + 2` 131
	mknod /dev/itel00 c `expr $unit + 3` 0
	mknod /dev/itel01 c `expr $unit + 3` 1
	mknod /dev/ispy c `expr $unit + 5` 0
	chmod 600 n8ic0 n9ic0 snic0 isdn isdn? ity?? itel?? ispy
	chown root n8ic0 n9ic0 snic0 isdn isdn? ity?? itel?? ispy
	chown uucp ityo[01]
	case $type in
	5000)
		ln /dev/snic0 /dev/nic0
		chmod 600 /dev/nic0
		chown root /dev/nic0
		;;
	3008)
		ln /dev/n8ic0 /dev/nic0
		chmod 600 /dev/nic0
		chown root /dev/nic0
		;;
	3009)
		ln /dev/n9ic0 /dev/nic0
		chmod 600 /dev/nic0
		chown root /dev/nic0
		;;
	1000|tel*|TEL*|none)
		;;
	*)
		echo "No such ISDN device subtype: $type"
		;;
	esac
	;;

local)
	umask 0			# XXX should be elsewhere
	sh MAKEDEV.local
	umask 77
	;;

*)
	echo $i - no such device name
	;;

esac
done
