#!/bin/sh
# install1.fs disk 'install'
# Simplified, interactive NetBSD installation script.
# D.E. Silvia (dsilvia@net.com)
#
# (and again hacked on by rgrimes 1993/08/10,
#  for FreeBSD, changed only the printing messages, not the comments
#  about what OS this is for, now uses variable ${OPSYSTEM},
#  converted to use cpio)
#
# (once again hacked on by rgrimes 1993/07/29,
#  disabled old disktab.preinstall,
#  added questions for what blocking factor to use in the file system,
#  added (heads) to clarify what disk tracks means)
#
# (heavily hacked by cgd)
# (and again by rwgrimes, for bad144 support and some error checking)
#
# Provides for variable swap and multiple partitions.
#
# Installs first minimal part of basic NetBSD system.
#
# Does not appear to work properly IF not using whole disk _AND_ there is
# no DOS partition (kernel bug?  Tries to chroot to partition 'd' :-{ )
#
# Currently, no method for checking to see if the designated disk type is
# already in /etc/disktab.  You can edit it out of the file after installation.
#
OPSYSTEM=FreeBSD

echo    "Welcome to ${OPSYSTEM}."
echo    ""
echo    "This program is designed to help put ${OPSYSTEM} on a hard disk,"
echo    "in a simple and rational way.  We'll ask you several questions,"
echo    "and it would probably be useful to have a disk's hardware"
echo	"manual, the installation notes, and a calculator handy."
echo    ""
echo	"In particular, we need to know some reasonably detailed"
echo	"information about the disk's geometry, because there is currently"
echo	"no way we can figure out this information by ourselves."
echo    ""
echo	"As with anything which modifies a hard drive's contents, this"
echo	"program can cause SIGNIFICANT data loss, and we strongly recommend"
echo	"making sure that the hard drive is backed up before going further with"
echo	"the installation process."
echo    ""
echo -n "Proceed with installation? [y] "
read resp junk
if [ "$resp" = "" ]; then
	resp=y
fi
echo $resp 
case $resp in
	y*|Y*)
		echo
		echo    "Cool!  Let's get to it..."
		echo	""
		echo	"If a mistake is made along the way, don't bail out."
		echo	"At the end, you have the option to redo the configuration."
		echo	"If you really must bail out at some point, then type <CTRL>+C,"
		echo	"and enter \`halt' at the command prompt \`#'."
		;;
	*)
		echo    ""
		echo    "OK, then.  enter 'halt' to halt the machine."
		echo    "Once the machine has halted, remove the floppy,"
		echo    "and press any key to reboot."
		exit
		;;
esac

verified_install=""
while [ "$verified_install" = "" ]; do	# Begin of Big Loop

rotdelay=""
drivename=wd0
drivetype=wd
sect_fwd=""
echo    ""
echo    "First, we need to know the drive type.  This can be can be one of"
echo	"ESDI, SCSI, ST506, or IDE."
echo -n "Drive type? [IDE] "
read type junk
if [ "$type" = "" ]; then
	type=IDE
fi
echo $type
case "$type" in
	e*|E*|st*|ST*)
		echo -n "Does it support _automatic_ sector remapping? [y] "
		read remap junk
		case "$remap" in
			n*|N*)
				sect_fwd="sf:"
				;;
		esac
		;;
	i*|I*)
		type=ST506
		;;
	sc*|SC*)
		drivename=sd0
		drivetype=sd
		type=SCSI
		rotdelay="-d 0"
		;;
	*)
		echo "Unknown type.  Assuming ST506 with automatic sectoring..."
		type=ST506
		;;
esac
echo    ""
echo    "Disk is of device type $drivetype."
echo    "Installing on device /dev/$drivename..."
echo    ""
echo	"Now we want to build a data base entry in /etc/disktab describing"
echo	"the geometry of the /dev/$drivename disk.  The name of the entry"
echo	"should be descriptive of the disk's type and model.  For example,"
echo	"a Maxtor IDE, model 7080 disk might be named \`maxtor7080'."
echo -n "Disk label name (one word, please)? [mfr_model] "
read name junk
if [ "$name" = "" ]; then
	name=mfr_model
fi
echo $name
echo	""
echo -n "Number of bytes per disk sector? [512] "
read bytes_per_sect
if [ "$bytes_per_sect" = "" ]; then
	bytes_per_sect=512
fi
echo $bytes_per_sect
echo	""
echo -n "Total number of disk cylinders? [1024] "
read cyls_per_disk
if [ "$cyls_per_disk" = "" ]; then
	cyls_per_disk=1024
fi
echo $cyls_per_disk
echo	""
echo -n "Number of disk heads (i.e., tracks/cylinder)? [12] "
read tracks_per_cyl
if [ "$tracks_per_cyl" = "" ]; then
	tracks_per_cyl=12
fi
echo $tracks_per_cyl
echo	""
echo -n "Number of disk sectors (i.e., sectors/track)? [36] "
read sects_per_track
if [ "$sects_per_track" = "" ]; then
	sects_per_track=36
fi
echo $sects_per_track
echo	""
cylindersize=`expr $sects_per_track \* $tracks_per_cyl`
disksize=`expr $cylindersize \* $cyls_per_disk`
mb_sect=`expr 1024 \* 1024 / $bytes_per_sect`
mb_per_disk=`expr $disksize / $mb_sect`
echo "Disk has a total of $mb_per_disk Mb."
echo "For greater efficiency, partitions should begin and end on cylinder"
echo "boundaries.  And there should be at least two of them: one for the root" 
echo "filesystem and one for the /usr filesystem.  If you know the size NN"
echo "in Megabytes (Mb) of a partition you want, then use the following formula"
echo "to determine the number NC of cylinders to use:"
echo	"	NC = integer { ( NN * $mb_sect ) /  $cylindersize }"
echo -n "Total size of the ${OPSYSTEM} portion of the disk (in cylinders)? [${cyls_per_disk}] "
read partition junk
if [ "$partition" = "" ]; then
	partition=$cyls_per_disk
fi
echo $partition
partition=`expr $partition \* $cylindersize`
part_offset=0
if [ $partition -lt $disksize ]; then
	echo ""
	echo -n "Offset from beginning of the disk of first ${OPSYSTEM} partition (in cylinders)? [0] "
	read part_offset junk
	if [ "$part_offset" = "" ]; then
		part_offset=0
	fi
	echo $part_offset
fi
part_offset=`expr $part_offset \* $cylindersize`
badspacesec=0
if [ "$sect_fwd" = "sf:" ]; then
	badspacecyl=`expr $sects_per_track + 126`
	badspacecyl=`expr $badspacecyl + $cylindersize - 1`
	badspacecyl=`expr $badspacecyl / $cylindersize`
	badspacesec=`expr $badspacecyl \* $cylindersize`
	echo ""
	echo -n "Using $badspacesec sectors ($badspacecyl cylinders) for the "
	echo "bad144 bad block table"
fi
whats_left=`expr $partition - $badspacesec`
cyl_left=`expr $whats_left / $cylindersize`
mb_left=`expr $whats_left / $mb_sect`
echo	""
echo	"There are $mb_left Mb ($cyl_left cylinders) left to allocate."
echo	""
# set default root partition to 15MB
part_size=`expr \( 15 \* $mb_sect \) /  $cylindersize`
if [ $part_size -gt $cyl_left ]; then
	part_size=$cyl_left
fi
echo "The root partition is usually no larger than about 15 Mb, and sometimes as"
echo "small as 7 or 8 Mb."
root=0
while [ $root -eq 0 ]; do
	echo -n "Root partition size (in cylinders)? [${part_size}] "
	read root
	if [ "$root" = "" ]; then
		root=$part_size
	fi
	echo $root
	case $root in
		[1-9]*)
			root=`expr $root \* $cylindersize`
			total=$root
			if [ $total -gt $whats_left ]; then
				echo Total is greater than remaining free space
				root=0
			else
				part_used=`expr $root + $badspacesec`
			fi
			;;
		*)
			root=0
			;;
	esac
done
root_offset=$part_offset
whats_left=`expr $partition - $part_used`
cyl_left=`expr $whats_left / $cylindersize`
mb_left=`expr $whats_left / $mb_sect`
echo	""
echo "We can build the root filesystem with block/fragment sizes of either"
echo "	1) 4k/512, to save disk space at the expense of speed, or"
echo "	2) 8k/1k for speed at the expense of disk space."
echo -n "Which blocking factor should we use for the root filesystem? [2] "
read blocking_factor
if [ "$blocking_factor" = "" ]; then
	blocking_factor=2
fi
echo $blocking_factor
fragsize=`expr $bytes_per_sect \* $blocking_factor`
blocksize=`expr $bytes_per_sect \* $blocking_factor \* 8`
minswap=`expr 8 \* $mb_sect`
min_cyl=`expr $minswap / $cylindersize`
swap=0
while [ $swap -eq 0 ]; do
	echo
	echo    "$mb_left Mb ($cyl_left cylinders) remaining in ${OPSYSTEM}"
	echo	"portion of disk."
	echo
	echo	"Minimum swap space is $min_cyl cylinders."
	echo	"If your RAM size is NR Mb, then the recomended swap size NS (in cylinders)"
	echo	"for running X is:"
	echo	" 	NS = integer { ( 2.1 x NR x $mb_sect ) / ${cylindersize} }"
	
	# guess memory size
	mb_ram=16
	part_size=`expr \( 21 \* $mb_ram \* $mb_sect \) / 10`
	part_size=`expr $part_size / ${cylindersize}`

	# but not swap size more than 10% of disk size...
	swap_quot=`expr $mb_left / $mb_ram`
	if [ $swap_quot -lt 10 ]; then
		part_size=$min_cyl
	fi
	echo -n "Swap partition size (in cylinders)? [${part_size}] "
	read swap_cyl junk
	if [ "$swap_cyl" = "" ]; then
		swap_cyl=$part_size
	fi
	echo $swap_cyl
	case $swap_cyl in
		[1-9]*)
			swap=`expr $swap_cyl \* $cylindersize`
			if [ $swap -gt $whats_left ]; then
				echo "Swap size is greater than remaining free space"
				swap=0
			fi
			if [ $swap_cyl -lt $min_cyl ]; then
				echo "Swap space must be greater than $min_cyl"
				swap=0
			fi
			;;
		*)
			swap=0
			;;
	esac
done
echo ""
swap_offset=`expr $root_offset + $root`
part_used=`expr $part_used + $swap`
mount -u /dev/fd0a /
echo    "" >/etc/disktab
echo    "$name|${OPSYSTEM} installation generated:\\" >>/etc/disktab
echo    "	:dt=${type}:ty=winchester:\\" >>/etc/disktab
echo -n "	:nc#${cyls_per_disk}:ns#${sects_per_track}" >>/etc/disktab
echo    ":nt#${tracks_per_cyl}:\\" >>/etc/disktab
echo    "	:se#${bytes_per_sect}:${sect_fwd}\\" >>/etc/disktab
echo -n "	:pa#${root}:oa#${root_offset}" >>/etc/disktab
echo    ":ta=4.2BSD:ba#${blocksize}:fa#${fragsize}:\\" >>/etc/disktab
echo    "	:pb#${swap}:ob#${swap_offset}:tb=swap:\\" >>/etc/disktab
echo    "	:pc#${partition}:oc#${part_offset}:\\" >>/etc/disktab
ename="";fname="";gname="";hname=""

echo    ""
echo	"Now we enter information about any other partitions and filesystems"
echo	"to be created in the ${OPSYSTEM} portion of the disk.  This process"
echo	"is complete when we've filled up all remaining space in the ${OPSYSTEM}"
echo	"portion of the disk."

while [ $part_used -lt $partition ]; do
	part_size=0
	whats_left=`expr $partition - $part_used`
	cyl_left=`expr $whats_left / $cylindersize`
	mb_left=`expr $whats_left / $mb_sect`
	while [ $part_size -eq 0 ]; do
		echo	""
		echo    "$mb_left Mb ($cyl_left cylinders) remaining in ${OPSYSTEM} portion of disk."
		echo
		echo -n "Next partition size (in cylinders)? [${cyl_left}] "
		read part_size junk
		if [ "$part_size" = "" ]; then
			part_size=$cyl_left
		fi
		echo $part_size
		case $part_size in
			[1-9]*)
				part_size=`expr $part_size \* $cylindersize`
				total=`expr $part_used + $part_size`
				if [ $total -gt $partition ]; then
					echo Total is greater than partition size
					part_size=0
				else
					part_used=$total
					part_name=""
					while [ "$part_name" = "" ]; do
						echo
						echo -n "On which directory should this filesystem be mounted? [usr] "
						read part_name junk
						if [ "$part_name" = "" ]; then
							part_name=usr
						fi
						part_name=`expr "$part_name" : '/*\(.*\)'`
						echo $part_name
					done
				fi
				;;
			*)
				part_size=0
				;;
		esac
	done
	echo
	echo "We can build this filesystem with block/fragment sizes of either:"
	echo "	1) 4k/512, to save disk space at the expense of speed, or"
	echo "	2) 8k/1k for speed at the expense of disk space."
	echo -n "Which blocking factor should we use for this filesystem? [1] "
	read blocking_factor junk
	if [ "$blocking_factor" = "" ]; then
		blocking_factor=1
	fi
	echo $blocking_factor
	fragsize=`expr $bytes_per_sect \* $blocking_factor`
	blocksize=`expr $bytes_per_sect \* $blocking_factor \* 8`
	if [ "$ename" = "" ]; then	
		ename=$part_name
		offset=`expr $part_offset + $root + $swap`
		echo -n "	:pe#${part_size}:oe#${offset}" >>/etc/disktab
		echo ":te=4.2BSD:be#${blocksize}:fe#${fragsize}:\\" >>/etc/disktab
		offset=`expr $offset + $part_size`
	elif [ "$fname" = "" ]; then
		fname=$part_name
		echo -n "	:pf#${part_size}:of#${offset}" >>/etc/disktab
		echo ":tf=4.2BSD:bf#${blocksize}:ff#${fragsize}:\\" >>/etc/disktab
		offset=`expr $offset + $part_size`
	elif [ "$gname" = "" ]; then
		gname=$part_name
		echo -n "	:pg#${part_size}:og#${offset}" >>/etc/disktab
		echo ":tg=4.2BSD:bg#${blocksize}:fg#${fragsize}:\\" >>/etc/disktab
		offset=`expr $offset + $part_size`
	elif [ "$hname" = "" ]; then
		hname=$part_name
		echo -n "	:ph#${part_size}:oh#${offset}" >>/etc/disktab
		echo ":th=4.2BSD:bh#${blocksize}:fh#${fragsize}:\\" >>/etc/disktab
		part_used=partition
	fi
done

echo    "	:pd#${disksize}:od#0:" >>/etc/disktab
cat /etc/disktab
#No longer provide a disktab.preinstall on the floppy!
#cat /etc/disktab.preinstall >> /etc/disktab
sync

echo    ""
echo    "OK!  THIS IS THE LAST CHANCE!!!  Data on the hard disk wil be lost."
echo -n "Are you sure you want to install on the hard drive? (yes/no) "
answer=""
while [ "$answer" = "" ]; do
	read answer junk
	echo $answer
	case $answer in
		Yes|yes|YES)
			verified_install=1
			echo    ""
			echo    "OK!  Here we go..."
			;;
		No|no|NO)
			echo ""
			echo -n "Would you like to change the configuration? [y] "
			read answer junk
			if [ "$answer" = "" ]; then
				answer=y
			fi
			echo $answer
			case $answer in
				y*|Y*)
					;;
				*)
					echo    ""
					echo    "OK, then.  enter 'halt' to halt the machine."
					echo    "Once the machine has halted, remove the floppy,"
					echo    "and press any key to reboot."
					exit
					;;
			esac
			;;
		*)
			echo "Please spell out either of \`yes' or \`no'..." 
			echo -n "Install on the hard disk? (yes/no) " 
			answer=
			;;
	esac
done

done	# End of Big Loop

echo    ""
echo -n "Labelling disk..."
/sbin/disklabel -w -r $drivename $name /usr/mdec/${drivetype}boot /usr/mdec/boot${drivetype}
echo    " done."

if [ "$sect_fwd" = "sf:" ]; then
	echo -n "Initializing bad144 badblock table..."
	bad144 $drivename 0
	echo " done."
fi

echo    "Initializing root filesystem, and mounting..."
newfs ${rotdelay} /dev/r${drivename}a $name
mount -v /dev/${drivename}a /mnt
if [ "$ename" != "" ]; then
	echo    ""
	echo    "Initializing $ename filesystem, and mounting..."
	newfs ${rotdelay} /dev/r${drivename}e $name
	mkdir -p /mnt/$ename
	mount -v /dev/${drivename}e /mnt/$ename
fi
if [ "$fname" != "" ]; then
	echo    ""
	echo    "Initializing $fname filesystem, and mounting..."
	newfs ${rotdelay} /dev/r${drivename}f $name
	mkdir -p /mnt/$fname
	mount -v /dev/${drivename}f /mnt/$fname
fi
if [ "$gname" != "" ]; then
	echo    ""
	echo    "Initializing $gname filesystem, and mounting..."
	newfs ${rotdelay} /dev/r${drivename}g $name
	mkdir -p /mnt/$gname
	mount -v /dev/${drivename}g /mnt/$gname
fi
if [ "$hname" != "" ]; then
	echo    ""
	echo    "Initializing $hname filesystem, and mounting..."
	newfs ${rotdelay} /dev/r${drivename}h $name
	mkdir -p /mnt/$hname
	mount -v /dev/${drivename}h /mnt/$hname
fi

echo    ""
#echo -n "Verbose installation? [n] "
#read resp
#
#case $resp in
#	y*)
#		cpioverbose=v
#		;;
#	*)
#		cpioverbose=
#		;;
#esac

echo Copying to disk...
cd /
cat filelist | cpio -pdalmuv /mnt
#cat filelist | cpio -pdalmu${cpioverbose} /mnt

cd /mnt

echo "/dev/${drivename}a	/	ufs	rw 1 1" >etc/fstab
if [ "$ename" != "" ]; then
	echo "/dev/${drivename}e	/$ename	ufs	rw 1 2" >>etc/fstab
fi
if [ "$fname" != "" ]; then
	echo "/dev/${drivename}f	/$fname	ufs	rw 1 3" >>etc/fstab
fi
if [ "$gname" != "" ]; then
	echo "/dev/${drivename}g	/$gname	ufs	rw 1 4" >>etc/fstab
fi
if [ "$hname" != "" ]; then
	echo "/dev/${drivename}h	/$hname	ufs	rw 1 5" >>etc/fstab
fi

cat << EOF >.profile
PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin:/usr/contrib/bin:.:
export PATH
HOME=/root
export HOME
TERM=pc3
export TERM
echo    ""
echo    "Insert second installation floppy in drive and"
echo -n "enter that drive's number (e.g. 0 or 1): [0]"
read driveno junk
if [ "\$driveno" = "" ]; then
	driveno=0
fi
echo $driveno
mount -o ro /dev/fd\${driveno}a /mnt
cd /mnt
install
EOF

sync

echo	""
echo    "The next step:  reboot from the kernel-copy disk, copy a kernel"
echo    "to the hard disk, and finally reboot from the hard disk."
echo    ""
echo    "To do this, enter 'halt' now to halt the machine.  After it"
echo	"announces that it has halted, remove the floppy from the drive"
echo	"and insert the kernel-copy disk that was booted before."
echo	"Press any key to reboot."
echo	""
echo	"When prompted to insert the file system floppy, this time just"
echo	"hit RETURN without changing floppies.  If all goes well, you can"
echo	"enter the command \`copy' at the prompt to copy the kernel to the"
echo	"hard disk.  When asked for which partition to copy to, enter  to"
echo    "\`${drivename}a' (without the quotes)."
echo	""
echo	"Okay, that's all for now.  I'm waiting for you to enter \`halt'..."
