#
# /etc/rc.diskless - general BOOTP startup
#
#	BOOTP has mounted / for us.  Assume a read-only mount.  We must then
#	- figure out where the NFS mount is coming from
#	- mount /usr via nfs
#	- figure out our IP by querying the interface
#	- setup the configuration script directory
#	- setup the configuration function
#
# SEE SAMPLE FILES IN /usr/share/examples/diskless.  If you have nothing 
# better to do, try:
#
#	ln -s /usr/share/examples/diskless /conf
#
# but at least read the README.

# chkerr:
#
# Routine to check for error
#
#	checks error code and drops into shell on failure.
#	if shell exits, terminates script as well as /etc/rc.

chkerr() {
	if [ $1 != 0 ]; then
		echo "$2 failed: dropping into /bin/sh"
		/bin/sh
		# RESUME
	fi
}

# DEBUGGING
#
set -v

#  Figure out where the root mount is coming from, synthesize a mount
#  for /usr and mount it.  Also mount /var
#
#  e.g. nfs_root might wind up as "A.B.C.D:/"
#
set `/bin/df /`
nfs_root=$8
mount_nfs -o ro ${nfs_root}/usr /usr

chkerr $? "mount of /usr"

#  Figure out our interface and IP.
#

bootp_ifc=`route -n get default | fgrep interface | awk '{ print $2; }'`
bootp_ipa=`ifconfig $bootp_ifc | fgrep inet | head -1 | awk '{ print $2; }'`

echo "Interface $bootp_ifc IP-Address $bootp_ipa"

# retarget the configuration directory, where rc.conf.local and rc.local
# are found.  We set the directory to /conf/$bootp_ipa.  'conf_dir' will
# be used by rc.conf and later in /etc/rc.
#
# retarget the kernel ( put a softlink in your conf directory to point to
# the correct kernel ).

conf_dir=/conf/$bootp_ipa
sysctl -w kern.bootfile=$conf_dir/kernel

if [ ! -f $conf_dir/rc.conf.local ]; then
	chkerr 1 "access to $conf_dir"
fi

#  Tell /etc/rc to skip normal disk configuration and replace
#  it with our own.
#
skip_diskconf=YES
diskless_mount_func=diskless_mount_system

#  Set defaults for MFS filesystem sizes.  These can get overriden by
#  rc.conf when diskless_mount_system is called back.  NOTE!  These
#  defaults are generous, but may be too large for your memory/swap
#  configuration.  Large is ok as long as you have sufficient NFS swap.
#
var_run_sectors=2048
var_db_sectors=16384
var_tmp_sectors=65536
var_spool_sectors=65536

#  Default mounting pass procedure
#
#	We have to create the filesystems that are expected
#	to be writeable.

diskless_mount_system() {
	sysctl -w net.inet.ip.portrange.first=4000

	# This is kinda a hack at the moment.  Typically, we do not want to
	# export /var from the server root due to security considerations,
	# even read-only.  XXX fixme.  See the tail end of the
	# /usr/share/examples/diskless/README.TEMPLATING file for the
	# reasoning and other security considerations.
	#
	if [ "X$nfs_var_mount" != "XNO" ]; then
		mount_nfs -o ro ${nfs_root}/var /var
	fi
	mount_mfs -s $var_run_sectors -T qp120at dummy /var/run
	mount_mfs -s $var_db_sectors -T qp120at dummy /var/db
	mount_mfs -s $var_tmp_sectors -T qp120at dummy /var/tmp
	mount_mfs -s $var_spool_sectors -T qp120at dummy /var/spool
	chmod 755 /var/run
	chmod 755 /var/db
	chmod 755 /var/spool
	chmod 1777 /var/tmp

	# /tmp should be a softlink to /var/tmp on most systems.  If it isn't, 
	# use nullfs
	#
	if [ ! -h /tmp -a ! -h /var/tmp ]; then
		mount_null /var/tmp /tmp
	fi

	# Create a skeleton spool
	#
	mkdir /var/spool/mqueue
	mkdir /var/spool/lpd
	mkdir /var/spool/output
	mkdir /var/spool/output/lpd
	chown -R root.daemon /var/spool/output
	chgrp daemon /var/spool/lpd

	# /proc may be necessary
	#
	mount_procfs proc /proc

	# We need a R+W /dev !  Use cpio to copy /dev from the 
	# server to an MFS mount.

	mkdir /tmp/root
	mount ${nfs_root} /tmp/root
	mount_mfs -s 4096 -i 512 -T qp120at dummy /dev
	( cd /tmp/root ; find -x dev | cpio -o -H newc ) | \
		( cd / ; cpio -i -H newc -d )
	umount /tmp/root
}

