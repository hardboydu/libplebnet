/**************************************************************************
**
**  $Id: pcivar.h,v 1.1 1995/02/01 22:56:55 se Exp $
**
**  Declarations for pci device drivers.
**
**  386bsd / FreeBSD
**
**-------------------------------------------------------------------------
**
** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
** 1. Redistributions of source code must retain the above copyright
**    notice, this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
***************************************************************************
*/

#ifndef __PCI_VAR_H__
#define __PCI_VAR_H__

#define PCIVAR_H_PATCHLEVEL  "pl1 95/02/27"

/*-----------------------------------------------------------------
**
**	main pci initialization function.
**	called at boot time from autoconf.c
**
**-----------------------------------------------------------------
*/

void pci_configure (void);

/*-----------------------------------------------------------------
**
**	The pci configuration id describes a pci device on the bus.
**	It is constructed from: bus, device & function numbers.
**
**-----------------------------------------------------------------
*/

typedef union {
	u_long	 cfg1;
        struct {
		 u_char   enable;
		 u_char   forward;
		 u_short  port;
	       } cfg2;
	} pcici_t;

/*-----------------------------------------------------------------
**
**	Each pci device has an unique device id.
**	It is used to find a matching driver.
**
**-----------------------------------------------------------------
*/

typedef u_long pcidi_t;

/*-----------------------------------------------------------------
**
**	The following functions are provided for the device driver
**	to read/write the configuration space.
**
**	pci_conf_read():
**		Read a long word from the pci configuration space.
**		Requires a tag (from pcitag) and the register
**		number (should be a long word alligned one).
**
**	pci_conf_write():
**		Writes a long word to the pci configuration space.
**		Requires a tag (from pcitag), the register number
**		(should be a long word alligned one), and a value.
**
**-----------------------------------------------------------------
*/

u_long pci_conf_read  (pcici_t tag, u_long reg		   );

void   pci_conf_write (pcici_t tag, u_long reg, u_long data);

/*-----------------------------------------------------------------
**
**	The pci driver structure.
**
**	name:	The short device name.
**
**	probe:	Checks if the driver can support a device
**		with this type. The tag may be used to get
**		more info with pci_read_conf(). See below.
**		It returns a string with the devices name,
**		or a NULL pointer, if the driver cannot
**		support this device.
**
**	attach:	Allocate a control structure and prepare
**		it. This function may use the pci mapping
**		functions. See below.
**		(configuration id) or type.
**
**	count:	A pointer to a unit counter.
**		It's used by the pci configurator to
**		allocate unit numbers.
**
**-----------------------------------------------------------------
*/

struct pci_device {
    char*    pd_name;
    char*  (*pd_probe ) (pcici_t tag, pcidi_t type);
    void   (*pd_attach) (pcici_t tag, int     unit);
    u_long  *pd_count;
};

/*-----------------------------------------------------------------
**
**	This table includes pointers to all pci device drivers.
**	It should be generated by the linker.
**
**-----------------------------------------------------------------
*/

extern struct linker_set pcidevice_set;

/*-----------------------------------------------------------------
**
**	The pci-devconf interface.
**
**-----------------------------------------------------------------
*/

struct pci_info {
        u_short pi_bus;
        u_short pi_device;
};  
   
#define PCI_EXT_CONF_LEN (16)
#define PCI_EXTERNAL_LEN (sizeof(struct pci_externalize_buffer))

struct pci_externalize_buffer {
	struct pci_info	peb_pci_info;
	u_long		peb_config[PCI_EXT_CONF_LEN];
};


/*-----------------------------------------------------------------
**
**	Register an additional pci bus for probing.
**	Called by pci-pci bridge handlers.
**
**-----------------------------------------------------------------
*/

int pci_map_bus (pcici_t tag, u_long bus);

/*-----------------------------------------------------------------
**
**	Map a pci device to physical and virtual memory.
**
**	The va and pa addresses are "in/out" parameters.
**	If they are 0 on entry, the function assigns an address.
**
**	Entry selects the register in the pci configuration
**	space, which supplies the size of the region, and
**	receives the physical address.
**
**	If there is any error, a message is written, and
**	the function returns with zero.
**	Else it returns with a value different to zero.
**
**-----------------------------------------------------------------
*/

int pci_map_mem (pcici_t tag, u_long entry, u_long  * va, u_long * pa);

/*-----------------------------------------------------------------
**
**	Map a pci device to an io port area.
**
**	*pa is an "in/out" parameter.
**	If it's 0 on entry, the function assigns an port number..
**
**	Entry selects the register in the pci configuration
**	space, which supplies the size of the region, and
**	receives the port number.
**
**	If there is any error, a message is written, and
**	the function returns with zero.
**	Else it returns with a value different to zero.
**
**-----------------------------------------------------------------
*/

int pci_map_port(pcici_t tag, u_long entry, u_short * pa);

/*-----------------------------------------------------------------
**
**	Map a pci interrupt to an isa irq line,
**	and enable the interrupt.
**
**	func is the interrupt handler, arg is the argument
**	to this function.
**
**	The maskptr argument should be  &bio_imask,
**	&net_imask etc. or NULL.
**
**	If there is any error, a message is written, and
**	the function returns with zero.
**	Else it returns with a value different to zero.
**
**	A word of caution for FreeBSD 2.0:
**
**	We use the register_intr() function.
**
**	The interrupt line of the selected device is included
**	into the supplied mask: after the corresponding splXXX
**	this drivers interrupts are blocked.
**
**	But in the interrupt handlers startup code ONLY
**	the interrupt of the driver is blocked, and NOT
**	all interrupts of the spl group.
**
**	It may be required to additional block the group
**	interrupts by splXXX() inside the interrupt handler.
**
**	In pre 2.0 kernels we emulate the register_intr
**	function. The emulating function blocks all interrupts
**	of the group in the interrupt handler prefix code.
**
**-----------------------------------------------------------------
*/

int pci_map_int (pcici_t tag, int (*func)(), void* arg, unsigned * maskptr);

#endif
