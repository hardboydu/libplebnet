/*	$NetBSD: sbic.c,v 1.10 1995/02/12 19:19:20 chopps Exp $	*/

/*
 * Copyright (c) 1994 Christian E. Hopps
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson of Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)scsi.c	7.5 (Berkeley) 5/4/91
 */
/*
 * Ported to PC-9801 by Yoshio Kimura, 1994
 *	last update 09/25/1994
 */

/*
 * AMIGA AMD 33C93 scsi adaptor driver
 */

#include "sbic.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/dkstat.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>

#include <machine/clock.h>
#include <machine/cpu.h>

#include <vm/vm.h>
#include <vm/vm_param.h>
#include <vm/pmap.h>

#include <i386/isa/icu.h>
#include <pc98/pc98/pc98.h>
#include <i386/isa/isa_device.h>
#include <i386/isa/ic/i8237.h>
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <pc98/pc98/sbicreg.h>
#include <pc98/pc98/sbicvar.h>

extern short dmapageport[];

/*
 * SCSI delays
 * In u-seconds, primarily for state changes on the SPC.
 */
#define	SBIC_CMD_WAIT	50000	/* wait per step of 'immediate' cmds */
#define	SBIC_DATA_WAIT	50000	/* wait per data in/out step */
#define	SBIC_INIT_WAIT	50000	/* wait per step (both) during init */
#define SBIC_RESET_TIMEOUT	2000

#define SBIC_WAIT(sbic, until, timeo) sbicwait(sbic, until, timeo, __LINE__)
#define SBIC_ENABLE_INT(iobase) { \
		u_char tmp; \
		GET_SBIC_mem_bank(iobase, tmp); \
		SET_SBIC_mem_bank(iobase, tmp | 0x04);\
	}
#define SBIC_DISABLE_INT(iobase) { \
		u_char tmp; \
		GET_SBIC_mem_bank(iobase, tmp); \
		SET_SBIC_mem_bank(iobase, tmp & 0xfb); \
	}

#define INT0	0
#define INT1	1
#define INT2	2
#define INT3	3
#define INT5	5
#define INT6	6

static struct sbic_softc *sbicdata[NSBIC];

#define KVTOPHYS(x)	vtophys(x)

static int  sbicprobe __P((struct isa_device *));
static int  sbicattach __P((struct isa_device *));

static u_int32_t	sbic_adapter_info __P((int));
static int  sbic_find __P((struct sbic_softc *));
static int32_t sbic_scsi_cmd __P((struct scsi_xfer *));
static int  sbicicmd __P((struct sbic_softc *,
	int, int, void *, int, void *, int,u_char));
static int  sbicgo __P((struct sbic_softc *, struct scsi_xfer *));
static int  sbicdmaok __P((struct sbic_softc *, struct scsi_xfer *));
static int  sbicgetsense __P((struct sbic_softc *, struct scsi_xfer *));
static int  sbicwait __P((struct sbic_softc *, char, int , int));
static int  sbicselectbus __P((struct sbic_softc *, u_char, u_char, u_char));
static int  sbicxfstart __P((struct sbic_softc *, int, u_char, int));
static int  sbicxfout __P((struct sbic_softc *, int, void *, int));
static int  sbicfromscsiperiod __P((struct sbic_softc *, int));
static int  sbictoscsiperiod __P((struct sbic_softc *, int));
static void sbicminphys __P((struct buf *));
static void sbicxfin __P((struct sbic_softc *, int, void *));
static void sbicxfdone __P((struct sbic_softc *, int));
static void sbicabort __P((struct sbic_softc *, char *));
static void sbicerror __P((struct sbic_softc *, u_char));
static void sbicreset __P((struct sbic_softc *));
static void sbicsetdelay __P((int));
static void sbic_scsidone __P((struct sbic_softc *, int));
static void sbic_donextcmd __P((struct sbic_softc *));
static void sbic_dmastart __P((struct sbic_softc *));
static void sbic_dmastop __P((struct sbic_softc *));

/*
 * Synch xfer parameters, and timing conversions
 */
static int sbic_min_period = SBIC_SYN_MIN_PERIOD;  /* in cycles = f(ICLK,FSn) */
static int sbic_max_offset = SBIC_SYN_MAX_OFFSET;  /* pure number */

static int sbic_cmd_wait = SBIC_CMD_WAIT;
static int sbic_data_wait = SBIC_DATA_WAIT;
static int sbic_init_wait = SBIC_INIT_WAIT;

/*
 * was broken before.. now if you want this you get it for all drives
 * on sbic controllers.
 */
#ifdef SCSI_SYNC
static int sbic_inhibit_sync = 0;
#else
static int sbic_inhibit_sync = 1;
#endif

static int sbic_force_async_flag = 0;

#ifdef SC98BUSMASTER
static int sc98busmaster = 0;
#endif

#ifdef DEBUG
#define QPRINTF(a) if (sbic_debug > 1) printf a
int	sbic_debug = 0;
int	sync_debug = 0;
int	sbic_dma_debug = 0;
#else
#define QPRINTF(a)
#endif

static
struct scsi_adapter sbic_switch = {
	sbic_scsi_cmd,
	sbicminphys,
	0,
	0,
	sbic_adapter_info,
	"sbic"
	, { 0, 0 }
};

/* the below structure is so we have a default dev struct for out link struct */
static
struct scsi_device sbic_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
	"sbic",
	0
	, { 0, 0 }
};

struct isa_driver sbicdriver = {
	sbicprobe,
	sbicattach,
	"sbic"
};

static int sbicunit = 0;

/*
 * Check if the device can be found at the port given
 * and if so, set ip up ready for further work
 * as an argument, takes the pc98_device structure from
 * autoconf.c
 */
static int
sbicprobe(dev)
	struct isa_device *dev;
{
	int unit = sbicunit;
	struct sbic_softc *sbic;

#define SBICFLAGS
# ifdef SBICFLAGS
	sbic_force_async_flag = dev->id_flags;
# else
	sbic_force_async_flag = 0;
# endif
	if (unit >= NSBIC) {
		printf("sbic%d: unit number too high\n", unit);
		return 0;
	}
	dev->id_unit = unit;
	/*
	 * Allocate a storage area for us
	 */
	if (sbicdata[unit]) {
		printf("sbic%d: memory already allocated\n", unit);
		return 0;
	}
	sbic = malloc(sizeof(struct sbic_softc), M_TEMP, M_NOWAIT);
	if (!sbic) {
		printf("sbic%d: cannot malloc!\n", unit);
		return 0;
	}
	bzero(sbic, sizeof(struct sbic_softc));
	sbicdata[unit] = sbic;
	sbic->sc_base = dev->id_iobase;

	if (sbic_find(sbic) != 0) {
		sbicdata[unit] = NULL;
		free(sbic, M_TEMP);
		return 0;
	}

	dev->id_irq = sbic->sc_int;
	dev->id_drq = sbic->sc_dma;
	sbicunit++;
	return 5;
}


/*
 * Attach all the sub-devices we can find
 */
static int
sbicattach(dev)
	struct isa_device *dev;
{
	int unit = dev->id_unit;
	struct sbic_softc *sbic = sbicdata[unit];
	struct scsibus_data *scbus;
#if defined(SC98BUSMASTER) || defined(FORCE_BUSMASTER)
	int a;
	int i;
#endif

#ifdef FORCE_BUSMASTER
	sbic_read_reg(sbic->sc_base, 0x37, a);
	/* set busmaster flag */
	sbic_write_reg(sbic->sc_base, 0x37, a | 0x08);
	printf("sbic%d: set busmaster flag\n", unit);
#if defined(HA55BS_ID) && defined(SCSI_SYNC)
	sbic_read_reg(sbic->sc_base, 0x60 + HA55BS_ID, a);
	for (i = 0; i < 7; i++) {
	    if (sbic_force_async_flag & 1 << i) {
		sbic_write_reg(sbic->sc_base, 0x60 + i, a);
		printf("sbic%d: set transfer rate (ID %d)\n",
		       unit, i);
	    }
	}
	sbic_force_async_flag = 0;
#endif
#endif

#ifdef SC98BUSMASTER
	sbic_read_reg(sbic->sc_base, 0x37, a);
	if (a & 0x08) {
		printf("sbic%d: busmaster enable\n", unit);
		sc98busmaster = 1;
	}
#endif
	/*
	 * fill in the prototype scsi_link.
	 */
	sbic->sc_link.adapter_unit = unit;
	sbic->sc_link.adapter_softc = sbic;
	sbic->sc_link.adapter_targ = sbic->sc_scsi_dev;
	sbic->sc_link.adapter = &sbic_switch;
	sbic->sc_link.device = &sbic_dev;
	sbic->sc_link.flags = SDEV_BOUNCE;
	TAILQ_INIT(&sbic->sc_xslist);

	/*
	 * Prepare the scsibus_data area for the upperlevel
	 * scsi code.
	 */
	scbus = scsi_alloc_bus();
	if(!scbus)
		return 0;
	scbus->adapter_link = &sbic->sc_link;

	/*
	 * ask the adapter what subunits are present
	 */
	scsi_attachdevs(scbus);

	return 1;
}

/*
 * Find the board and find its irq/drq
 */
static int
sbic_find(sbic)
	struct sbic_softc *sbic;
{
	int intr, my_id, asr, csr;
	volatile int i, sts;

	GET_SBIC_asr(sbic->sc_base, asr);		/* dummy read */
	GET_SBIC_csr(sbic->sc_base, csr);
	SBIC_DISABLE_INT(sbic->sc_base);

	GET_SBIC_myid(sbic->sc_base, my_id);
	switch(my_id & 0xc0) {
	case SBIC_ID_FS_8_10:
		sbic->sc_clkfreq = 100;
		break;
	case SBIC_ID_FS_12_15:
		sbic->sc_clkfreq = 150;
		break;
	case SBIC_ID_FS_16_20:
		sbic->sc_clkfreq = 200;
		break;
	}
	sbic->sc_scsi_dev = my_id & SBIC_ID_MASK;
	my_id &= 0xc7;
	my_id |= SBIC_ID_EAF;
	/*
	 * reset board, If it doesn't respond, assume
	 * that it's not there.. good for the probe
	 */
	SET_SBIC_myid(sbic->sc_base, my_id);
	SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_RESET);
	DELAY(10);
	SBIC_WAIT(sbic, SBIC_ASR_INT, 0);
	GET_SBIC_csr(sbic->sc_base, csr);
	if (csr != SBIC_CSR_RESET_AM)
		return(ENXIO);

	sbic->sc_dma = inb(sbic->sc_base + 4) & 0x03;
	outb(sbic->sc_base, SBIC_reset_int);
	intr = (inb(sbic->sc_base + 2) >> 3) & 0x07;
	switch(intr) {
	case INT0:
		sbic->sc_int = IRQ3;
		break;
	case INT1:
		sbic->sc_int = IRQ5;
		break;
	case INT2:
		sbic->sc_int = IRQ6;
		break;
	case INT3:
		sbic->sc_int = IRQ9;
		break;
	case INT5:
		sbic->sc_int = IRQ12;
		break;
	case INT6:
		sbic->sc_int = IRQ13;
		break;
	default:
		printf("illegal int jumper setting\n");
		return(EIO);
	}
	SET_SBIC_control(sbic->sc_base, SBIC_CTL_EDI | SBIC_CTL_IDI
	    | SBIC_MACHINE_DMA_MODE);
	SET_SBIC_rselid(sbic->sc_base, 0);
	SET_SBIC_syn(sbic->sc_base, 0);	/* asynch for now */

	sbic->sc_flags = SBICF_ALIVE;
	return 0;
}

/*
 * default minphys routine for sbic based controllers
 */
static void
sbicminphys(bp)
	struct buf *bp;
{
	if (bp->b_bcount > ((SBIC_NSEG - 1) << PAGE_SHIFT))
		bp->b_bcount = ((SBIC_NSEG - 1) << PAGE_SHIFT);
}

/*
 * must be used
 */
static u_int32_t
sbic_adapter_info(unit)
	int unit;
{
	/* 
	 * one request at a time please
	 */
	return(1);
}

/*
 * used by specific sbic controller
 *
 * it appears that the higher level code does nothing with LUN's
 * so I will too.  I could plug it in, however so could they
 * in scsi_scsi_cmd().
 */
static int32_t
sbic_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct sbic_pending *pendp;
	struct sbic_softc *sbic;
	struct scsi_link *sc_link;
	int flags, s;
	int unit;

	sc_link = xs->sc_link;
	unit = sc_link->adapter_unit;
	sbic = sc_link->adapter_softc;
	flags = xs->flags;

	if (flags & SCSI_DATA_UIO)
		panic("sbic: scsi data uio requested");
	
	if (sbic->sc_xs && flags & SCSI_NOMASK)
		panic("sbic_scsi_cmd: busy");

	s = splbio();
	pendp = &sbic->sc_xsstore[sc_link->target][sc_link->lun];
	if (pendp->xs) {
		splx(s);
		return(TRY_AGAIN_LATER);
	}

	if (sbic->sc_xs) {
		pendp->xs = xs;
		TAILQ_INSERT_TAIL(&sbic->sc_xslist, pendp, link);
		splx(s);
		return(SUCCESSFULLY_QUEUED);
	}
	pendp->xs = NULL;
	sbic->sc_xs = xs;
	splx(s);

	/*
	 * nothing is pending do it now.
	 */
	sbic_donextcmd(sbic);

	if (flags & SCSI_NOMASK)
		return(COMPLETE);
	return(SUCCESSFULLY_QUEUED);
}

/*
 * entered with sbic->sc_xs pointing to the next xfer to perform
 */
static void
sbic_donextcmd(sbic)
	struct sbic_softc *sbic;
{
	struct scsi_xfer *xs;
	struct scsi_link *sc_link;
	int flags, phase, stat;

	xs = sbic->sc_xs;
	sc_link = xs->sc_link;
	flags = xs->flags;

	if (flags & SCSI_DATA_IN)
		phase = DATA_IN_PHASE;
	else if (flags & SCSI_DATA_OUT)
		phase = DATA_OUT_PHASE;
	else
		phase = STATUS_PHASE;
	
	if (flags & SCSI_RESET)
		sbicreset(sbic);

	sbic->sc_stat[0] = -1;
	xs->cmd->bytes[0] |= sc_link->lun << 5;
	if (phase == STATUS_PHASE || flags & SCSI_NOMASK ||
	    sbicdmaok(sbic, xs) == 0) 
		stat = sbicicmd(sbic, sc_link->target, sc_link->lun, xs->cmd,
		    xs->cmdlen, xs->data, xs->datalen, phase);
	else if (sbicgo(sbic, xs) == 0)
		return;
	else 
		stat = sbic->sc_stat[0];
	
	sbic_scsidone(sbic, stat);
}

static void
sbic_scsidone(sbic, stat)
	struct sbic_softc *sbic;
	int stat;
{
	struct sbic_pending *pendp;
	struct scsi_xfer *xs;
	int s, donext;

	xs = sbic->sc_xs;
#ifdef DIAGNOSTIC
	if (xs == NULL)
		panic("sbic_scsidone");
#endif
	/*
	 * is this right?
	 */
	xs->status = stat;

	if (stat == 0)
		xs->resid = 0;
	else {
		switch(stat) {
		case SCSI_CHECK:
			if (stat = sbicgetsense(sbic, xs))
				goto bad_sense;
			xs->error = XS_SENSE;
			break;
		case SCSI_BUSY:
			xs->error = XS_BUSY;
			break;
		bad_sense:
		default:
			xs->error = XS_DRIVER_STUFFUP;
			QPRINTF(("sbic_scsicmd() bad %x\n", stat));
			break;
		}
	}
	xs->flags |= ITSDONE;

	/*
	 * grab next command before scsi_done()
	 * this way no single device can hog scsi resources.
	 */
	s = splbio();
	pendp = sbic->sc_xslist.tqh_first;
	if (pendp == NULL) {
		donext = 0;
		sbic->sc_xs = NULL;
	} else {
		donext = 1;
		TAILQ_REMOVE(&sbic->sc_xslist, pendp, link);
		sbic->sc_xs = pendp->xs;
		pendp->xs = NULL;
	}
	splx(s);
	scsi_done(xs);

	if (donext)
		sbic_donextcmd(sbic);
}

static int
sbicgetsense(sbic, xs)
	struct sbic_softc *sbic;
	struct scsi_xfer *xs;
{
	struct scsi_sense rqs;
	struct scsi_link *sc_link;
	int stat;

	sc_link = xs->sc_link;
	
	rqs.op_code = REQUEST_SENSE;
	rqs.byte2 = sc_link->lun << 5;
#ifdef not_yet
	rqs.length = xs->req_sense_length ? xs->req_sense_length : 
	    sizeof(xs->sense);
#else
	rqs.length = sizeof(xs->sense);
#endif
	    
	rqs.unused[0] = rqs.unused[1] = rqs.control = 0;
	
	return(sbicicmd(sbic, sc_link->target, sc_link->lun, &rqs,
	     sizeof(rqs), &xs->sense, rqs.length, DATA_IN_PHASE));
}

static int
sbicdmaok(sbic, xs)
	struct sbic_softc *sbic;
	struct scsi_xfer *xs;
{
	int va, phys, priorpage = 0, endva, length;

	va = (int)xs->data;
	length = xs->datalen;
	endva = round_page(va + length);

	for (; va < endva; va += PAGE_SIZE) {
		phys = trunc_page(pmap_extract(kernel_pmap, va));
		if (phys == 0)
			panic("sbicdmaok: no physical page present");
		if (phys >= (1 << 24))
			return 0;
		priorpage = phys;
	}
	return 1;
}

static int
sbicwait(sbic, until, timeo, line)
	struct sbic_softc *sbic;
	char until;
	int timeo;
	int line;
{
	u_char val;
	int csr;

	if (timeo == 0)
		timeo = 1000000;	/* some large value.. */

	GET_SBIC_asr(sbic->sc_base,val);
	while ((val & until) == 0) {
		if (timeo-- == 0) {
			GET_SBIC_csr(sbic->sc_base, csr);
			printf("sbicwait TIMEO @%d with asr=x%x csr=x%x\n",
			    line, val, csr);
			break;
		}
		DELAY(1);
		GET_SBIC_asr(sbic->sc_base,val);
	}
	return(val);
}

static void
sbicabort(sbic, where)
	struct sbic_softc *sbic;
	char *where;
{
	u_char csr, asr;
  
	GET_SBIC_csr(sbic->sc_base, csr);
	GET_SBIC_asr(sbic->sc_base, asr);

	printf ("sbic%d: abort %s: csr = 0x%02x, asr = 0x%02x\n", 
	    sbic->sc_link.adapter_unit, where, csr, asr);

	if (sbic->sc_flags & SBICF_SELECTED) {
		SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_ABORT);
		WAIT_CIP(sbic->sc_base);

		GET_SBIC_asr(sbic->sc_base, asr);
		if (asr & (SBIC_ASR_BSY|SBIC_ASR_LCI)) {
			/* ok, get more drastic.. */
          
			SET_SBIC_cmd (sbic->sc_base, SBIC_CMD_RESET);
			DELAY(25);
			SBIC_WAIT(sbic, SBIC_ASR_INT, 0);
			/* clears interrupt also */
			GET_SBIC_csr (sbic->sc_base, csr);

			sbic->sc_flags &= ~SBICF_SELECTED;
			return;
		}

		do {
			SBIC_WAIT (sbic, SBIC_ASR_INT, 0);
			GET_SBIC_csr (sbic->sc_base, csr);
		} while ((csr != SBIC_CSR_DISC) && (csr != SBIC_CSR_DISC_1)
		    && (csr != SBIC_CSR_CMD_INVALID));

		/* lets just hope it worked.. */
		sbic->sc_flags &= ~SBICF_SELECTED;
	}
}

/*
 * XXX Set/reset long delays.
 *
 * if delay == 0, reset default delays
 * if delay < 0,  set both delays to default long initialization values
 * if delay > 0,  set both delays to this value
 *
 * Used when a devices is expected to respond slowly (e.g. during
 * initialization).
 */
static void
sbicsetdelay(del)
	int del;
{
	static int saved_cmd_wait, saved_data_wait;

	if (del) {
		saved_cmd_wait = sbic_cmd_wait;
		saved_data_wait = sbic_data_wait;
		if (del > 0)
			sbic_cmd_wait = sbic_data_wait = del;
		else
			sbic_cmd_wait = sbic_data_wait = sbic_init_wait;
	} else {
		sbic_cmd_wait = saved_cmd_wait;
		sbic_data_wait = saved_data_wait;
	}
}

void
sbicreset(sbic)
	struct sbic_softc *sbic;
{
	u_int i, s;
	u_char my_id, csr;
	
	if (sbic->sc_flags & SBICF_ALIVE)
		sbicabort(sbic, "reset");
		
	s = splbio();
	/* preserve our ID for now */
	GET_SBIC_myid (sbic->sc_base, my_id);
	my_id &= SBIC_ID_MASK;

	if (sbic->sc_clkfreq < 110)
		my_id |= SBIC_ID_FS_8_10;
	else if (sbic->sc_clkfreq < 160)
		my_id |= SBIC_ID_FS_12_15;
	else if (sbic->sc_clkfreq < 210)
		my_id |= SBIC_ID_FS_16_20;

	my_id |= SBIC_ID_EAF /*| SBIC_ID_EHP*/ ;

	SET_SBIC_myid(sbic->sc_base, my_id);

	/*
	 * Disable interrupts (in dmainit) then reset the chip
	 */
	SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_RESET);
	DELAY(25);
	SBIC_WAIT(sbic, SBIC_ASR_INT, 0);
	GET_SBIC_csr(sbic->sc_base, csr);       /* clears interrupt also */

	/*
	 * Set up various chip parameters
	 */
	SET_SBIC_control(sbic->sc_base, SBIC_CTL_EDI | SBIC_CTL_IDI 
	    | SBIC_MACHINE_DMA_MODE);
	/*
	 * don't allow (re)selection (SBIC_RID_ES)
	 * until we can handle target mode!!
	 */
	SET_SBIC_rselid(sbic->sc_base, 0);
	SET_SBIC_syn(sbic->sc_base, 0);     /* asynch for now */

	/*
	 * anything else was zeroed by reset
	 */
	splx(s);

	sbic->sc_flags |= SBICF_ALIVE;
	sbic->sc_flags &= ~SBICF_SELECTED;
}

static void
sbicerror(sbic, csr)
	struct sbic_softc *sbic;
	u_char csr;
{
	struct scsi_xfer *xs;

	xs = sbic->sc_xs;

#ifdef DIAGNOSTIC
	if (xs == NULL)
		panic("sbicerror");
#endif
	if (xs->flags & SCSI_SILENT)
		return;

	printf("sbic%d: ", sbic->sc_link.adapter_unit);
	printf("csr == 0x%02x\n", csr);	/* XXX */
}

/*
 * select the bus, return when selected or error.
 */
static int
sbicselectbus(sbic, target, lun, our_addr)
        struct sbic_softc *sbic;
	u_char target, lun, our_addr;
{
	u_char asr, csr, id;

	QPRINTF(("sbicselectbus %d\n", target));

	/* 
	 * if we're already selected, return (XXXX panic maybe?)
	 */
	if (sbic->sc_flags & SBICF_SELECTED)
		return(1);

	/*
	 * issue select
	 */
	SBIC_TC_PUT(sbic->sc_base, 0);
	SET_SBIC_selid(sbic->sc_base, target);
	SET_SBIC_timeo(sbic->sc_base, SBIC_TIMEOUT(250,sbic->sc_clkfreq));

	/*
	 * set sync or async
	 */
	if (sbic->sc_sync[target].state == SYNC_DONE)
		SET_SBIC_syn(sbic->sc_base, SBIC_SYN (sbic->sc_sync[target].offset, 
		    sbic->sc_sync[target].period));
	else
		SET_SBIC_syn(sbic->sc_base, SBIC_SYN (0, sbic_min_period));
	
	SET_SBIC_cmd(sbic->sc_base, sbic_inhibit_sync ? SBIC_CMD_SEL : SBIC_CMD_SEL_ATN);

	/*
	 * wait for select (merged from seperate function may need
	 * cleanup)
	 */
	WAIT_CIP(sbic->sc_base);
	do {
		SBIC_WAIT(sbic, SBIC_ASR_INT, 0);
		GET_SBIC_csr (sbic->sc_base, csr);
		QPRINTF(("%02x ", csr));
	} while (csr != (SBIC_CSR_MIS_2|MESG_OUT_PHASE)
	    && csr != (SBIC_CSR_MIS_2|CMD_PHASE) && csr != SBIC_CSR_SEL_TIMEO);

	if (csr == (SBIC_CSR_MIS_2|CMD_PHASE))
		sbic->sc_flags |= SBICF_SELECTED;	/* device ignored ATN */
	else if (csr == (SBIC_CSR_MIS_2|MESG_OUT_PHASE)) {
		/*
		 * Send identify message
		 * (SCSI-2 requires an identify msg (?))
		 */
		GET_SBIC_selid(sbic->sc_base, id);

		/* 
		 * handle drives that don't want to be asked 
		 * whether to go sync at all.
		 */
		if ((sbic_force_async_flag & (1 << id)) || (sbic_inhibit_sync && sbic->sc_sync[id].state == SYNC_START)) {
#ifdef DEBUG
			if (sync_debug)
				printf("Forcing target %d asynchronous.\n", id);
#endif
			sbic->sc_sync[id].offset = 0;
			sbic->sc_sync[id].period = sbic_min_period;
			sbic->sc_sync[id].state = SYNC_DONE;
		}
	

		if (sbic->sc_sync[id].state != SYNC_START)
			SEND_BYTE (sbic, MSG_IDENTIFY | lun);
		else {
			/*
			 * try to initiate a sync transfer.
			 * So compose the sync message we're going 
			 * to send to the target
			 */

#ifdef DEBUG
			if (sync_debug)
				printf("Sending sync request to target %d ... ",
				    id);
#endif
			/*
			 * setup scsi message sync message request
			 */
			sbic->sc_msg[0] = MSG_IDENTIFY | lun;
			sbic->sc_msg[1] = MSG_EXT_MESSAGE;
			sbic->sc_msg[2] = 3;
			sbic->sc_msg[3] = MSG_SYNC_REQ;
			sbic->sc_msg[4] = sbictoscsiperiod(sbic,
			    sbic_min_period);
			sbic->sc_msg[5] = sbic_max_offset;

			if (sbicxfstart(sbic, 6, MESG_OUT_PHASE, sbic_cmd_wait))
				sbicxfout(sbic, 6, sbic->sc_msg, MESG_OUT_PHASE);

			sbic->sc_sync[id].state = SYNC_SENT;
#ifdef DEBUG
			if (sync_debug)
				printf ("sent\n");
#endif
		}

		SBIC_WAIT (sbic, SBIC_ASR_INT, 0);
		GET_SBIC_csr (sbic->sc_base, csr);
		QPRINTF(("[%02x]", csr));
#ifdef DEBUG
		if (sync_debug && sbic->sc_sync[id].state == SYNC_SENT)
			printf("csr-result of last msgout: 0x%x\n", csr);
#endif

		if (csr != SBIC_CSR_SEL_TIMEO)
			sbic->sc_flags |= SBICF_SELECTED;
	}
  
	QPRINTF(("\n"));

	return(csr == SBIC_CSR_SEL_TIMEO);
}

static int
sbicxfstart(sbic, len, phase, wait)
	struct sbic_softc *sbic;
	int len, wait;
	u_char phase;
{
	u_char id;

	if (phase == DATA_IN_PHASE || phase == MESG_IN_PHASE) {
		GET_SBIC_selid (sbic->sc_base, id);
		id |= SBIC_SID_FROM_SCSI;
		SET_SBIC_selid (sbic->sc_base, id);
		SBIC_TC_PUT (sbic->sc_base, (unsigned)len);
	} else if (phase == DATA_OUT_PHASE || phase == MESG_OUT_PHASE 
	    || phase == CMD_PHASE)
		SBIC_TC_PUT (sbic->sc_base, (unsigned)len);
	else
		SBIC_TC_PUT (sbic->sc_base, 0);
	QPRINTF(("sbicxfstart %d, %d, %d\n", len, phase, wait));

	return(1);
}

static int
sbicxfout(sbic, len, bp, phase)
	struct sbic_softc *sbic;
	int len;
	void *bp;
	int phase;
{
	u_char orig_csr, csr, asr, *buf;
	int wait;
	
	buf = bp;
	wait = sbic_data_wait;

	QPRINTF(("sbicxfout {%d} %02x %02x %02x %02x %02x "
	    "%02x %02x %02x %02x %02x\n", len, buf[0], buf[1], buf[2], 
	    buf[3], buf[4], buf[5], buf[6], buf[7], buf[8], buf[9]));

	GET_SBIC_csr (sbic->sc_base, orig_csr);

	/* 
	 * sigh.. WD-PROTO strikes again.. sending the command in one go
	 * causes the chip to lock up if talking to certain (misbehaving?)
	 * targets. Anyway, this procedure should work for all targets, but
	 * it's slightly slower due to the overhead
	 */
	WAIT_CIP (sbic->sc_base);
	SET_SBIC_cmd (sbic->sc_base, SBIC_CMD_XFER_INFO);
	for (;len > 0; len--) {
		GET_SBIC_asr (sbic->sc_base, asr);
		while ((asr & SBIC_ASR_DBR) == 0) {
			if ((asr & SBIC_ASR_INT) || --wait < 0) {
#ifdef DEBUG
				if (sbic_debug)
					printf("sbicxfout fail: l%d i%x w%d\n",
					    len, asr, wait);
#endif
				return (len);
			}
			DELAY(1);
			GET_SBIC_asr (sbic->sc_base, asr);
		}

		SET_SBIC_data (sbic->sc_base, *buf);
		buf++;
	}

	QPRINTF(("sbicxfout done\n"));
	/*
	 * this leaves with one csr to be read
	 */
	return(0);
}

static void
sbicxfin(sbic, len, bp)
	struct sbic_softc *sbic;
	int len;
	void *bp;
{
	int wait;
	u_char *obp, *buf;
	u_char orig_csr, csr, asr;
	
	wait = sbic_data_wait;
	obp = bp;
	buf = bp;

	GET_SBIC_csr (sbic->sc_base, orig_csr);

	QPRINTF(("sbicxfin %d, csr=%02x\n", len, orig_csr));

	WAIT_CIP (sbic->sc_base);
	SET_SBIC_cmd (sbic->sc_base, SBIC_CMD_XFER_INFO);
	for (;len > 0; len--) {
		GET_SBIC_asr (sbic->sc_base, asr);
		while ((asr & SBIC_ASR_DBR) == 0) {
			if ((asr & SBIC_ASR_INT) || --wait < 0) {
#ifdef DEBUG
				if (sbic_debug)
					printf("sbicxfin fail: l%d i%x w%d\n",
					    len, asr, wait);
#endif
				return;
			}

			DELAY(1);
			GET_SBIC_asr (sbic->sc_base, asr);
		}

		GET_SBIC_data (sbic->sc_base, *buf);
		buf++;
	}

	QPRINTF(("sbicxfin {%d} %02x %02x %02x %02x %02x %02x "
	    "%02x %02x %02x %02x\n", len, obp[0], obp[1], obp[2], 
	    obp[3], obp[4], obp[5], obp[6], obp[7], obp[8], obp[9]));

	/* this leaves with one csr to be read */
}


/*
 * SCSI 'immediate' command:  issue a command to some SCSI device
 * and get back an 'immediate' response (i.e., do programmed xfer
 * to get the response data).  'cbuf' is a buffer containing a scsi
 * command of length clen bytes.  'buf' is a buffer of length 'len'
 * bytes for data.  The transfer direction is determined by the device
 * (i.e., by the scsi bus data xfer phase).  If 'len' is zero, the
 * command must supply no data.  'xferphase' is the bus phase the
 * caller expects to happen after the command is issued.  It should
 * be one of DATA_IN_PHASE, DATA_OUT_PHASE or STATUS_PHASE.
 */
static int
sbicicmd(sbic, target, lun, cbuf, clen, buf, len, xferphase)
	struct sbic_softc *sbic;
	int target, lun;
	void *cbuf, *buf;
	int clen, len;
	u_char xferphase;
{
	u_char phase, csr, asr;
	int wait;

	/* 
	 * set the sbic into non-DMA mode
	 */
	SET_SBIC_control(sbic->sc_base, SBIC_CTL_EDI | SBIC_CTL_IDI);

retry_selection:
	/*
	 * select the SCSI bus (it's an error if bus isn't free)
	 */
	if (sbicselectbus(sbic, target, lun, sbic->sc_scsi_dev))
		return(-1);
	/* 
	 * Wait for a phase change (or error) then let the device sequence 
	 * us through the various SCSI phases.
	 */
	sbic->sc_stat[0] = 0xff;
	sbic->sc_msg[0] = 0xff;
	phase = CMD_PHASE;

new_phase:
	wait = sbic_cmd_wait;

	GET_SBIC_csr (sbic->sc_base, csr);
	QPRINTF((">CSR:%02x<", csr));

	/*
	 * requesting some new phase
	 */
	if ((csr != 0xff) && (csr & 0xf0) && (csr & 0x08))
		phase = csr & PHASE;
	else if ((csr == SBIC_CSR_DISC) || (csr == SBIC_CSR_DISC_1)
	    || (csr == SBIC_CSR_S_XFERRED)) {
		sbic->sc_flags &= ~SBICF_SELECTED;
		GET_SBIC_cmd_phase (sbic->sc_base, phase);
		if (phase == 0x60)
			GET_SBIC_tlun (sbic->sc_base, sbic->sc_stat[0]);
		else
			return(-1);
		goto out;
	} else {
		sbicerror(sbic, csr);
		goto abort;
	}

	switch (phase) {
	case CMD_PHASE:
		if (sbicxfstart (sbic, clen, phase, wait))
			if (sbicxfout (sbic, clen, cbuf, phase))
				goto abort;
		phase = xferphase;
		break;
	case DATA_IN_PHASE:
		if (len <= 0)
			goto abort;
		wait = sbic_data_wait;
		if (sbicxfstart(sbic, len, phase, wait))
			sbicxfin(sbic, len, buf);
		phase = STATUS_PHASE;
		break;
	case MESG_IN_PHASE:
		if (sbicxfstart(sbic, sizeof(sbic->sc_msg), phase, wait) == 0)
			break;
		sbic->sc_msg[0] = 0xff;
		sbicxfin(sbic, sizeof(sbic->sc_msg), sbic->sc_msg);
		/*
		 * get the command completion interrupt, or we 
		 * can't send a new command (LCI)
		 */
		SBIC_WAIT(sbic, SBIC_ASR_INT, wait);
		GET_SBIC_csr(sbic->sc_base, csr);
#ifdef DEBUG
		if (sync_debug)
			printf("msgin done csr 0x%x\n", csr);
#endif
		/*
		 * test whether this is a reply to our sync
		 * request
		 */
		if (sbic->sc_msg[0] == MSG_EXT_MESSAGE && sbic->sc_msg[1] == 3
		    && sbic->sc_msg[2] == MSG_SYNC_REQ) {

			sbic->sc_sync[target].period = sbicfromscsiperiod(sbic,
			    sbic->sc_msg[3]);
			sbic->sc_sync[target].offset = sbic->sc_msg[4];
			sbic->sc_sync[target].state = SYNC_DONE;
			SET_SBIC_syn(sbic->sc_base, SBIC_SYN(sbic->sc_sync[target].offset,
			    sbic->sc_sync[target].period));
			/* ACK the message */
			SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_CLR_ACK);
			WAIT_CIP(sbic->sc_base);
			phase = CMD_PHASE;  /* or whatever */
			printf("sbic%d: target %d now synchronous,"
			    " period=%dns, offset=%d.\n",
			    sbic->sc_link.adapter_unit, target, sbic->sc_msg[3] * 4,
			    sbic->sc_msg[4]);
		} else if (sbic->sc_msg[0] == MSG_REJECT
		    && sbic->sc_sync[target].state == SYNC_SENT) {
#ifdef DEBUG
			if (sync_debug)
				printf("target %d rejected sync, going async\n",
				    target);
#endif
			sbic->sc_sync[target].period = sbic_min_period;
			sbic->sc_sync[target].offset = 0;
			sbic->sc_sync[target].state = SYNC_DONE;
			SET_SBIC_syn(sbic->sc_base, SBIC_SYN(sbic->sc_sync[target].offset,
			    sbic->sc_sync[target].period));
			/* ACK the message */
			SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_CLR_ACK);
			WAIT_CIP(sbic->sc_base);
			phase = CMD_PHASE;  /* or whatever */
		} else if (sbic->sc_msg[0] == MSG_REJECT) {
			/*
			 * we'll never REJECt a REJECT message..
			 */
			/* ACK the message */
			SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_CLR_ACK);
			WAIT_CIP(sbic->sc_base);
			phase = CMD_PHASE;  /* or whatever */
		} else if (sbic->sc_msg[0] == MSG_CMD_COMPLETE
		    || sbic->sc_msg[0] == 0xff) {
			/* !! KLUDGE ALERT !! quite a few drives don't seem to 
			 * really like the current way of sending the
			 * sync-handshake together with the ident-message, and 
			 * they react by sending command-complete and
			 * disconnecting right after returning the valid sync
			 * handshake. So, all I can do is reselect the drive,
			 * and hope it won't disconnect again. I don't think
			 * this is valid behavior, but I can't help fixing a
			 * problem that apparently exists.
			 * 
			 * Note: we should not get here on `normal' command
			 * completion, as that condition is handled by the
			 * high-level sel&xfer resume command used to walk
			 * thru status/cc-phase.
			 */

#ifdef DEBUG
			if (sync_debug)
				printf ("GOT CMD-COMPLETE! %d acting weird.."
				    " waiting for disconnect...\n", target);
#endif
			/* ACK the message */
			SET_SBIC_cmd (sbic->sc_base, SBIC_CMD_CLR_ACK);
			WAIT_CIP(sbic->sc_base);

			/* wait for disconnect */
			while (csr != SBIC_CSR_DISC && 
			    csr != SBIC_CSR_DISC_1) {
				DELAY(1);
				GET_SBIC_csr(sbic->sc_base, csr);
			}
#ifdef DEBUG
			if (sync_debug)
				printf ("ok.\nRetrying selection.\n");
#endif
			sbic->sc_flags &= ~SBICF_SELECTED;
			goto retry_selection;
		} else {
#ifdef DEBUG
			if (sbic_debug || sync_debug)
				printf ("Rejecting message 0x%02x\n",
				    sbic->sc_msg[0]);
#endif
			/* prepare to reject the message, NACK */
			SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_SET_ATN);
			WAIT_CIP(sbic->sc_base);
			SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_CLR_ACK);
			WAIT_CIP(sbic->sc_base);
			phase = MESG_OUT_PHASE;
		}
		break;

	case MESG_OUT_PHASE:
#ifdef DEBUG
		if (sync_debug)
			printf ("sending REJECT msg to last msg.\n");
#endif
		/*
		 * should only get here on reject, 
		 * since it's always US that
		 * initiate a sync transfer
		 */
		SEND_BYTE(sbic, MSG_REJECT);
		phase = STATUS_PHASE;
		break;
	case DATA_OUT_PHASE:
		if (len <= 0)
			goto abort;
		wait = sbic_data_wait;
		if (sbicxfstart(sbic, len, phase, wait))
			if (sbicxfout (sbic, len, buf, phase))
				goto abort;
		phase = STATUS_PHASE;
		break;
	case STATUS_PHASE:
		/* 
		 * the sbic does the status/cmd-complete reading ok,
		 * so do this with its hi-level commands.
		 */
		SBIC_TC_PUT(sbic->sc_base, 0);
		SET_SBIC_cmd_phase(sbic->sc_base, 0x46);
		SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_SEL_ATN_XFER);
		phase = BUS_FREE_PHASE;
		break;
	case BUS_FREE_PHASE:
		goto out;
	default:
		printf("sbic%d: unexpected phase %d in icmd from %d\n",
		    sbic->sc_link.adapter_unit, phase, target);
		goto abort;
	}

	/*
	 * make sure the last command was taken, 
	 * ie. we're not hunting after an ignored command..
	 */
	GET_SBIC_asr(sbic->sc_base, asr);
	if (asr & SBIC_ASR_LCI)
		goto abort;

	/* tapes may take a loooong time.. */
	while (asr & SBIC_ASR_BSY) {
		DELAY(1);
		GET_SBIC_asr(sbic->sc_base, asr);
	}

	/* 
	 * wait for last command to complete
	 */
	SBIC_WAIT (sbic, SBIC_ASR_INT, wait);

	/*
	 * do it again
	 */
	goto new_phase;
abort:
	sbicabort(sbic, "icmd");
out:
	QPRINTF(("=STS:%02x=", sbic->sc_stat[0]));
	return(sbic->sc_stat[0]);
}

/*
 * Finish SCSI xfer command:  After the completion interrupt from
 * a read/write operation, sequence through the final phases in
 * programmed i/o.  This routine is a lot like sbicicmd except we
 * skip (and don't allow) the select, cmd out and data in/out phases.
 */
static void
sbicxfdone(sbic, target)
	struct sbic_softc *sbic;
	int target;
{
	u_char phase, csr;
	int s;

	QPRINTF(("{"));
	s = splbio();

	/*
	 * have the sbic complete on its own
	 */
	SBIC_TC_PUT(sbic->sc_base, 0);
	SET_SBIC_cmd_phase(sbic->sc_base, 0x46);
	SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_SEL_ATN_XFER);

	do {
		SBIC_WAIT (sbic, SBIC_ASR_INT, 0);
		GET_SBIC_csr (sbic->sc_base, csr);
		QPRINTF(("%02x:", csr));
	} while ((csr != SBIC_CSR_DISC) && (csr != SBIC_CSR_DISC_1)
	    && (csr != SBIC_CSR_S_XFERRED));

	sbic->sc_flags &= ~SBICF_SELECTED;

	GET_SBIC_cmd_phase (sbic->sc_base, phase);
	QPRINTF(("}%02x", phase));
	if (phase == 0x60)
		GET_SBIC_tlun(sbic->sc_base, sbic->sc_stat[0]);
	else
		sbicerror(sbic, csr);

	QPRINTF(("=STS:%02x=\n", sbic->sc_stat[0]));
	splx(s);
}

static int
sbicgo(sbic, xs)
	struct sbic_softc *sbic;
	struct scsi_xfer *xs;
{
	int i, target, len, wait;
	int seg, thiskv, thisphys, nextphys, datalen;
	int bytes_this_seg, bytes_this_page;
	u_char phase, csr, asr, cmd;
	struct dma_chain *sg;

	target = xs->sc_link->target;
	datalen = xs->datalen;
	thiskv = (int)xs->data;

	/*
	 * set the sbic into DMA mode
	 */
	SET_SBIC_control(sbic->sc_base, SBIC_CTL_EDI | SBIC_CTL_IDI |
	    SBIC_MACHINE_DMA_MODE);

	/*
	 * select the SCSI bus (it's an error if bus isn't free)
	 */
	if (sbicselectbus(sbic, target, xs->sc_link->lun,
	    sbic->sc_scsi_dev)) {
		sbic_dmastop(sbic);
		SBIC_DISABLE_INT(sbic->sc_base);
		return(-1);
	}

	/*
	 * Wait for a phase change (or error) then let the device
	 * sequence us through command phase (we may have to take
	 * a msg in/out before doing the command).  If the disk has
	 * to do a seek, it may be a long time until we get a change
	 * to data phase so, in the absense of an explicit phase
	 * change, we assume data phase will be coming up and tell
	 * the SPC to start a transfer whenever it does.  We'll get
	 * a service required interrupt later if this assumption is
	 * wrong.  Otherwise we'll get a service required int when
	 * the transfer changes to status phase.
	 */
	phase = CMD_PHASE;

new_phase:
	wait = sbic_cmd_wait;
	switch (phase) {
	case CMD_PHASE:
		if (sbicxfstart(sbic, xs->cmdlen, phase, wait))
			if (sbicxfout(sbic, xs->cmdlen, xs->cmd, phase))
				goto abort;
		break;
	case MESG_IN_PHASE:
		if (sbicxfstart(sbic, sizeof(sbic->sc_msg), phase, wait) == 0)
			break;

		sbicxfin(sbic, sizeof(sbic->sc_msg), sbic->sc_msg);
		/*
		 * prepare to reject any mesgin, 
		 * no matter what it might be..
		 */
		SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_SET_ATN);
		WAIT_CIP(sbic->sc_base);
		SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_CLR_ACK);
		phase = MESG_OUT_PHASE;
		break;
	case MESG_OUT_PHASE:
		SEND_BYTE(sbic, MSG_REJECT);
		phase = STATUS_PHASE;
		break;
	case DATA_IN_PHASE:
	case DATA_OUT_PHASE:
		goto out;
	/*
	 * status phase can happen, if the issued read/write command
	 * is illegal (for example, reading after EOT on tape) and the 
	 * device doesn't even go to data in/out phase. So handle this 
	 * here normally, instead of going thru abort-handling.
	 */
	case STATUS_PHASE:
		sbic_dmastop(sbic);
		SBIC_DISABLE_INT(sbic->sc_base);
		sbicxfdone(sbic, target);
		sbic->sc_flags &= ~(SBICF_INDMA | SBICF_BBUF);
		sbic_scsidone(sbic, sbic->sc_stat[0]);
		return(0);
	default:
		printf("sbic%d: unexpected phase %d in go from %d\n", phase,
		    sbic->sc_link.adapter_unit, target);
		goto abort;
	}

	/*
	 * make sure the last command was taken, 
	 * ie. we're not hunting after an ignored command..
	 */
	GET_SBIC_asr(sbic->sc_base, asr);
	if (asr & SBIC_ASR_LCI)
		goto abort;

	/* 
	 * tapes may take a loooong time..
	 */
	while (asr & SBIC_ASR_BSY) {
		DELAY(1);
		GET_SBIC_asr(sbic->sc_base, asr);
	}

	if (wait <= 0)            
		goto abort;

	/*
	 * wait for last command to complete
	 */
	SBIC_WAIT(sbic, SBIC_ASR_INT, wait);

	GET_SBIC_csr(sbic->sc_base, csr);
	QPRINTF((">CSR:%02x<", csr));

	/* 
	 * requesting some new phase
	 */
	if ((csr != 0xff) && (csr & 0xf0) && (csr & 0x08))
		phase = csr & PHASE;
	else {
		sbicerror(sbic, csr);
		goto abort;
	}
	/*
	 * start again with for new phase
	 */
	goto new_phase;
out:
	/*
	 * Build the DMA chain
	 */
	thisphys = KVTOPHYS(thiskv);
	seg = 0;
	sg = sbic->sc_chain;
	while((datalen) && (seg < SBIC_NSEG)) {
		bytes_this_seg = 0;
		sg->dc_addr = thisphys;
		nextphys = thisphys;
		while((datalen) && (thisphys == nextphys)) {
			nextphys = (thisphys & ~PAGE_MASK) + PAGE_SIZE;
			bytes_this_page = nextphys - thisphys;
			bytes_this_page = min(bytes_this_page, datalen);
			bytes_this_seg += bytes_this_page;
			datalen -= bytes_this_page;
			thiskv = (thiskv & ~PAGE_MASK) + PAGE_SIZE;
			if (datalen)
				thisphys = KVTOPHYS(thiskv);
		}
		sg->dc_count = bytes_this_seg;
		sg++;
		seg++;
	}
	sbic->sc_cur = sbic->sc_chain;
	sbic->sc_last = --sg;

#ifdef DEBUG
	if (sbic_dma_debug) {
		for (sg = sbic->sc_chain; sg <= sbic->sc_last; sg++)
			printf("\n  %d: %d@%x", sg-sbic->sc_chain,
			    sg->dc_count, sg->dc_addr);
		printf("Total: %d  ", xs->datalen);
	}
#endif

	sbic_dmastart(sbic);
	SBIC_ENABLE_INT(sbic->sc_base);
	SBIC_TC_PUT(sbic->sc_base, (unsigned)sbic->sc_cur->dc_count);
	SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_XFER_INFO);

	return(0);

abort:
	sbicabort(sbic, "go");
	sbic_dmastop(sbic);
	SBIC_DISABLE_INT(sbic->sc_base);
	return(-1);
}


void
sbicintr(unit)
	int unit;
{
	struct sbic_softc *sbic = sbicdata[unit];
	u_char asr, csr;
	int i;

	/*
	 * pending interrupt?
	 */
	GET_SBIC_asr (sbic->sc_base, asr);
	if ((asr & SBIC_ASR_INT) == 0)
		return;
	GET_SBIC_csr(sbic->sc_base, csr);
	QPRINTF(("[0x%x]", csr));

	if (csr == (SBIC_CSR_XFERRED|STATUS_PHASE)
	    || csr == (SBIC_CSR_MIS|STATUS_PHASE)
	    || csr == (SBIC_CSR_MIS_1|STATUS_PHASE)
	    || csr == (SBIC_CSR_MIS_2|STATUS_PHASE)) {
		/*
		 * this should be the normal i/o completion case.
		 * get the status & cmd complete msg then let the
		 * device driver look at what happened.
		 */
		sbic_dmastop(sbic);
		SBIC_DISABLE_INT(sbic->sc_base);
		sbicxfdone(sbic, sbic->sc_xs->sc_link->target);
		/*
		 * check for overlapping cache line, flush if so
		 */
		sbic->sc_flags &= ~(SBICF_INDMA | SBICF_BBUF | SBICF_DCFLUSH);
		sbic_scsidone(sbic, sbic->sc_stat[0]);
	} else if (csr == (SBIC_CSR_XFERRED|DATA_OUT_PHASE)
	    || csr == (SBIC_CSR_XFERRED|DATA_IN_PHASE)
	    || csr == (SBIC_CSR_MIS|DATA_OUT_PHASE)
	    || csr == (SBIC_CSR_MIS|DATA_IN_PHASE)
	    || csr == (SBIC_CSR_MIS_1|DATA_OUT_PHASE)
	    || csr == (SBIC_CSR_MIS_1|DATA_IN_PHASE)
	    || csr == (SBIC_CSR_MIS_2|DATA_OUT_PHASE)
	    || csr == (SBIC_CSR_MIS_2|DATA_IN_PHASE)) {
		/*
		 * do scatter-gather dma 
		 * hacking the controller chip, ouch..
		 */
		/*
		 * set next dma addr and dec count
		 */
		sbic_dmastop(sbic);
		++sbic->sc_cur;		/* advance to next segment */
		sbic_dmastart(sbic);
		SBIC_TC_PUT(sbic->sc_base, (unsigned)sbic->sc_cur->dc_count);
		SET_SBIC_cmd(sbic->sc_base, SBIC_CMD_XFER_INFO);
	} else {
		/*
		 * Something unexpected happened -- deal with it.
		 */
		sbic_dmastop(sbic);
		sbicerror(sbic, csr);
		sbicabort(sbic, "intr");
		if (sbic->sc_flags & SBICF_INDMA) {
			/*
			 * check for overlapping cache line, flush if so
			 */
			sbic->sc_flags &= 
			    ~(SBICF_INDMA | SBICF_BBUF | SBICF_DCFLUSH);
			SBIC_DISABLE_INT(sbic->sc_base);
			sbic_scsidone(sbic, -1);
		}
	}
	return;
}

static int 
sbictoscsiperiod(sbic, a)
	struct sbic_softc *sbic;
	int a;
{
	unsigned int fs;
  
	/*
	 * cycle = DIV / (2*CLK)
	 * DIV = FS+2
	 * best we can do is 200ns at 20Mhz, 2 cycles
	 */
  
	GET_SBIC_myid(sbic->sc_base,fs);
	fs = (fs >>6) + 2;		/* DIV */
	fs = (fs * 10000) / (sbic->sc_clkfreq<<1);	/* Cycle, in ns */
	if (a < 2) a = 8;		/* map to Cycles */
	return ((fs*a)>>2);		/* in 4 ns units */
}

static int 
sbicfromscsiperiod(sbic, p)
	struct sbic_softc *sbic;
	int p;
{
	register unsigned int fs, ret;
  
	/* Just the inverse of the above */
  
	GET_SBIC_myid(sbic->sc_base,fs);
	fs = (fs >>6) + 2;		/* DIV */
	fs = (fs * 10000) / (sbic->sc_clkfreq<<1);   /* Cycle, in ns */
  
	ret = p << 2;			/* in ns units */
	ret = ret / fs;			/* in Cycles */
	if (ret < sbic_min_period)
		return(sbic_min_period);

	/* verify rounding */
	if (sbictoscsiperiod(sbic, ret) < p)
		ret++;
	return (ret >= 8) ? 0 : ret;
}

#define	DMA_SMSK	(IO_DMA + 0x14)
#define	DMA_MODE	(IO_DMA + 0x16)
#define	DMA_FFC		(IO_DMA + 0x18)

#define	DMA37SM_CLEAR	0x00
#define	DMA37SM_SET	0x04

#define	DMA_CHN(c)	(IO_DMA + ((c) << 2))

static void
sbic_dmastart(sbic)
	struct sbic_softc *sbic;
{
	int waport;

#ifdef CYRIX_5X86
	/* Cyrix 5x86 */
	asm("wbinvd");	/* wbinvd (WB cache flush) */
#endif

#ifdef	SC98BUSMASTER
	if (sc98busmaster) {
		sbic_write_reg(sbic->sc_base, 0x73, 0x32);
		sbic_write_reg(sbic->sc_base, 0x74, 0x23);
	}
#endif

	/* mask channel */
	outb(DMA_SMSK, sbic->sc_dma | DMA37SM_SET);

	/* set dma channel mode, and reset address ff */
	if (sbic->sc_xs->flags & SCSI_DATA_IN)
		outb(DMA_MODE, sbic->sc_dma | DMA37MD_SINGLE | DMA37MD_WRITE);
	else
		outb(DMA_MODE, sbic->sc_dma | DMA37MD_SINGLE | DMA37MD_READ);
	outb(DMA_FFC, 0);

	/* send start address */
	waport = DMA_CHN(sbic->sc_dma);
	outb(waport, sbic->sc_cur->dc_addr);
	outb(waport, sbic->sc_cur->dc_addr>>8);
	outb(dmapageport[sbic->sc_dma], sbic->sc_cur->dc_addr>>16);

	/* send count */
	outb(waport + 2, sbic->sc_cur->dc_count - 1);
	outb(waport + 2, (sbic->sc_cur->dc_count-1)>>8);

	/* unmask channel */
	outb(DMA_SMSK, sbic->sc_dma | DMA37SM_CLEAR);

	/* SCSI DMA enable */
	outb(sbic->sc_base + 4, 1);
}

static void
sbic_dmastop(sbic)
	struct sbic_softc *sbic;
{
#if defined(CYRIX_486DLC) || defined(IBM_486SLC)
	if (sbic->sc_xs->flags & SCSI_DATA_IN) {
		/* cache flush only after reading 92/12/9 by A.Kojima */
		asm("	.byte 0x0f,0x08");	/* invd (cache flush) */
	}
#endif
	/* mask channel */
	outb(DMA_SMSK, DMA37SM_SET | sbic->sc_dma);

	/* SCSI DMA disable */
	outb(sbic->sc_base + 4, 2);

#ifdef	SC98BUSMASTER
	if (sc98busmaster) {
		sbic_write_reg(sbic->sc_base, 0x73, 0x43);
		sbic_write_reg(sbic->sc_base, 0x74, 0x34);
	}
#endif
}
