#! /bin/sh -

# $FreeBSD$
#
# stage1 -- this script prepares the actual picobsd image

. ../Version

set -e	# abort in case of untested errors

# By default, /tmp should exist.
#
MFS_NAME=fs.PICOBSD
MFS_MOUNTPOINT=`mktemp -d "/tmp/picobsd.XXXXXXXXXX"`
export MFS_MOUNTPOINT

PICO_OBJ=${OBJ}/picobsd/${TYPE}
export PICO_OBJ

# Location of the boot blocks (in case you want them custom-built)
boot1=/boot/boot1
boot2=/boot/boot2

rm -f kernel.gz ${MFS_NAME}    # cleanup...

# find a suitable vnode
VNUM=`mount | awk "/vn/ { num++ } END { printf \"%d\", num }"`
export VNUM
echo "-> Using vn${VNUM}..."

trap fail 2	# catch user interrupt

# free as much as possible from the vnode
free_vnode() {
    umount ${MFS_MOUNTPOINT} 2> /dev/null || true
    umount /dev/vn${VNUM} 2> /dev/null || true
    vnconfig -u /dev/rvn${VNUM} 2> /dev/null || true
}

# fail errno errcode
# This function is used to trap errors and print msgs
#
fail() {
    errno=$1
    errcode=$2
    echo "--> Error $errno code $errcode"
    case $errcode in
    no_vnconfig)
	echo "Error while doing vnconfig of ${MFS_NAME} on /dev/rvn${VNUM}..."
	echo "   Most probably your running kernel doesn't have the vn(4) device."
	;;
    disklabel)
	echo "Error while labeling ${MFS_NAME} size ${MFS_SIZE}"
	;;
    no_mount)
	echo "Error while mounting ${MFS_NAME} (/dev/vn${VNUM}c) on ${MFS_MOUNTPOINT}"
	;;
    mtree)
	echo "Error while making hierarchy in ${MFS_MOUNTPOINT}"
	;;
    makedevs)
	echo "Error while making devices in ${MFS_MOUNTPOINT}"
	;;
    crunch)
	echo "Error while building ../${TYPE}/crunch1..."
	;;
    vnconfig2)
	echo "Error while doing vnconfig of floppy.img on /dev/rvn${VNUM}..."
	;;
    disklabel)
	echo "Error while doing disklabel on of floppy.img size $FLOPPY_SIZE"
	;;
    kernel_compress)
	echo "Error while copying compressed kernel to disk"
	;;
    mfs_compress)
	echo "Error while copying compressed mfs image to disk"
	;;
    missing_kernel)
	echo "-> ERROR: you must build PICOBSD${suffix} kernel first"
	;;
    *)
	echo "unknown error, maybe user break: $errno $errcode"   
	;;
    esac
    echo "-> Aborting $0"
    # try to cleanup the vnode.
    free_vnode
    rm -rf ${MFS_MOUNTPOINT} 2> /dev/null || true
    exit 10
}

create_mfs() {
    echo "-> Preparing MFS filesystem..."

    free_vnode

    # zero-fill the MFS image
    dd of=${MFS_NAME} if=/dev/zero count=${MFS_SIZE} bs=1k 2> /dev/null

    vnconfig -s labels -c /dev/rvn${VNUM} ${MFS_NAME} 2>/dev/null || \
	    fail $? no_vnconfig

    dd if=/boot/boot1 of=${MFS_NAME} conv=notrunc 2> /dev/null

    # This command does weird things on 2.2.x systems.
    # For small image sizes, use std disktypes
    if [ ${MFS_SIZE} -lt 1024 ] ; then
	disklabel -rw /dev/rvn${VNUM} fd${MFS_SIZE} || fail $? disklabel
    else
	disklabel -rw vn${VNUM} auto || fail $? disklabel
    fi

    newfs -i ${MFS_INODES} -m 0 -p 0 -o space /dev/rvn${VNUM}c
    mount /dev/vn${VNUM}c ${MFS_MOUNTPOINT} || fail $? no_mount

    pwd=`pwd`
}

populate_mfs() {
    echo "-> Populating MFS tree..."
    cd ../${TYPE}
    make -f Makefile.mfs DESTDIR=${MFS_MOUNTPOINT} > /dev/null || \
	fail $? mtree
    if [ X"${NO_DEVFS}" != X"" ] ; then
	make -f Makefile.mfs DESTDIR=${MFS_MOUNTPOINT} devnodes \
		> /dev/null || fail $? makedevs
    fi

    MFS_RC=mfs_tree/etc/rc
    if [ ! -f ${MFS_RC} ] ; then # no private version. use generic mfs.rc
	MFS_RC=${BUILDDIR}/../${MFS_RC}
    fi
    if [ "${INIT}" = "oinit" ] ; then
	cat ${MFS_RC} | sed -e "s/@VER@/${VER}/g" > ${MFS_MOUNTPOINT}/etc/oinit.rc
    else
	cat ${MFS_RC} | sed -e "s/@VER@/${VER}/g" > ${MFS_MOUNTPOINT}/etc/rc
	fname=mfs_tree/etc/login.conf
	if [ ! -f ${fname} ] ; then
	    fname=${BUILDDIR}/../${fname}
	fi
	cp ${fname} ${MFS_MOUNTPOINT}/etc/login.conf
    fi

    if [ "${TYPE}" = "dial" ] ; then
	for i in login dialup; do
	    cp lang/${i}.${LANGUAGE} ${MFS_MOUNTPOINT}/stand/${i}
	done
	ln -s /stand/reboot ${MFS_MOUNTPOINT}/stand/shutdown
	(cd ../help;\
	rm -rf tmp_hlp;\
	mkdir tmp_hlp;\
	for i in `ls *.hlp.${LANGUAGE}`; do \
	    cp $i tmp_hlp/`basename $i .hlp.${LANGUAGE}`;\
	done;\
	cd tmp_hlp;\
	ar -cru help.a *;\
	cp help.a ${MFS_MOUNTPOINT}/help.a)
    fi

    echo "-> Making and installing crunch1..."
    cd crunch1
    make -f ../../build/Makefile.crunch "SRC=${SRC}" && \
	make -f ../../build/Makefile.crunch install 2>&1 >/dev/null || \
	fail $? crunch

    cd ${pwd}
    if [ -f ${MFS_MOUNTPOINT}/stand/sshd ] ; then
	echo "creating host key for sshd"
	ssh-keygen -f ${MFS_MOUNTPOINT}/etc/ssh_host_key -N "" -C "root@picobsd"
    fi
    cp -Rp ../mfs_tree/stand/update ${MFS_MOUNTPOINT}/stand/update

    (echo "-> Fixing permissions"; cd ${MFS_MOUNTPOINT}; chown -R root *)
    df -ik ${MFS_MOUNTPOINT}
    umount ${MFS_MOUNTPOINT}
    fsck -p /dev/rvn${VNUM}c
    vnconfig -u /dev/rvn${VNUM}
}

do_kernel() {
    echo "-> Preparing kernel..."
    (cd ../${TYPE}; make -v -f ${BUILDDIR}/Makefile.conf )
    cp -p ${SRC}/sys/compile/PICOBSD${suffix}/kernel kernel || \
	fail $? missing_kernel
    strip kernel
    strip --remove-section=.note --remove-section=.comment kernel
}

do_floppy() {
    # On entry we are in /usr/src/release/build.

    echo "==> Preparing ${FLOPPY_SIZE}kB floppy filesystem..."

    # correct block and number of sectors according to size.
    blocks=${FLOPPY_SIZE}
    sectors=18
    if [ "${blocks}" = "1720" ]; then
	blocks=1722
	sectors=21
    elif [ "${blocks}" = "1480" ]; then
	blocks=1476
    fi
    echo "${sectors} sectors per track"
    # create image
    dd of=picobsd.bin if=/dev/zero count=${blocks} bs=1k
    # put in boot sector so vnconfig and disklabel will not complain
    dd if=${boot1} of=picobsd.bin conv=notrunc 2> /dev/null
    vnconfig -c /dev/rvn${VNUM} picobsd.bin || fail $? vnconfig2

    disklabel -Brw -b ${boot1} -s ${boot2} /dev/vn${VNUM}c \
	fd${FLOPPY_SIZE} || \
	fail $?  disklabel

    newfs -i ${FLOPPY_INODES} -m 0 -p 0 -o space /dev/rvn${VNUM}c

    mount /dev/vn${VNUM}c ${MFS_MOUNTPOINT}

    # preload kernel, compress with kgzip and copy to floppy image
    cc -o ./wmk /usr/src/release/write_mfs_in_kernel.c
    ./wmk kernel ${MFS_NAME}
    rm wmk
    kgzip -o kernel.gz kernel
    cp -p kernel.gz ${MFS_MOUNTPOINT}/kernel

    echo "==> Populating floppy filesystem..."

    # Configuration files are first copied to a local tree, then
    # compressed, then transferred back to the floppy.
    rm -rf floppy.tree || true
    mkdir floppy.tree

    excl=${BUILDDIR}/../${TYPE}/floppy.tree.exclude
    if [ -f ${excl} ] ; then
	excl="--exclude-from ${excl}"
	echo "Exclude following files from ${excl}:\n==="
	cat ${excl}
	echo "==="
    else
	excl=""
    fi
    (cd ${BUILDDIR}/../floppy.tree ; tar -cf - --exclude CVS ${excl} . ) | \
		(cd floppy.tree ; tar xvf - )

    srcdir=${BUILDDIR}/../${TYPE}/floppy.tree
    if [ -d ${srcdir} ] ; then
	echo "-> update with private files:"
	(cd ${srcdir} ; tar cf - --exclude CVS . ) | \
	    (cd floppy.tree ; tar xvf - )
    fi
    if [ -d ${srcdir}.${SITE} ] ; then
	echo "-> update with site-specific (${SITE}) files:"
	(cd ${srcdir}.${SITE} ; tar cf - --exclude CVS . ) | \
	    (cd floppy.tree ; tar xvf - )
    fi
    files="motd"
    echo "-> Copying language dependent files: ${files} -> ${MFS_MOUNTPOINT}/etc ..."
    for i in ${files} ; do
	if [ -f ${BUILDDIR}/../${TYPE}/lang/${i}.${LANGUAGE} ] ; then
	    cat ${BUILDDIR}/../${TYPE}/lang/${i}.${LANGUAGE} | \
		sed -e "s/@VER@/${VER}/g" > floppy.tree/etc/${i}
	fi
    done

    # XXX check this! i am unsure how it is necessary.
    if [ "${TYPE}" = "dial" ] ; then
	cp -p floppy.tree/etc/master.passwd .
	pwd_mkdb -d . master.passwd
	mv spwd.db floppy.tree/etc/
	rm pwd.db master.passwd
    fi
    # gzip returns an error if it fails to compress some file
    gzip -9 floppy.tree/etc/* || true

    # now transfer the floppy tree
    cp -Rp floppy.tree/* ${MFS_MOUNTPOINT}
    rm -rf floppy.tree || true # cleanup
    (echo "-> Fixing permissions"; cd ${MFS_MOUNTPOINT} ; chown -R root *)

    df -ik ${MFS_MOUNTPOINT} | colrm 70 > .build.reply
    umount ${MFS_MOUNTPOINT}
    rm -rf ${MFS_MOUNTPOINT}
    vnconfig -u /dev/rvn${VNUM}
    rm kernel.gz ${MFS_NAME}
}

do_kernel
create_mfs
populate_mfs
do_floppy
