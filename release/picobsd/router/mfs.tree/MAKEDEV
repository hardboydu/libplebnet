#!/bin/sh -
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Written and contributed by W. Jolitz 12/90
#
# Redistribution and use in source and binary forms are permitted provided
# that: (1) source distributions retain this entire copyright notice and
# comment, and (2) distributions including binaries display the following
# acknowledgement:  ``This product includes software developed by the
# University of California, Berkeley and its contributors'' in the
# documentation or other materials provided with the distribution and in
# all advertising materials mentioning features or use of this software.
# Neither the name of the University nor the names of its contributors may
# be used to endorse or promote products derived from this software without
# specific prior written permission.
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
#	@(#)MAKEDEV	5.2 (Berkeley) 6/22/90
#
# Device "make" file.  Valid arguments:
#	all	makes all known devices, standard number of units (or close)
#	std	standard devices
#	local	configuration specific devices
#	mach-4	mach4&lites+devices for Mach's XFree86 distribution
#	(see http://www.cs.hut.fi/lites.html for more info on LITES)
#
# Tapes:
#	wt*	QIC-interfaced (e.g. not SCSI) 3M cartridge tape
#	st*	"NEW type scsi tapes" (old driver uses the
#		block devices of the disks to get access)
#	ft*	QIC-40/QIC-80 3M cartridge tape (interfaced
#		via the floppy disk controller)
#
# Disks:
#	wd*	"Winchester" disk drives (ST506,IDE,ESDI,RLL,...)
#	wfd*	"IDE floppy" disk drives (LS-120)
#	fd*	"floppy" disk drives (3 1/2", 5 1/4")
#	sd*	"SCSI disks"
#	cd*	"SCSI CD-ROM disks"
#	mcd*	"Mitsumi CD-ROM disks"
#	scd*	"Sony CD-ROM disks"
#	matcd*	"Matsushita (Panasonic) CD-ROM disks"
#	wcd*	"IDE CD-ROM disks"
#	vn*	"vnode disks"
#	od*	"optical disks"
#
# Console ports:
#	vty*	virtual console devices for syscons/pcvt/codrv
#
# Pointing devices:
#	mse*	Logitech and ATI Inport bus mouse
#	psm*	PS/2 mouse
#	sysmouse Mousesystems mouse emulator for syscons
#
# Time devices:
#	refclock-*  serial ports used by xntpd parse refclocks
#
# Terminal ports:
#	tty*	general purpose serial ports
#	cua*	dialout serial ports
#	ttyA*	Specialix SI/XIO dialin ports ('*' = number of devices)
#	cuaA*	Specialix SI/XIO dialout ports
#	ttyD*	Digiboard - 16 dialin ports
#	cuaD*	Digiboard - 16 dialout ports
#	ttyR*	Rocketport dialin ports
#	cuaR*	Rocketport dialout ports
#
# Pseudo terminals:
#	pty*	set of 32 master and slave pseudo terminals
#	vty*	virtual terminals using syscons/pcvt/codrv console
#
# Printers:
#	lpt*	stock lp
#
# SCSI devices (other than CD-ROM, tape and disk):
#	ssc	The ``super scsi'' device
#	uk*	"unknown" device (supports ioctl calls only)
#	worm*	WORM driver
#	pt*	Processor Type (HP scanner, as one example)
#
# PC-CARD (previously called PCMCIA) support
#	card*	PC-CARD slots
#
# Special purpose devices:
#	apm	Advanced Power Management BIOS
#	bpf*	packet filter
#	speaker	pc speaker
#	tw*	xten power controller
#	snd*	various sound cards
#	pcaudio PCM audio driver
#	socksys iBCS2 socket system driver
#	vat	VAT compatibility audio driver (requires snd*)
#	gsc	Genius GS-4500 hand scanner
#	joy	pc joystick
#	tun*	Tunneling IP device
#	snp*	tty snoop devices
#	spigot	Video Spigot video acquisition card
#	ctx*    Cortex-I video acquisition card
#	meteor*	Matrox Meteor video acquisition card (pci)
#	bktr*	Bt848 based video acquisition card (pci)
#	labpc*	National Instrument's Lab-PC and LAB-PC+
#	perfmon	CPU performance-monitoring counters
#	pci	PCI configuration-space access from user mode
#	ipl	ipfilter control devices (ipl, ipnat, ipstate, ipauth)
#
#	$Id: MAKEDEV,v 1.1 1998/08/02 13:03:32 abial Exp $
#

PATH=/sbin:/bin/:/usr/bin:/usr/sbin:$PATH
umask 77

# Usage: die exitcode msg
die() {
	echo $2
	exit $1
}

# Convert integer to partition name
dkitop() {
	local p

	case $1 in
	0) p=a;; 1) p=b;; 2) p=c;; 3) p=d;; 4) p=e;; 5) p=f;; 6) p=g;; 7) p=h;;
	*) p="?";;
	esac
	echo $p
}

# Convert integer to slice name
dkitos() {
	local s

	case $1 in
	0) s="";;
	1) s="";;
	*) s=s$(($1-1));;
	esac
	echo $s
}

# Convert disk (type, unit, slice, partition) to minor number
dkminor()
{
	echo $(($1 << 25 | ($2 / 32) << 21 | ($2 % 32) << 3 | $3 << 16 | $4))
}

# Override mknod(2) to add extra handling to it.
mknod() {
	rm -f "$1" || exit 1
	/sbin/mknod "$@" || die 2 "/sbin/mknod $@ failed"
	chown root.wheel "$1" || exit 1
}

# Convert the last character of a tty name to a minor number.
ttyminor()
{
	case $unit in
	[0-9]) m=$unit;;
	a) m=10;; b) m=11;; c) m=12;; d) m=13;; e) m=14;; f) m=15;; g) m=16;;
	h) m=17;; i) m=18;; j) m=19;; k) m=20;; l) m=21;; m) m=22;; n) m=23;;
	o) m=24;; p) m=25;; q) m=26;; r) m=27;; s) m=28;; t) m=29;; u) m=30;;
	v) m=31;;
	*) m="?";;
	esac
	echo $m
}

# Raw partition for disks
dkrawpart=2

# Compatibility slice for disks
dkcompatslice=0

# Raw slice for disks
dkrawslice=1

# Control bit for SCSI
scsictl=$((1 << 29))

# Standard umasks
disk_umask=037			# allow group operator to read disks
tape_umask=017			# allow group operator to read/write tapes

for i in $*; do
case $i in

all)
	sh MAKEDEV std					# standard
	sh MAKEDEV fd0 fd1				# bdev, floppy disk
	sh MAKEDEV sd0 sd1 sd2 sd3 wd0 wd1 wd2 wd3	# bdev, ordinary disk
	sh MAKEDEV od0					# bdev, optical disk
	sh MAKEDEV wfd0					# bdev, LS-120 floppy
	sh MAKEDEV vn0					# bdev, virtual disk
	sh MAKEDEV cd0 matcd0 mcd0 scd0 wcd0		# bdev, cdrom
	sh MAKEDEV ft0 st0 wt0				# bdev, tape
	sh MAKEDEV vty4					# cdev, virtual tty
	sh MAKEDEV cuaa0 cuaa1 cuaa2 cuaa3		# cdev, serial tty
	sh MAKEDEV pty0					# cdev, pseudo tty
	sh MAKEDEV ttyd0 ttyd1 ttyd2 ttyd3		# cdev, serial tty
	sh MAKEDEV mse0 psm0 sysmouse			# cdev, mouse
	sh MAKEDEV pcaudio speaker			# cdev, noise
	sh MAKEDEV lpt0 lpt1 lpt2			# cdev, printer
	sh MAKEDEV bpf0 ipl tun0			# cdev, network
	sh MAKEDEV ch0 perfmon tw0			# cdev, miscellaneous
	sh MAKEDEV apm card0 card1			# cdev, laptop
	;;
std)
	mknod console	c 0 0;	chmod 600 console
	mknod drum	c 4 0;	chmod 640 drum;		chgrp kmem drum
	mknod kmem	c 2 1;	chmod 640 kmem;		chgrp kmem kmem
	mknod mem	c 2 0;	chmod 640 mem;		chgrp kmem mem
	mknod null	c 2 2;	chmod 666 null
	mknod random	c 2 3;	chmod 644 random
	mknod urandom	c 2 4;	chmod 644 urandom
	mknod zero	c 2 12;	chmod 666 zero
	mknod io	c 2 14;	chmod 600 io
	mknod tty	c 1 0;	chmod 666 tty
	mknod klog	c 7 0;	chmod 600 klog
	mknod stdin	c 22 0; chmod 666 stdin
	mknod stdout	c 22 1; chmod 666 stdout
	mknod stderr	c 22 2; chmod 666 stderr
	mknod lkm	c 32 0;	chmod 644 lkm
	mknod pci	c 78 0; chmod 644 pci
	mkdir -p fd
	(cd fd && eval `echo "" | awk ' BEGIN { \
		for (i = 0; i < 64; i++) \
			printf("mknod %d c 22 %d;", i, i)}'`)
	chown -R bin.bin fd
	chmod 555 fd
	chmod 666 fd/*
	;;

mach-4)
	mknod iopl c 22 0
	mknod kbd c 23 0
	mknod mouse c 24 0
	mknod time c 25 0
	mknod timezone c 26 0
	;;

# Create device files for new Archive/Wangtek QIC-02 tape driver (vak)
wt*)
	umask $tape_umask
	u=`expr $i : '..\(.*\)'`
	if [ x$u = x ]; then u=0; fi
	mknod rwt${u}   c 10 `expr  0 + $u`	# default density, 512b blocks
	mknod nrwt${u}  c 10 `expr  4 + $u`
#	mknod rWt${u}   c 10 `expr 64 + $u`	# default density, 1024b blocks
#	mknod nrWt${u}  c 10 `expr 68 + $u`
	mknod rwt${u}b  c 10 `expr 16 + $u`	# 60 megabytes
	mknod nrwt${u}b c 10 `expr 20 + $u`
	mknod rwt${u}c  c 10 `expr 24 + $u`	# 120 megabytes
	mknod nrwt${u}c c 10 `expr 28 + $u`
	mknod rwt${u}d  c 10 `expr 32 + $u`	# 150 megabytes
	mknod nrwt${u}d c 10 `expr 36 + $u`
#	mknod rwt${u}e  c 10 `expr 40 + $u`	# 300 megabytes?
#	mknod nrwt${u}e c 10 `expr 44 + $u`
#	mknod rwt${u}f  c 10 `expr 48 + $u`	# 600 megabytes?
#	mknod nrwt${u}f c 10 `expr 52 + $u`
	chgrp operator r[Ww]t$u nr[Ww]t$u r[Ww]t$u[a-f] nr[Ww]t$u[a-f]
	umask 77
	;;

# Individual slices.
od*s*|sd*s*|vn*s*|wd*s*|wfd*s*)
	umask $disk_umask
	case $i in
	od*s*) name=od; blk=20; chr=70;;
	sd*s*) name=sd; blk=4;  chr=13;;
	wd*s*) name=wd; blk=0;  chr=3;;
	vn*s*) name=vn; blk=15; chr=43;;
	wfd*s*) name=wfd; blk=1; chr=87;;
	esac
	case $i in
	wfd*s*)
		unit=`expr $i : '...\([0-9]*\)s'`
		slice=`expr $i : '...[0-9]*s\([0-9]*\)'`
		part=`expr $i : '...[0-9]*s[0-9]*\(.*\)'`
		;;
	*)
		unit=`expr $i : '..\([0-9]*\)s'`
		slice=`expr $i : '..[0-9]*s\([0-9]*\)'`
		part=`expr $i : '..[0-9]*s[0-9]*\(.*\)'`
		;;
	esac
	case $unit in
	[0-9]|[0-9][0-9]|[0-4][0-9][0-9]|50[0-9]|51[0-1])
		case $slice in
		[0-9]|[1-2][0-9]|30)
			oldslice=$slice
			slice=$(($slice+1))
			slicename=`dkitos $slice`
			minor=`dkminor 0 $unit $slice $dkrawpart`
			mknod  $name$unit$slicename b $blk $minor
			mknod r$name$unit$slicename c $chr $minor
			case $part in
			[a-h])
				case $oldslice in
				0) slice=$oldslice ;;
				esac
				for part in 0 1 2 3 4 5 6 7
				do
					minor=`dkminor 0 $unit $slice $part`
					partname=`dkitop $part`
					mknod  $name$unit$slicename$partname \
					      b $blk $minor
					mknod r$name$unit$slicename$partname \
					      c $chr $minor
				done
				;;
			"")
				;;
			*)
				echo bad partition for disk in: $i
				;;
			esac
			chgrp operator $name$unit$slicename* \
				      r$name$unit$slicename*
			;;
		*)
			echo bad slice for disk in: $i
			;;
		esac
		;;
	*)
		echo bad unit for disk in: $i "(unit=$unit, slice=$slice, part=$part)"
		;;
	esac
	umask 77
	;;

fd*)
	umask $disk_umask
	unit=`expr $i : '..\(.*\)'`
	name=fd; blk=2; chr=9
	case $unit in
	0|1|2|3)
		mknod ${name}${unit}   b $blk `expr $unit '*' 64`
		mknod r${name}${unit}  c $chr `expr $unit '*' 64`
		# Fake BSD partitions
		for i in a b c d e f g h
		do
			ln ${name}${unit} ${name}${unit}$i
			ln r${name}${unit} r${name}${unit}$i
		done
		# User-readable and programmer-readable name sets

		mknod ${name}${unit}.1720  b $blk `expr $unit '*' 64 + 1`
		mknod r${name}${unit}.1720 c $chr `expr $unit '*' 64 + 1`
		# ln ${name}${unit}.1720 ${name}${unit}135hs21
		# ln r${name}${unit}.1720 r${name}${unit}135hs21

		mknod ${name}${unit}.1480  b $blk `expr $unit '*' 64 + 2`
		mknod r${name}${unit}.1480 c $chr `expr $unit '*' 64 + 2`
		# ln ${name}${unit}.1480 ${name}${unit}135hs18
		# ln r${name}${unit}.1480 r${name}${unit}135hs18
		# ln ${name}${unit}.1480 ${name}${unit}96hs18
		# ln r${name}${unit}.1480 r${name}${unit}96hs18

		mknod ${name}${unit}.1440  b $blk `expr $unit '*' 64 + 3`
		mknod r${name}${unit}.1440 c $chr `expr $unit '*' 64 + 3`
		# ln ${name}${unit}.1440 ${name}${unit}135
		# ln r${name}${unit}.1440 r${name}${unit}135
		# ln ${name}${unit}.1440 ${name}${unit}135ds18
		# ln r${name}${unit}.1440 r${name}${unit}135ds18
		# ln ${name}${unit}.1440 ${name}${unit}96ds18
		# ln r${name}${unit}.1440 r${name}${unit}96ds18

		mknod ${name}${unit}.1200  b $blk `expr $unit '*' 64 + 4`
		mknod r${name}${unit}.1200 c $chr `expr $unit '*' 64 + 4`
		# ln ${name}${unit}.1200 ${name}${unit}96
		# ln r${name}${unit}.1200 r${name}${unit}96
		# ln ${name}${unit}.1200 ${name}${unit}96ds15
		# ln r${name}${unit}.1200 r${name}${unit}96ds15
		# ln ${name}${unit}.1200 ${name}${unit}135ds15
		# ln r${name}${unit}.1200 r${name}${unit}135ds15

		mknod ${name}${unit}.820  b $blk `expr $unit '*' 64 + 5`
		mknod r${name}${unit}.820 c $chr `expr $unit '*' 64 + 5`
		# ln ${name}${unit}.820 ${name}${unit}96hs10
		# ln r${name}${unit}.820 r${name}${unit}96hs10
		# ln ${name}${unit}.820 ${name}${unit}135hs10
		# ln r${name}${unit}.820 r${name}${unit}135hs10

		mknod ${name}${unit}.800  b $blk `expr $unit '*' 64 + 6`
		mknod r${name}${unit}.800 c $chr `expr $unit '*' 64 + 6`
		# ln ${name}${unit}.800 ${name}${unit}96ds10
		# ln r${name}${unit}.800 r${name}${unit}96ds10
		# ln ${name}${unit}.800 ${name}${unit}135ds10
		# ln r${name}${unit}.800 r${name}${unit}135ds10

		mknod ${name}${unit}.720  b $blk `expr $unit '*' 64 + 7`
		mknod r${name}${unit}.720 c $chr `expr $unit '*' 64 + 7`
		# ln ${name}${unit}.720 ${name}${unit}96ds9
		# ln r${name}${unit}.720 r${name}${unit}96ds9
		# ln ${name}${unit}.720 ${name}${unit}135ds9
		# ln r${name}${unit}.720 r${name}${unit}135ds9

		mknod ${name}${unit}.360  b $blk `expr $unit '*' 64 + 8`
		mknod r${name}${unit}.360 c $chr `expr $unit '*' 64 + 8`
		# ln ${name}${unit}.360 ${name}${unit}48
		# ln r${name}${unit}.360 r${name}${unit}48
		# ln ${name}${unit}.360 ${name}${unit}48ds9
		# ln r${name}${unit}.360 r${name}${unit}48ds9

		chgrp operator ${name}${unit}* r${name}${unit}*
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

ft*)
	umask $tape_umask
	unit=`expr $i : '..\(.*\)'`
	name=ft; blk=2; chr=9
	case $unit in
	0|1|2|3)
		mknod ${name}${unit}   b $blk `expr $unit '*' 64 + 32`
		mknod r${name}${unit}  c $chr `expr $unit '*' 64 + 32`
		ln ${name}${unit} ${name}${unit}a
		ln r${name}${unit} r${name}${unit}a
		chgrp operator ${name}${unit}* r${name}${unit}*
		;;
	*)
		echo bad unit for tape in: $i
		;;
	esac
	umask 77
	;;

od*|sd*|vn*|wd*|wfd*)
	umask $disk_umask
	case $i in
	od*) name=od; blk=20; chr=70;;
	sd*) name=sd; blk=4;  chr=13;;
	vn*) name=vn; blk=15; chr=43;;
	wd*) name=wd; blk=0;  chr=3;;
	wfd*) name=wfd; blk=1; chr=87;;
	esac
	case $i in
	wfd*)
		unit=`expr $i : '...\(.*\)'`
		;;
	*)
		unit=`expr $i : '..\(.*\)'`
		;;
	esac
	case $unit in
	[0-9]|[0-9][0-9]|[0-4][0-9][0-9]|50[0-9]|51[0-1])
		for slicepartname in s0h s1 s2 s3 s4
		do
			sh MAKEDEV $name$unit$slicepartname
		done
		case $name in
		od|sd)
			minor=`dkminor 0 $unit 0 0`
			mknod r${name}${unit}.ctl c $chr $(($minor | $scsictl))
			chmod 600 r${name}${unit}.ctl
			;;
		esac
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

ccd*)
	umask $disk_umask
	name=ccd
	blk=21; chr=74
	unit=`expr $i : '...\(.*\)'`
	case $unit in
	[0-9]|[0-9][0-9]|[0-4][0-9][0-9]|50[0-9]|51[0-1])
		for part in 0 1 2 3 4 5 6 7
		do
			minor=`dkminor 0 $unit 0 $part` 
			partname=`dkitop $part`
			mknod  $name$unit$partname b $blk $minor
			mknod r$name$unit$partname c $chr $minor
		done
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

ssc*)
	mknod ssc c 49 0
	;;

uk*)
	unit=`expr $i : 'uk\(.*\)'`
	mknod uk$unit c 31 $unit
	;;

worm*)
	umask $disk_umask
	unit=`expr $i : 'worm\(.*\)'`
	if [ "X${unit}" = "X" ]; then
		unit=0
	fi
	chr=62
	blk=23
	name=worm
	mknod ${name}${unit} b $blk ${unit}
	mknod r${name}${unit} c $chr ${unit}
	chgrp operator ${name}${unit} r${name}${unit}
	umask 077
	mknod r${name}${unit}.ctl c $chr `expr $unit + $scsictl `
	;;

# SCSI processor type driver
pt[0-9]*)
	chr=61
	name=pt
	unit=`expr $i : 'pt\([0-9][0-9]*\)'`
	if [ "X${unit}" = "X" ]; then
		unit=0
	fi
	unit=`expr $unit + 1 - 1`
	mknod ${name}${unit} c $chr $unit
	mknod ${name}${unit}.ctl c $chr `expr $unit + $scsictl `
	;;

pty*)
	class=`expr $i : 'pty\(.*\)'`
	case $class in
	0) offset=0 name=p;;
	1) offset=32 name=q;;
	2) offset=64 name=r;;
	3) offset=96 name=s;;
# Note that xterm (at least) only look at p-s.
	4) offset=128 name=P;;
	5) offset=160 name=Q;;
	6) offset=192 name=R;;
	7) offset=224 name=S;;
	# This still leaves [tuTU].
	*) echo bad unit for pty in: $i;;
	esac
	case $class in
	0|1|2|3|4|5|6|7)
		umask 0
		eval `echo $offset $name | awk ' { b=$1; n=$2 } END { \
			for (i = 0; i < 32; i++) {
				c = substr("0123456789abcdefghijklmnopqrstuv", i + 1, 1); \
				printf("mknod tty%s%s c 5 %d; \
					mknod pty%s%s c 6 %d;", \
					n, c, b+i, \
					n, c, b+i); \
			} \
		}'`
		umask 77
		;;
	esac
	;;

st*)
	umask $tape_umask
	unit=`expr $i : '..\(.*\)'`
	chr=14

	case $unit in
	0|1|2|3|4|5|6)
		for mode in 0 1 2 3
		do
			mknod rst${unit}.${mode} c $chr `expr $unit '*' 16 + $mode '*' 4 + 0`
			mknod nrst${unit}.${mode} c $chr `expr $unit '*' 16 + $mode '*' 4 + 1`
			mknod erst${unit}.${mode} c $chr `expr $unit '*' 16 + $mode '*' 4 + 2`
			mknod st${unit}ctl.${mode} c $chr `expr $unit '*' 16 + $mode '*' 4 + 3`
			chgrp operator	rst${unit}.${mode}\
					nrst${unit}.${mode} \
					erst${unit}.${mode} \
					st${unit}ctl.${mode}
			chmod 600	st${unit}ctl.${mode}
		done
		mknod rst${unit}.ctl c $chr `expr $unit '*' 16 + $scsictl `
		chmod 600 rst${unit}.ctl

		ln rst${unit}.0 rst${unit}
		ln nrst${unit}.0 nrst${unit}
		ln erst${unit}.0 erst${unit}
		;;
	*)
		echo bad unit for tape in: $i
		;;
	esac
	umask 77
	;;

ch*)
	umask 37
	unit=`expr $i : '..\(.*\)'`
	case $i in
	ch*) name=ch;  chr=17;;
	esac
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}	c $chr `expr $unit '*' 16 + 0`
		chgrp operator ${name}${unit}
		mknod r${name}${unit}.ctl c $chr `expr $unit '*' 16 + $scsictl `
		chmod 600 r${name}${unit}.ctl
		;;
	*)
		echo bad unit for media changer in: $i
		;;
	esac
	umask 77
	;;

cd*|mcd*|scd*)
	umask $disk_umask
	case $i in
	cd*) unit=`expr $i : '..\(.*\)'`; name=cd; blk=6; chr=15;;
	mcd*) unit=`expr $i : '...\(.*\)'`; name=mcd; blk=7; chr=29;;
	scd*) unit=`expr $i : '...\(.*\)'`; name=scd; blk=16; chr=45;;
	esac
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 8 + 2`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + 2`
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		case $name in
		cd)
			mknod r${name}${unit}.ctl c $chr `expr $unit '*' 8 + $scsictl `
			chmod 600 r${name}${unit}.ctl
			;;
		esac
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

matcd*)
	umask 2
	case $i in
	matcd*) unit=`expr $i : '.....\(.*\)'`; name=matcd; blk=17; chr=46;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15)
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}c   b $blk `expr $unit '*' 8 + 2`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}c  c $chr `expr $unit '*' 8 + 2`
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]

		mknod ${name}${unit}la  b $blk `expr $unit '*' 8 + 128`
		mknod ${name}${unit}lc  b $blk `expr $unit '*' 8 + 130`
		mknod r${name}${unit}la c $chr `expr $unit '*' 8 + 128`
		mknod r${name}${unit}lc c $chr `expr $unit '*' 8 + 130`
		chgrp operator ${name}${unit}l[a-h] r${name}${unit}l[a-h]
		chmod 640 ${name}${unit}l[a-h] r${name}${unit}l[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

wcd*)
	umask 2 ;
	unit=`expr $i : '...\(.*\)'`
	blk=19
	chr=69
	case $unit in
	0|1|2|3)
		mknod wcd${unit}a  b $blk `expr $unit '*' 8 + 0`
		mknod rwcd${unit}a c $chr `expr $unit '*' 8 + 0`
		mknod wcd${unit}c  b $blk `expr $unit '*' 8 + 2`
		mknod rwcd${unit}c c $chr `expr $unit '*' 8 + 2`
		chgrp operator wcd${unit}[a-h] rwcd${unit}[a-h]
		chmod 640 wcd${unit}[a-h] rwcd${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

lpt*)
	unit=`expr $i : 'lpt\(.*\)'`
	mknod lpt$unit c 16 $unit
	mknod lpctl$unit c 16 `expr $unit + 128`
	;;

tw*)
	unit=`expr $i : 'tw\(.*\)'`
	mknod tw$unit c 19 $unit
	chgrp operator tw$unit
	;;

# Use this to create virtual consoles for syscons, pcvt or codrv
# ttyv0-b
# use as MAKEDEV vtyNN to create NN entries
vty*)
	chr=12
	units=`expr $i : 'vty\(.*\)'`
	eval `echo ${chr} ${units} | awk ' { c=$1; n=$2 } END {
		for (i = 0; i < n; i++)
			printf("mknod ttyv%01x c %d %d;", i, c, i); }'`
	ln -fs ttyv0 vga	# XXX X still needs this pccons relic
	;;

bpf*)
	unit=`expr $i : 'bpf\(.*\)'`
	mknod bpf$unit c 23 $unit
	;;

speaker)
	mknod speaker c 26 0
	;;

cuaa?|cua?)
	umask 7
	unit=`expr $i : 'cua.*\(.\)$'`
	m=`ttyminor $unit`
	mknod cuaa$unit c 28 `expr $m + 128`
	mknod cuaia$unit c 28 `expr $m + 32 + 128`
	mknod cuala$unit c 28 `expr $m + 64 + 128`
	chown uucp.dialer cua*a$unit
	umask 77
	;;

tty0?|ttyd?|tty?)
	unit=`expr $i : 'tty.*\(.\)$'`
	m=`ttyminor $unit`
	mknod ttyd$unit c 28 $m
	mknod ttyid$unit c 28 `expr $m + 32`
	mknod ttyld$unit c 28 `expr $m + 64`
	;;

cuac?)
	umask 7
	portlist="0 1 2 3 4 5 6 7 8 9 a b c d e f
		  g h i j k l m n o p q r s t u v"
	major=48
	card=`expr $i : 'cua.*\(.\)$'`
	for unit in $portlist
	do
		minor=`ttyminor $unit`
		minor=`expr $card \* 65536 + $minor`
		name=$card$unit
		mknod cuac$name c $major `expr $minor + 128`
		mknod cuaic$name c $major `expr $minor + 32 + 128`
		mknod cualc$name c $major `expr $minor + 64 + 128`
		chown uucp.dialer cuac$name cuaic$name cualc$name
	done
	umask 77
	;;

ttyc?)
	portlist="0 1 2 3 4 5 6 7 8 9 a b c d e f
		  g h i j k l m n o p q r s t u v"
	major=48
	card=`expr $i : 'tty.*\(.\)$'`
	for unit in $portlist
	do
		minor=`ttyminor $unit`
		minor=`expr $card \* 65536 + $minor`
		name=$card$unit
		mknod ttyc$name c $major $minor
		mknod ttyic$name c $major `expr $minor + 32`
		mknod ttylc$name c $major `expr $minor + 64`
	done
	;;

# RISCom8 'rc' driver entries

cuam?)
	umask 7
	unit=`expr $i : 'cua.*\(.\)$'`
	m=`ttyminor $unit`
	mknod cuam$unit c 63 `expr $m + 128`
	chown uucp.dialer cuam$unit
	umask 77
	;;

ttym?)
	unit=`expr $i : 'tty.*\(.\)$'`
	m=`ttyminor $unit`
	mknod ttym$unit c 63 $m
	;;

# Specialix SI/XIO.
# Note: these are 'base 1' to match the numbers on the panels, and to match
#       the manual that comes with the system.
ttyA*)
	major=68
	nports=`expr $i : 'ttyA\(.*\)$'`
	port=1
	while [ $port -le $nports ]; do
		minor=`expr $port - 1`
		name=`expr $port + 1000 | cut -c 3-4` 
		mknod ttyA$name c $major $minor
		mknod ttyiA$name c $major `expr $minor + 65536`
		mknod ttylA$name c $major `expr $minor + 131072`
		port=`expr $port + 1`
	done
	# For the user-mode control program, 'sicontrol'
	mknod si_control c 68 262144
	;;

cuaA*)
	umask 7
	major=68
	nports=`expr $i : 'cuaA\(.*\)$'`
	port=1
	while [ $port -le $nports ]; do
		minor=`expr $port - 1`
		name=`expr $port + 1000 | cut -c 3-4` 
		mknod cuaA$name c $major `expr $minor + 128`
		mknod cuaiA$name c $major `expr $minor + 128 + 65536`
		mknod cualA$name c $major `expr $minor + 128 + 131072`
		chown uucp.dialer cuaA$name cuaiA$name cualA$name
		port=`expr $port + 1`
	done
	umask 77
	;;

# Digiboard PC/?? 16 port card.
# The current scheme of minor numbering is:
#
#       unused{14} CARD{2} major{8} CALLOUT{1} LOCK{1} INIT{1} PORT{5}
#
#   CARD bitfield in future versions may be extended to 3 bits.
#
# See dgb(4)
#
ttyD?)
	portlist="0 1 2 3 4 5 6 7 8 9 a b c d e f"
	major=58
	card=`expr $i : 'tty.*\(.\)$'`
	for unit in $portlist
	do
		minor=`ttyminor $unit`
		minor=`expr $card \* 65536 + $minor`
		name=$card$unit
		mknod ttyD$name c $major $minor
		mknod ttyiD$name c $major `expr $minor + 32`
		mknod ttylD$name c $major `expr $minor + 64`
	done
	;;

cuaD?)
	umask 7
	portlist="0 1 2 3 4 5 6 7 8 9 a b c d e f"
	major=58
	card=`expr $i : 'cua.*\(.\)$'`
	for unit in $portlist
	do
		minor=`ttyminor $unit`
		minor=`expr $card \* 65536 + $minor`
		name=$card$unit
		mknod cuaD$name c $major `expr $minor + 128`
		mknod cuaiD$name c $major `expr $minor + 32 + 128`
		mknod cualD$name c $major `expr $minor + 64 + 128`
		chown uucp.dialer cua*D$name
	done
	umask 77
	;;

ttyR?)
	major=81
	BOARD=1; MINOR=65536; Rnum=0
	MINOR=`expr $BOARD \* 65536`
	dmesg | grep ^RocketPort[0-4] > /tmp/rp_list
	controllers=`awk '{print $1}' < /tmp/rp_list`
	rm -f /dev/ttyR*; rm -f /dev/ttyiR*; rm -f /dev/ttylR*
	for i in $controllers;do
 	   ndevices=`grep ^$i /tmp/rp_list | sed -e 's/.* \([0-9]*\) ports/\1/'`
	   echo -n "Creating $ndevices devices for $i: "
	   for dev in `jot $ndevices 0`;do
		   mknod /dev/ttyR$Rnum c $major $MINOR 
		   mknod /dev/ttylR$Rnum c $major `expr $MINOR + 32`
		   mknod /dev/ttyiR$Rnum c $major `expr $MINOR + 64` 
		   Rnum=`expr $Rnum + 1`
		   MINOR=`expr $MINOR + 1`
	   done
		BOARD=`expr $BOARD + 1`
		MINOR=`expr $BOARD \* 65536`
	   echo " "
	done
	;;

cuaR?)
	major=81
	BOARD=1; MINOR=65536; Rnum=0
	MINOR=`expr $BOARD \* 65536`
	dmesg | grep ^RocketPort[0-4] > /tmp/rp_list
	controllers=`awk '{print $1}' < /tmp/rp_list`
	rm -f /dev/cuaR*; rm -f /dev/cuaiR*; rm -f /dev/cualR*
	for i in $controllers;do
 	   ndevices=`grep ^$i /tmp/rp_list | sed -e 's/.* \([0-9]*\) ports/\1/'`
	   echo -n "Creating $ndevices devices for $i: "
	   for dev in `jot $ndevices 0`;do
		   mknod /dev/cuaR$Rnum c  $major `expr $MINOR + 128`
		   mknod /dev/cualR$Rnum c $major `expr $MINOR + 128 + 32`
		   mknod /dev/cuaiR$Rnum c $major `expr $MINOR + 128 + 64` 
		   Rnum=`expr $Rnum + 1`
		   MINOR=`expr $MINOR + 1`
	   done
		BOARD=`expr $BOARD + 1`
		MINOR=`expr $BOARD \* 65536`
	   echo " "
	done
	chown uucp.dialer /dev/cuaR*
	;;

mse*)
	unit=`expr $i : 'mse\(.*\)'`
	chr=27
	mknod mse$unit c $chr `expr $unit '*' 2 + 1`	# non-blocking for X11
	;;

psm*)
	unit=`expr $i : 'psm\(.*\)'`
	chr=21
	mknod psm$unit c $chr `expr $unit '*' 2 + 1`	# non-blocking for X11
	;;

mouse*)
	name=`expr $i : 'mouse\(.*\)'`
	if [ ! -c $name ]; then
		$0 $name			# make the appropriate device
	fi
	ln -fs $name mouse
	;;

pcaudio)
	mknod pcaudio c 24 0
	mknod pcaudioctl c 24 128
	;;

socksys)
	mknod socksys c 41 0
	mknod spx c 41 1
	ln -fs socksys nfsd
	chmod 666 socksys nfsd spx
	;;

snd*)
#
# changes from Linux voxware
# minor		Linux			FreeBSD
# 8		sequencer2 (aka music0)	music0
# 17		patmgr0			sequencer1
# 33		patmgr1			sequencer2
#

	unit=`expr $i : 'snd\(.*\)'`
	chr=30

	# XXX write this less verbosely, like std
	snd_security_hole=0	# XXX
	umask $snd_security_hole

	if [ $unit = "0" ] ; then
		ln -fs mixer$unit mixer
		ln -fs sequencer$unit sequencer
		ln -fs dsp$unit dsp
		ln -fs audio$unit audio
		ln -fs dspW$unit dspW
		ln -fs music$unit music
		ln -fs pss$unit pss
	fi

	mknod mixer$unit	c $chr `expr $unit '*' 16 + 0`
	mknod sequencer$unit	c $chr `expr $unit '*' 16 + 1`
	mknod midi$unit		c $chr `expr $unit '*' 16 + 2`
	mknod dsp$unit		c $chr `expr $unit '*' 16 + 3`
	mknod audio$unit	c $chr `expr $unit '*' 16 + 4`
	mknod dspW$unit		c $chr `expr $unit '*' 16 + 5`
	mknod sndstat		c $chr 6
				# minor number 7 is unused
	mknod music$unit	c $chr `expr $unit '*' 16 + 8`
	mknod pss$unit		c $chr `expr $unit '*' 16 + 9`
				# minor numbers 10-15 are unused
	umask 77
	;;

vat)
	mknod vatio c 25 128
	chmod 660 vatio
	;;

gsc*)
	unit=`expr $i : 'gsc\(.*\)'`
	mknod gsc${unit} c 47 $unit
	mknod gsc${unit}p c 47 $(($unit + 8))
	mknod gsc${unit}d c 47 $(($unit + 32))
	mknod gsc${unit}pd c 47 $(($unit + 40))
	chmod 666 gsc${unit}*
	;;

apm*)
	chr=39
	mknod apm c $chr 0
	chgrp operator apm
	chmod 660 apm
	;;

card*)
	unit=`expr $i : 'card\(.*\)'`
	chr=50
	mknod card$unit c $chr $unit
	chmod 644 card$unit
	;;

ttyx?|ttyy?|ttyz?)
	case $i in
	*0) unit=0;;	*1) unit=1;;	*2) unit=2;;	*3) unit=3;;
	*4) unit=4;;	*5) unit=5;;	*6) unit=6;;	*7) unit=7;;
	*8) unit=8;;	*9) unit=9;;	*a) unit=10;;	*b) unit=11;;
	*c) unit=12;;	*d) unit=13;;	*e) unit=14;;	*f) unit=15;;
	esac
	case $i in
	ttyy?)  unit=`expr $unit \+ 16`;;
	ttyz?)  unit=`expr $unit \+ 32`;;
	esac
	mknod $i c 42 $unit
	chown uucp.wheel $i
	;;

cronyx)
	mknod cronyx c 42 63
	;;

joy)
	mknod joy0 c 51 0
	mknod joy1 c 51 1
	chgrp operator joy0 joy1
	chmod 640  joy0 joy1
	;;

spigot)
	mknod spigot c 11 0
	chmod 444 spigot
	;;

ctx?)
	unit=`expr $i : 'ctx\(.*\)'`
	mknod ctx$unit c 40 $unit
	chmod 444 ctx$unit
	;;

meteor?)
	unit=`expr $i : 'meteor\(.*\)'`
	mknod meteor$unit c 67 $unit
	chmod 444 meteor$unit
	;;

bktr?)
	unit=`expr $i : 'bktr\(.*\)'`
	mknod bktr$unit c 92 $unit
	mknod tuner$unit c 92 $((16 + $unit ))
	chmod 444 bktr$unit tuner$unit
	;;

tun*)
	ntun=`expr $i : 'tun\(.*\)$'`
	unit=0
	while [ $unit -le $ntun ]; do
		mknod tun$unit c 52 $unit
		chown uucp.dialer tun$unit
		unit=`expr $unit + 1`
	done
	;;

sysmouse)
	mknod sysmouse c 12 128
	mknod consolectl c 12 255
	;;

snp?)
	unit=`expr $i : 'snp\(.*\)'`
	mknod snp$unit c 53 $unit
	;;

# dufault@hda.com: If I do much more work on other A-D boards
# then eventually we'll have a "ad" and "dio" interface and some of these
# "labpcaio" ones will be gone.
# labpcaio: D-A and A-D.
# labpcdio: Digital in and Digital out.
#
labpc*)
	umask 7
	case $i in
	labpcaio*)
		name=labpcaio
		unit=`expr $i : 'labpcaio\(.*\)'`
		all="0 1 2 3 4 5 6 7"
		offset=0
		;;
	labpcdio*)
		name=labpcdio
		unit=`expr $i : 'labpcdio\(.*\)'`
		all="0 1 2 3"
		offset=8
		;;
	*)
		die 3 "Don't know LabPC type $i"
		;;
	esac
	if [ "X${unit}" = "X" ]; then
		unit=all
	fi
	case $unit in
		0|1|2|3|4|5|6|7)
				mknod $name$unit c 66 `expr $offset + $unit `
		;;
		all)
			for i in $all
			do
				mknod $name$i c 66 `expr $offset + $i `
			done
			;;
		*)
			echo "No such LabPC unit: $unit"
			;;
	esac
	umask 77
	;;

perfmon)
	mknod perfmon c 2 32
	chgrp kmem perfmon
	chmod 640 perfmon
	;;

ipl)
	mknod ipl c 79 0
	mknod ipnat c 79 1
	mknod ipstate c 79 2
	mknod ipauth c 79 3
	;;

local)
	umask 0			# XXX should be elsewhere
	sh MAKEDEV.local
	umask 77
	;;

*)
	echo $i - no such device name
	;;

esac
done
