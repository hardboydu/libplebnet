<!-- $Id$ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.4 -->

<!--
<!DOCTYPE linuxdoc PUBLIC "-//FreeBSD//DTD linuxdoc//EN" [

<!ENTITY % authors SYSTEM "authors.sgml">
%authors;

]>
-->
<sect2><heading>UART とは何か, そしてどのように動作するか <label id="uart"></heading>

<p><em>Copyright &copy; 1996 &a.uhclem;, All Rights Reserved.<newline>
13 January 1996.</em>
<p><em>訳: &a.saeki;, &a.iwasaki;.<newline>
11 November 1996.</em>

<!-- Version 1(2) 13-Jan-96 -->

<p>( ここからは &a.saeki; が翻訳を担当) 

	汎用非同期送受信コントローラ (UART) はコンピュータのシリアル通信
	サブシステムの鍵となる部品です. UART は何バイトかのデータを受けとり, 
	これを 1 ビットずつ順番に送信します. 受信側では, もう一つの UART が
	このビット列を完全なバイト列に組み立て直します. 

	シリアル転送は, モデムやコンピュータ間の非ネットワーク型の通信, 
	ターミナルその他のデバイスで広く使われています. 

	シリアル転送には主に同期と非同期という二つの形式があります: 
	通信サブシステムの名前は, そのハードウェアでサポートされている
	通信モードによって変化します. 
	通常, 非同期通信をサポートしているものは文字 "A" を含み, 
	同期通信をサポートしているものは文字 "S" を含みます. 
	以下で両方の形式について詳しく説明します. 

	通常使われている略号は以下の通りです:
<quote>UART	汎用非同期送受信装置 (Universal Asynchronous Receiver/Transmitter)</quote>
<quote>USART	汎用同期-非同期送受信装置 (Universal Synchronous-Asynchronous Receiver/Transmitter)</quote>


<sect3><heading> 同期シリアル転送 </heading>

	<p> 同期シリアル転送では, 送信側と受信側がクロックを共有している
	必要があります. さもなければ, 送信側がストローブまたは
	その他のタイミング信号を供給して, 受信側にデータの次のビットを 
	いつ「読み込」めばよいのかを知らせる必要があります. 

	ほとんどの同期シリアル通信では, 常に何らかのデータが転送され続けます. 
	そのため, 転送のタイミングまでに送信データが用意できていなければ, 
	通常のデータのかわりに「埋め草」 (fill character) が送られます. 
	同期通信では, 送信側と受信側との間でデータビットのみが転送されるため, 
	同じビット速度の非同期シリアル通信に比べて効率的です. 
	しかし, 送信側と受信側でクロック信号を共有するために余分な電線と
	回路が必要となる場合には, よりコスト高となる可能性があります. 

	プリンタやハードディスクでも同期転送の一種が使用されています. 
	このときデータが 1 組みの電線で送られる一方, クロック信号または
	ストローブ信号が別の電線で送られます. 
	プリンタやハードディスクは通常, シリアルデバイスではありません. 
	ほとんどのハードディスクのインターフェース規格では, データを送るための
	線とは別にクロックまたはストローブ信号を送るための線を持っていて, 
	ストローブ 1 回毎に一つのデータ全体を送ります. 
	PC 産業界では, これらはパラレルデバイスとして知られています. 

	PC の標準的なシリアル通信ハードウェアは, 同期モードをサポートして
	いません. ここで同期モードについて述べたのは, 非同期モードとの
	比較のために過ぎません. 


<sect3><heading> 非同期シリアル転送 </heading>

	<p> 非同期転送は, 送信側がクロック信号を受信側に送らなくても
	データを転送することができます. そのかわり, 送信側と受信側は
	あらかじめタイミングパラメータや同期のために追加される
	特別なビットについて取り決めをおこなっておかなければなりません. 

	非同期転送をおこなうために UART にデータが与えられると, 
	「スタートビット」と呼ばれるビットが転送データの先頭に追加されます. 
	スタートビットはデータの転送開始を受信側に知らせるために使われ, 
	これにより受信側のクロックを送信側のクロックに同期させます. 
	この二つのクロックは, 転送データの残りのビットを転送する間に
	10% 以上ふらつかないように正確なものでなければなりません. 
	(この条件は機械式テレタイプの時代に定められたものなので, 
	現代の電子装置であれば容易に満足させることができます). 

	スタートビットが送られた後, データの各ビットが最下位 (LSB) から
	順番に送られます. 転送されるビットの長さはすべて同じになっていて, 
	受信側はそれぞれのビットの中央部でそれが "1" か "0" かを判断します. 
	例えば, 仮に 1 ビットを送るのに 2 秒かかるとすると, 受信側は
	スタートビットの始まりを認識した 1 秒後に信号が "1" か "0" かを調べ, 
	その後 2 秒ごとに次のビットの値を調べるという動作を繰り返します. 

	送信側は, いつ受信側がビットの値を「見た」のかはわかりません. 
	送信側はクロックにしたがって次々にビットを転送するだけです. 

	設定によっては, 1 ワードのデータ全体が送られたあとに
	送信側が内部で生成したパリティビットを付加する場合があります. 
	パリティビットは受信側で簡単なエラーチェックをするために使われます. 
	その後に, 最低でも 1 ビットのストップビットが送られます. 

	1 ワードのすべてのビットを受信すると, 受信側がパリティビットの
	チェックをおこなうように設定することができます. (パリティビットを
	使用するかどうか, 送信側と受信側であらかじめ取り決めておかなければ
	なりません). それから受信側はストップビットをチェックします. 
	もしもストップビットが期待通りの位置に存在しなければ, UART は
	転送エラーが発生したと判断して, ホストがデータを読もうとした時に
	フレーミングエラーが起きたと報告します. 通常, フレーミングエラーは
	送信側と受信側のクロックが一致していなかったり, 信号に割り込みが
	入った時に起こります. 

	データが正しく受信されたかどうかにかかわらず, 
	UART はスタート, パリティ, ストップビットを自動的に捨てます. 
	送信側と受信側で設定が正しく一致していれば, これらのビットが
	誤ってホストに転送されることはありません. 

	1 回の転送が終了する前に次のデータの転送準備ができていれば, 
	前のデータのストップビットを送った後, 間を空けずに
	次のデータのスタートビットを送ることができます. 

	非同期転送データは「自己同期」なので, 転送するべきデータがない場合は
	転送路は空き状態になります. 


<sect3><heading>UART のその他の機能 </heading>

	<p> 転送のためにデータをパラレルからシリアルに変換し, 受信時に
	シリアルからパラレルに戻すという基本的な機能の他に, UART は通常, 
	転送路の状態を示したり, リモートデバイスで次のデータを受けとる準備が
	できていない場合にデータの流れを抑制するのに使われる信号のための
	付加回路も持っています. 
	例えば UART に接続されているデバイスがモデムの場合, モデムは
	回線上に搬送波 (carrier) が存在していることを報告するかもしれません. 
	一方, コンピュータはこれらの付加信号を操作することにより
	モデムのリセットをおこなったり, かかってきた電話を取らないように
	モデムに指示するかもしれません. 
	これらの付加信号の機能はそれぞれ EIA RE232-C 規格で定義されています. 

<sect3><heading>RS-232C と V.24 規格 </heading>

	<p> ほとんどのコンピュータシステムでは, UART は EIA RS-232C 規格に
	準拠した信号を生成するための回路に接続されています. 
	また, RS-232C の仕様を反映した, V.24 という CCITT 規格に
	準拠したシステムも存在しています. 

<sect4><heading>RS-232C のビット割り当て (マークとスペース) </heading>

	<p> RS-232C では, "1" の値を「マーク」, "0" の値を「スペース」と
	呼びます. 通信路にデータが流れていない時, 回線は「マーキング」
	であるとか, "1" の値を連続して転送し続けているとか言われます. 

	スタートビットは常に "0" (スペース) で, 
	ストップビットは常に "1" (マーク) です. 
	このことは, たとえ複数のデータが連続して転送されている場合でも, 
	それぞれのデータの転送開始時には必ず, マーク (1) から
	スペース (0) への遷移が回線上で起こるということを意味しています. 

	これによって, 転送されるデータビットの内容にかかわらず, 
	送信側と受信側のクロックを同期させることができるのです. 

	ストップビットとスタートビットの間の空き時間は, その通信路で
	1 ビットを転送するのに必要な時間の正確な倍数である必要はありません. 
	 (倍数にはゼロを含みます). しかし, ほとんどの UART では
	設計の単純化のために, 倍数になるように設計されています. 

	RS-232C では, 「マーク」信号 ("1") は -2V から -12V の間の電圧で, 
	「スペース」信号 ("0") は 0V から +12V の間の電圧で示されます. 
	送信部は +12V または -12V を送ることになっていて, 受信部では
	長いケーブルによるいくらかの電圧ロスを許容するように定められています. 
	(ポータブルコンピュータなどで使用されている) 低消費電力デバイスの
	送信部では しばしば +5V と -5V のみを使用していますが, 
	短いケーブルを使用するならば, これらの電圧も RS-232C 受信部の
	許容範囲に入っています. 


<sect4><heading>RS-232C のブレーク信号 </heading>

	<p>RS-232C は「ブレーク」と呼ばれる信号についても定めています. 
	これは (スタートビットもストップビットも無しで) 連続して
	スペースの値を送ることで発生されます. 
	データ回路に電流が流れていない場合は, 
	回線は「ブレーク」を送り続けているものと解釈されます. 

	「ブレーク」信号は完全な 1 バイトとスタート, ストップ, パリティ
	ビットを送るために必要な時間よりも長い間続かなければなりません. 
	ほとんどの UART はフレーミングエラーとブレークを区別することが
	できますが, もしも これを区別できない UART があった場合, 
	フレーミングエラーの検出をブレークの識別のために
	使用することができます. 

	テレタイプの時代には, 国中でおびただしい数のテレタイプが
	(ニュースサービスなどで) 電線で直列に接続されていました. 
	任意のテレタイプユニットは, 電流が流れないように一時的に回路を
	オープンにすることで「ブレーク」信号を発生させることができました. 
	これは, 他のテレタイプが情報を送信している間に, 緊急ニュースを
	送る必要のあるテレタイプが割り込みをかけるために使われました. 

	現在のシステムでは, ブレーク信号には二つのタイプがあります. 
	もしブレーク信号が 1.6 秒よりも長ければ, それは
	「モデムブレーク」であると解釈されます. 
	モデムがこの信号を検出すると, 通信を終了して電話を切ったり, 
	コマンドモードに入るようにプログラムされていることがあります. 
	もしブレーク信号が 1.6 秒よりも短ければ, それはデータブレークを
	示します. この信号に応答するのはリモートコンピュータの仕事です. 
	この形のブレークは, しばしば注意喚起または割り込みのための信号として
	使われ, ASCII の CONTROL-C 文字の代用とされることもあります. 

	マークとスペースは紙テープシステムでの「穴空き」と「穴無し」に
	相当しています. 

	ブレーク信号は, 紙テープまたはその他のバイト列から生成できない
	ことに注意してください. なぜならバイト列は常にスタートビットや
	ストップビットとともに送られるからです. 
	UART には通常, ホストプロセッサからの特別なコマンドにより
	連続したスペース信号を生成する能力があります. 

<sect4><heading>RS-232C の DTE デバイスおよび DCE デバイス </heading>

	<p>RS-232C 規格は二つのタイプの装置を定めています: 
	それはデータターミナル装置 (DTE) とデータキャリア装置 (DCE) です. 
	通常, DTE デバイスはターミナル (またはコンピュータ) で, DCE は
	モデムです. 電話回線を介した通信のもう一方の端である受信側のモデムも
	また DCE デバイスで, そのモデムに接続されているコンピュータは
	DTE デバイスです. DCE デバイスが信号を受け取るピンは DTE デバイスが
	信号を送るピンであり, また逆も同様です. 

	二つのデバイスがともに DTE であったり, ともに DCE であって, 
	モデムやそれに類似したメディア変換装置を介さずに接続する必要が
	ある場合, ヌルモデム (NULL modem) を使わなければなりません. 
	ヌルモデムはケーブルを電気的に再配列し, 一方のデバイスの送信出力が
	もう一方のデバイスの受信入力に接続され, その逆もまた同様に
	接続されるようにしてくれます. 
	同様の変換はすべての制御信号についておこなわれ, それぞれのデバイスが
	他方のデバイスからの DCE (または DTE) 信号を受けとれるようになります. 

	DTE デバイスと DCE デバイスで生成される信号の数は等しくありません. 
	DTE デバイスが DCE デバイスのために生成する信号の数は, 
	DTE デバイスが DCE デバイスから受けとる信号の数よりも
	少なくなっています. 

<sect4><heading>RS-232C のピン割当て </heading>

	<p>EIA の RS-232C 規格 (およびこれに相当する ITU の V.24 規格) は
	25 ピンのコネクタ (通常 DB25 が使われます) を要求し, 
	そのコネクタのほとんどのピンの使用目的を定義しています. 

	IBM PC および類似のシステムでは, RS-232C 信号のサブセットが
	9 ピンのコネクタ (DB9) で提供されています. 
	主に同期モードで使用される信号は PC のコネクタには含まれていませんが, 
	もともと この転送モードは IBM が IBM PC で使用することにした
	UART ではサポートされていません. 

	メーカーによっては RS-232C 用のコネクタに DB25 か DB9, 
	またはその両タイプのコネクタを使っている場合があります. 
	(IBM PC はパラレルプリンタインターフェースにも DB25 コネクタを
	使っているので, このことは しばしば混乱を引き起こします.) 

	以下は DB25 および DB9 コネクタにおける RS-232C 信号の割り当て表です. 

<verb>
DB25	DB9	EIA	CCITT	一般	信号源	説明
RS-232C	IBM PC	回路	回路	名称
端子	端子	符号	符号	

1	-	AA	101	PG/FG	---	保安用接地
2	3	BA	103	TD	DTE	送信データ
3	2	BB	104	RD	DCE	受信データ
4	7	CA	105	RTS	DTE	送信要求
5	8	CB	106	CTS	DCE	送信可
6	6	CC	107	DSR	DCE	データセットレディ
7	5	AV	102	SG/GND	---	信号用接地
8	1	CF	109	DCD/CD	DCE	受信キャリア検出
9	-	-	-	-	-	予約 (テスト用)
10	-	-	-	-	-	予約 (テスト用)
11	-	-	-	-	-	未割当て
12	-	CI	122	SRLSD	DCE	従局受信キャリア検出
13	-	SCB	121	SCTS	DCE	従局送信可
14	-	SBA	118	STD	DTE	従局送信データ
15	-	DB	114	TSET	DCE	送信信号エレメントタイミング
16	-	SBB	119	SRD	DCE	従局受信データ
17	-	DD	115	RSET	DCE	受信信号エレメントタイミング
18	-	-	141	LOOP	DTE	ローカルループバック
19	-	SCA	120	SRS	DTE	従局送信要求
20	4	CD	108.2	DTR	DTE	データ端末レディ
21	-	-	-	RDL	DTE	リモートデジタルループバック
22	9	CE	125	RI	DCE	被呼表示
23	-	CH	111	DSRS	DTE	データ信号速度選択
24	-	DA	113	TSET	DTE	送信信号エレメントタイミング
25	-	-	142	-	DCE	テストモード
</verb>


    <sect3><heading> ビット, ボー, そしてシンボル </heading>

	<p> ボーとは非同期通信における転送速度の単位です. 
	モデム通信技術の進歩により, 新しいデバイスのデータ速度を
	表記するにあたって, この用語が しばしば誤って使われるようになりました. 

	ボーレートは伝統的に, 通信路を通して実際に送られるビットの数を
	表します. ある DTE デバイスからもう一方へと実際に移動した
	データの量を表すものではありません. 
	ボーレートは, 送信側 UART で生成されて受信側 UART で取り除かれる
	スタート, ストップ, パリティといったオーバーヘッドビットをも
	含んでいます. 
	これは 1 ワード 7 ビットのデータを送るためには, 実際には 10 ビットの
	データが完全に転送される必要があるということを意味します. 
	そのため, もしパリティを使い, スタートビットとストップビットが
	それぞれ 1 ビットずつ存在する場合には, 1 秒あたり 300 ビットの
	転送能力を持つモデムでは, 7 ビットのワードを通常 30 個しか
	転送することができません. 

	もし 1 ワード 8 ビットのデータとパリティビットを使用する場合には, 
	データ転送速度は 1 秒あたり 27.27 ワードまで低下します. 
	なぜなら 8 ビットのワードを送るのに 11 ビットが必要で, 
	このモデムは 1 秒間に 300 ビットしか送ることができないからです. 

	1 秒あたりの転送バイト数をボーレートに変換したり, その逆をおこなう
	計算式は, エラー訂正をおこなうモデムが現れるまでは単純でした. 
	エラー訂正をおこなうモデムは, ホストコンピュータの UART から
	シリアルのビット列を受けとり, それをバイト列に戻します. 
	(内蔵モデムを使用している場合でさえ, データは今まで通り
	頻繁にシリアル化されます) 
	その後これらのバイトはパケットに変換され, 同期転送方式を用いて
	電話回線を通じて送信されます. 
	これは DTE (コンピュータ) 中の UART で追加されたストップ, スタート
	およびパリティビットは, モデムから送り出される前に, モデムによって
	取り除かれるということを意味します. 
	これらのバイト列がリモートモデムに受信されると, リモートモデムは
	スタート, ストップおよびパリティビットを追加して, それらを
	シリアル形式に変換し, リモートコンピュータの受信側 UART に送ります. 
	そしてリモートコンピュータの UART はスタート, ストップおよび
	パリティビットを取り除きます. 

	これらの特別な変換はすべて, 二つのモデムの間でエラー訂正が
	実行できるようにするためおこなわれています. 
	エラー訂正とは, 受信側のモデムが正しいチェックサムで
	受信できなかったデータブロックの再送を, 
	送信側のモデムに要求することができるということです. 
	この作業はモデムにより処理されて, DTE デバイスは
	このようなプロセスがおこなわれていることに, 通常気がつきません. 

	スタート, ストップおよびパリティビットを取り除くことにより, 
	エラー訂正のために二つのモデムの間で共有しなければならない
	追加のビットを, 実効転送速度を低下させずに送ることができます. 
	そのため, 送受信 DTE にはエラー訂正がおこなわれているかどうかが
	ほとんど見えなくなります. 
	例えば, もしモデムが 10 個の 7 ビットデータをもう一方のモデムに送る
	際に, スタート, ストップ, およびパリティビットを送る必要がなければ, 
	その分の 30 ビットの情報を, 真のデータの転送速度に影響を与えることなく
	エラー訂正のために追加することができるわけです. 

	データ圧縮をおこなうモデムでは, ボーという言葉の使い方は
	さらに混乱することになります. 
	例えば電話回線を通じて送られた二つの 8 ビットデータは, 
	送信側モデムに送られた 12 バイトのデータを表すかもしれません. 
	受信側モデムはそのデータを本来の内容に展開し, 受信側の DTE に渡します. 

	また, 最近のモデムはバッファを内蔵しており, (DCE から DCE へ) 電話線を
	流れるデータの転送速度と, 両端の DTE と DCE の間で流れるデータの
	転送速度とを別々に設定することができます. 
	モデムによる圧縮を使用する場合, 通常は DTE と DCE の間の速度を
	DCE と DCE の間の速度より速くしておきます. 

	1 バイトを記述するのに必要なビットの数は, 二つのマシンの間でも
	DTE-DCE と DCE-DCE のリンクでそれぞれ変化する場合がありますし, 
	そのうえ, それぞれのビット転送速度が異なる場合もあります. そのため, 
	全体としての通信速度を表現するためにボーという言葉を使うことは
	問題でもありますし, 真の転送速度を正しく伝えない場合があります. 
	1 秒あたりの転送ビット数 (bps) は DCE と DCE の間のインターフェースに
	おける転送速度を記述するために使うなら正しい用語ですし, 
	ボーまたは 1 秒あたりのビット数は, 二つのシステムが電線で直接
	接続されていたり, エラー訂正や圧縮をおこなわないモデムが
	使われている場合には, 許容可能な用語です. 

	最近の高速モデム (2400, 9600, 14,400, 19,200bps などのもの) も, 
	実際には 2,400 ボー (正確には 2,400 シンボル/秒) か, それ以下の
	速度で通信しています. 高速モデムでは, 複数のビットを一つのシンボルで
	伝送する技術 (多値符合化など) を用いて, シンボル速度 (シンボル/秒) よりも
	高い通信速度 (ビット/秒) を達成しています. 
	これが電話の限られた音声帯域で高い伝送速度を得られる理由です. 
	28,800bps やそれ以上のモデムでは, シンボル速度自体が
	可変になっていますが, それ以外は同様の技術が用いられています. 

    <sect3><heading>IBM PC の UART</heading>

	<p> 元祖 IBM PC を設計した際に, IBM はナショナル・セミコンダクタ社の
	INS8250 UART を IBM PC パラレル/シリアルアダプタで使用することに
	決めました. 

	IBM 自身やその他のベンダが作っている後継世代の AT 互換機でも, 
	INS8250 そのものやナショナル・セミコンダクタの UART ファミリの
	改良版を使い続けられています. 

<sect4><heading> ナショナル・セミコンダクタの UART ファミリ系統図 </heading>

	<p>INS8250 UART にはいくつかのバージョンと後継の部品があります. 
	主要なバージョンを以下に示します. 

<verb>
	INS8250  -> INS8250B 
	    \
              \
	        \-> INS8250A -> INS82C50A 
		        \
          	          \
		            \-> NS16450 -> NS16C450
				   \
			             \
				       \-> NS16550 -> NS16550A -> PC16550D
</verb>

<descrip>
	<tag>INS8250</tag> この部品は元祖 IBM PC と IBM PC/XT で
	使われていました. 
	この部品は本来 INS8250 ACE (Asynchronous Communications Element) と
	いう名前で, NMOS 技術で作られていました. 

	8250 は八つの I/O ポートを占有し, 送信バッファ 1 バイトと
	受信バッファ 1 バイトを持っています. この元祖の UART はいくつかの
	競合状態などに関する欠陥を持っています. 
	元祖の IBM BIOS はこれらの欠陥を回避してうまく動くようなコードを
	含んでいましたが, そのために BIOS が欠陥の存在に依存するように
	なってしまいました. このため, 元祖 IBM PC や IBM PC/XT では
	8250A, 16450, または 16550 のような後継部品を使うことは
	できませんでした. 

	<tag>INS8250-B</tag> これは NMOS 技術で作られた INS8250 の低速版です. 
	これもオリジナルの INS8250 と同じ問題を含んでいます. 
	
	<tag>INS8250A</tag> XMOS 技術を使い, さまざまな機能的欠陥を修正した
	INS8250 の改良版です. INS8250A は当初, 「クリーン」な BIOS を
	使用したベンダの PC クローンで使用されていました. 
	なぜなら欠陥が修正されたことにより, この部品は INS8250 や INS8250B の
	ために書かれた BIOS で使うことはできなかったからです. 

	<tag>INS82C50A</tag> これは INS8250A の CMOS 版 (低消費電力版) で, 
	INS8250A と同じ機能特性を持っています. 

	<tag>NS16450</tag> より高速な CPU バスにも対応できるように
	改良されたこと以外は NS8250A と同じです. 
	IBM はこの部品を IBM AT で使うことに決め, もはや IBM BIOS が
	INS8250 のバグに依存しなくなるように変更をおこないました. 

	<tag>NS16C450</tag> これは NS16450 の CMOS 版 (低消費電力版) です. 

	<tag>NS16550</tag> 送信バッファと受信バッファをそれぞれ 16 バイトに
	変更したこと以外は NS16450 と同じですが, バッファの設計に
	欠陥があるため, 信頼して使用することはできません. 

	<tag>NS16550A</tag> バッファの欠陥が修正されたこと以外は NS16550 と
	同じです. 割り込みへの反応が遅い OS でも高い信頼性で高速なデータを
	扱うことができることから, 16550A とその後継部品は PC 産業界で
	最も一般的に使われる UART となりました. 

	<tag>NS16C552</tag> これは 2 個の NS16C550A CMOS UARTを
	一つのパッケージに入れた部品です. 

	<tag>PC16550D</tag> ささいな欠陥が修正されたこと以外は NS16550A と
	同じです. これは 16550 ファミリの D リビジョンで, 
	ナショナル・セミコンダクタ社から提供されている最新の部品です. 
</descrip>

<sect4><heading>NS16550AFとPC16550Dは同じもの</heading>
<p>( ここからは &a.iwasaki; が翻訳を担当)

	<p>ナショナル・セミコンダクタは数年前に部品番号体系を再編成して
	おり, NS16550AFN という名称はもはや存在しません. (もしあなたが 
	NS16550AFN を持っていたら, 部品の日付コードを見てください. それは
	通常 9 から始まる4桁の数字です. 最初の2桁の数字は年度, 次の2桁
	は部品がパッケージされた年度の週です. あなたの持っている 
	NS16550AFN は, おそらく数年前のものでしょう.)

	新しい番号は PC16550DV の様に, パッケージ材料と形状により接尾辞
	に小さな違いがあります (番号体系についての記述は後述します). 

	ここで注意しなければいけないことがあります. 例えば, ある店に行って
	1990年製の NS16550AFN を15米ドルで売っているとします. ところが, 
	そのすぐ隣には ナショナル・セミコンダクタが AFN を生産開始してから
	それにマイナーな変更を加えて作った PC16550DN があり, そちらは
	最近 6ヶ月に作られたものなのに, 簡単に入手できるため NS16550AFN の
	半額 (たくさん一度に買うと 5米ドルまで下がることもあります) 位で
	買えたりすることがあるのです. 

	NS16550AFN のチップ供給は減少し続けているため, PC16550DN が古い
	部品番号のものとまったく同じ機能を持っていることに, より多くの人が
	気付いて受け入れるまでは, 価格はおそらく上昇し続けるでしょう. 

<sect4><heading>ナショナル・セミコンダクタの部品番号体系</heading>

	<p> 古い NS<em>nnnnnrqp</em> の部品番号は, 現在 
	PC<em>nnnnnrgp</em> というフォーマットになっています. 

	「<em>r</em>」はリビジョンのフィールドです. 現在のナショナルセ
	ミコンダクタの 16550 のリビジョンは「D」です. 
	
	「<em>p</em>」はパッケージタイプのフィールドです. タイプは以下
	の通りです:
<verb>	"F"	QFP	(quad flat pack) L lead type
	"N"	DIP	(dual inline package) through hole straight lead type
	"V"	LPCC	(lead plastic chip carrier) J lead type</verb>

	<p>訳注: 具体的なパッケージ形状についての情報は <htmlurl
	url="http://www.national.com/packaging/plastic.html"
	name="http://www.national.com/packaging/plastic.html" >を参照
	してください. 

	「<em>g</em>」は製品グレードのフィールドです. もしパッケージタイ
	プの文字の前に「I」があれば, 「工業用」グレード部品を表し, 標準
	部品より高いスペックを持ちますが, Miltary 仕様 (Milspec) ほど高
	くはありません. これは付加的なフィールドです. 

	私たちがかつて NS16550AFN (DIP パッケージ) と呼んでいたものは, 現在
	は PC16550DN または PC16550DIN と呼ばれています. 

    <sect3><heading>他のベンダと類似の UART</heading>

	<p>長年に渡り, 8250, 8250A, 16450 そして 16550 はライセンスされ, 
	または他のチップベンダにコピーされてきました. 8250, 8250A そして 
	16450 の場合は, そのものの回路 (「megacell」: LSIの中に組み込む
	ことのできるライブラリ化された回路の大規模な物) が Western
	Digital と Intel を含むたくさんのベンダにライセンスされまし
	た. 他のベンダは部品をリバースエンジニアリングした物か同じように
	動作する互換品を製造しました. 

	内蔵モデムにおいては, モデム設計者はモデムのマイクロプロセッサで 
	8250A/16450 をエミュレートすることはよくおこなわれます. このエミュレート
	による (互換の) UART は数百バイトの隠れたバッファを持つでしょう. 
	バッファのサイズのため, このような互換品は高速データ処理の能力では 
	16550A と変わらない信頼性を持つことができます. しかし, それでも
	ほとんどのオペレーティングシステムは UART は 8250A か 16450 である
	と報告し, 特殊なドライバが使用されなければ エミュレートによる UART 
	の余分に存在するバッファリングの効果的な使用はおこないません. 

	幾つかのモデムメーカーは, 市場における競争を有利にするために数百バ
	イトのバッファを持ち 16550A の置き換えができるはずの設計を, たとえ
	性能が低下する事になったとしても棄てざるを得なくなるような市場の圧
	力を受けています. 

	一般的にある誤解は, 「16550A」と書かれたすべての部品が同じ性能であると
	いうことです. それらは異なるものであり, 状況によってはまちがいなく
	欠陥と呼べるものがこれらの 16550A クローンのほとんどにあります. 

	NS16550 が開発された時に, ナショナル・セミコンダクタは設計に関する
	幾つかの特許を取得し, 彼らはライセンスを制限して他のベンダが類似
	の特徴を持つチップを供給することを困難にしました. 特許のため, リバー
	スエンジニアリングによる設計とエミュレーションは, 特許がカバーする
	請求権を侵害を回避しなくてはなりませんでした. 結果として, これらの
	コピーのほとんどは, 多くのコンピュータとモデムのメーカーは支払いた
	くはない程の価格であった本物の部品の NS16550A または PC16550D とまった
	く同じような動作をさせることはできませんでした. 

	16550A のクローン部品ののいくつかの相違点は, その相違点を除いた点だ
	けがオペレーティングシステムやドライバで使われるのであれば重要では
	ありません. これらの相違点は他のドライバを使用している時または, 良
	くテストされなかったとか Windows ドライバで考慮されなかった実際の
	イベントの組み合せが発生した時に出てくるでしょう. 
	これはほとんどのモデムベンダと 16550 クローンメーカーが, NS16550A 
	との互換性のプライマリテストとして Windows for Workgroups 3.11 と 
	Microsoft MSD ユーティリティの Microsoft ドライバを使用しているか
	らです. この安易過ぎる規準は, もし異なるオペレーティングシステムが
	使用されたらクローンと本物の部品の微妙な違いのために問題が発生し得
	る, ということを意味しています. 

	ナショナル・セミコンダクタは, どんな OS のドライバからも独立した互
	換性テストを実行する COMTEST という名前の入手可能なプログラムを作
	成しました. このタイプのプログラムの目的は, 競合製品にある欠陥のデ
	モンストレーションであることをおぼえておくべきです. ですからそのプ
	ログラムは, テスト中の部品の動作の重要な問題と極めてささいな相違を
	同じように報告するでしょう. 

	この文書の著者が1994年に実行した一連のテストでは, ナショナルセミ
	コンダクタ, TI, StarTech そして CMD が製造した部品は megacell 及び 
	COMTEST でテストされた内蔵モデムに埋め込まれたエミュレーションと同
	等です. これらの部品のの幾つかで注目される相違点を以下に示します. 
	これらのテストは1994年に実行されたので, これらはベンダから供給さ
	れた製品の現在の性能には反映されないでしょう. 

	極端に多くの問題やあるタイプの問題が検出された場合に, COMTEST は通
	常は実行を中止することに注意してください. このテストの一部では, たと
	え何回相違点に遭遇しても中止しないように COMTEST を修正しました. 


<verb>ベンダ  	部品番号		報告された「相違点」として知られるエラー
National	(PC16550DV) 			0 *

National	(NS16550AFN)			0

National	(NS16C552V)			0 *

TI		(TL16550AFN)			3

CMD		(16C550PE)			19

StarTech	(ST16C550J)			23

Rockwell	reference modem
		with internal 16550 or an
		emulation (RC144DPi/C3000-25) 	117

Sierra		modem with an internal
		16550 (SC11951/SC11351)		91</verb>

	<p>COMTEST からの相違点の単純なカウントが, 何の相違点が重要であり
	どれがそうでないのかについて多くを明らかにしないことを理解すること
	が大切です. 例えば, 内蔵の UART を持つ上記の二つのモデムで報告され
	た相違点の約半分が, 5及び6ビットキャラクタモードをサポートしないク
	ローンの UART によって引き起こされました. 本物の 16550, 16450 そし
	て 8250 UART すべてはこれらのモードをサポートし, COMTEST はこれらの
	モードの機能性をチェックするので, 50を越える相違点が報告されました. 
	しかし, 5及び6ビットキャラクタモードをサポートするモデムは殆どなく, 
	特ににこれらはエラー修正と圧縮機能付のものです. これは5及び6ビット
	キャラクタモードに関連した相違点は差し引いて考えることができること
	を意味しています. 

	COMTEST が報告した相違点の多くは, タイミングに関する点でしょう. 
	多くのクローンの設計では, ホストが一つのポートから読み込んだ時に他
	のあるポートのステータスビットは, <em>本当の</em> NS16550AFN と同じ
	長さの時間内で更新されない (あるものは速く, あるものは遅く) かもしれ
	ませんが, COMTEST はこれらの相違点を探します. これは相違点の数は誤
	解を招き易いものです. あるデバイスには一つか二つの相違点しかありま
	せんがそれらは非常に重大かもしれません. また別のデバイスは基準部品
	と比べて速くまたは遅く status レジスタを更新するために (適切に書か
	れたドライバの操作にはまったく影響しないかもしれません) 多くの相違点を
	報告されるかもしれません. 

	* この文書の著者は今まで, COMTEST プログラムを使用して相違点がゼロ
	と報告されるナショナル・セミコンダクタ以外の部品を一つも発見しませ
	んでした. ナショナル・セミコンダクタは長年に渡り 16550 の五つのバー
	ジョンを持っており, 最新の部品は機能性のために, ベンチマークを考慮
	した古い NS16550AFN と少し異なる振る舞いをすることに注意するべきで
	す. COMTEST はナショナル・セミコンダクタの製品ラインの相違点につい
	ては見て見ぬふりをするようになり, 部品のリビジョン A, B そして C 
	にあるバグが記述されている公式な正誤表がある時でも, (オリジナルの 
	16550 を除いては) ナショナル・セミコンダクタの部品についてエラーを
	報告しなくなったので, この COMTEST のひいきを考慮にいれるべきです. 

	COMTEST は問題を引き起こすかも知れない, または特殊なケースとして処
	理しなければならない潜在的に矛盾した部品の存在に対して, 管理者に警
	告を出すスクリーニングツールとして使用できます. 

	もしモデムの中にある 16550 やシリアルポート接続されているモデムに
	対して COMTEST を実行する場合, モデムがテストキャラクタをエコーし
	ないように最初に ATE0&amp;W コマンドをモデムに発行する必要がありま
	す. これをおこなうことを忘れた場合, COMTEST は少なくともこの相違点を
	報告するでしょう: 
	<quote>Error (6)...Timeout interrupt failed: IIR = c1  LSR = 61</quote>

	<sect3><heading>8250/16450/16550 のレジスタ</heading>

	<p>8250/16450/16550 UART は八つの連続する I/O ポートアドレスを予約
	しています. IBM PC ではこれらの八つのポートに対して二つの定義された
	位置があり, それらは集合的に COM1 と COM2 として知られています. PC 
	クローンとアドオンカードのメーカーは COM3 と COM4 として知られる二つ
	の付加的な領域を作成しましたが, 幾つかのシステムではこれらの余分な 
	COM ポートは他のハードウェアと衝突します. 最もよく起きるものは IBM
	8514 エミュレーションを提供するビデオアダプタとの衝突です. 

<verb>
COM1 には 0x3f8 から 0x3ff が割り当てられ, 通常 IRQ 4 が使用されます
COM2 には 0x2f8 から 0x2ff が割り当てられ, 通常 IRQ 3 が使用されます
COM3 には 0x3e8 から 0x3ef が割り当てられ, IRQ は標準化されていません
COM4 には 0x2e8 から 0x2ef が割り当てられ, IRQ は標準化されていません
</verb>
<p>8250/16450/16550 UART のI/Oポートの詳細は以下に提供されています. 

<verb>
I/O	許可された		説明
ポート	アクセス

+0x00	write		Transmit Holding Register (THR)
	(DLAB==0)	このポートに書き込まれた情報はデータ命令として
			処理され, UART により送信されます. 

+0x00	read		Receive Buffer Register (RBR)
	(DLAB==0)	シリアル接続から UART によって受信されたすべての
			データ命令は, このポートを読むことによってホス
			トによりアクセスされます. 

+0x00	write/read	Divisor Latch LSB (DLL)
	(DLAB==1)	マスタ入力クロックの周波数をこのレジスタに入っ
			ている値で割ることにより, UART の周波数が決定
			されます (IBM PCでは, マスタクロックの周波数は
			1.8432MHzです). このレジスタには上記の除数の下
			位8ビットが入っています. 


+0x01	write/read	Divisor Latch MSB (DLH)
	(DLAB==1)	マスタ入力クロックの周波数をこのレジスタに入っ
			ている値で割ることにより, UART の周波数が決定
			されます (IBM PCでは, マスタクロックの周波数は
			1.8432MHzです). このレジスタには上記の除数の上
			位8ビットが入っています. 

+0x01	write/read	Interrupt Enable Register (IER)
	(DLAB==0)	8250/16450/16550 の UART はイベントを四つのカテ
			ゴリの一つに分類します. それぞれのカテゴリは設
			定可能です. それぞれのカテゴリは, どんな類のイ
			ベントの発生時に割り込みを生成するように設定可
			能です. 8250/16450/16550 の UART は, 有効になっ
			ているカテゴリ内でいくつのイベントが発生してい
			るかに関わらず, 単一の外部割り込みシグナルを生
			成します. 割り込みに応答し有効になっている割り
			込みカテゴリ (通常すべてのカテゴリが有効になって
			いる割り込みを持ちます) を割り込みの本当の原因
			を決定するためにポーリングするかは, ホストのプ
			ロセッサ次第です. 

			Bit 7	予約済み, 常に 0. 

			Bit 6	予約済み, 常に 0. 

			Bit 5	予約済み, 常に 0. 

			Bit 4	予約済み, 常に 0. 

			Bit 3	Enable Modem Status Interrupt (EDSSI)
				このビットを「1」に設定することで, 
				一つ以上の状態ラインで変更が発生した時
				に, UART が割り込みを生成可能となりま
				す. 

			Bit 2	Enable Receiver Line Status
				Interrupt (ELSI)
				このビットを「1」に設定することで, 入っ
				てくるデータにエラー (または BREAK シ
				グナル) が検知された時に, UART が割り
				込みを生成するようになります. 

			Bit 1	Enable Transmitter Holding Register
				Empty Interrupt (ETBEI)
				このビットを「1」に設定することで, 
				UART に送信される一つ以上の付加的な文
				字に対する空きが生じた時に, UART が割
				り込みを生成するようになります. 

			Bit 0	Enable Received Data Available
				Interrupt (ERBFI)
				このビットを「1」に設定することで, 
				UART が FIFO のトリガーレベルを越え
				る十分な文字を受け取るか, FIFO のタイ
				マが期限切れとなるか (古くなったデータ), 
				FIFO が無効の場合にシグナル文字が受信
				された時に, UART が割り込みを生成する
				ようになります. 


+0x02	write		FIFO Control Register (FCR)
			(このポートは 8250 と 16450 の UART では
			 存在しません.)
			
			Bit 7	Receiver Trigger Bit #1
			Bit 6	Receiver Trigger Bit #0
				この二つのビットは FIFO が機能している
				場合にレシーバがどの時点で割り込みを生
				成するかを制御します. 

				7 6	割り込み生成前にいくつの命令が
					受信されたか. 

				0 0	1

				0 1	4

				1 0	8

				1 1	14

			Bit 5	予約済み, 常に 0. 

			Bit 4	予約済み, 常に 0. 

			Bit 3	DMA Mode Select 
				Bit 0 が「1」 (FIFO 有効) に設定されて
				いる場合, このビットの設定は -RXRDY と 
				-TXRDY の処理を Mode 0 から Mode 1 へ
				変更します. 

			Bit 2	Transmit FIFO Reset
				このビットに「1」が書き込まれている場
				合, FIFO の内容は破棄されます. 現在送
				信されているすべての命令は損なわれずに送
				られるでしょう. この機能は送信中止の場
				合に役に立ちます. 

			Bit 1	Receiver FIFO Reset
				このビットに「1」が書き込まれている場
				合, FIFO の内容は破棄されます. 現在 
				shift レジスタ内で組み立てられているすべ
				ての命令は損なわれずに受信されるでしょ
				う. 

			Bit 0	16550 FIFO Enable
				設定されている場合, 送信 / 受信両方の 
				FIFO が有効になります. holding レジス
				タ, shift レジスタまたは FIFO 内のすべて
				の内容は, FIFO が有効または無効になっ
				た時点で失われます. 


+0x02	read		Interrupt Identification Register (IIR)

			Bit 7	FIFO有効. 
				8250/16450 UART では, このビットはゼロ. 

			Bit 6	FIFO有効. 
				8250/16450 UART では, このビットはゼロ. 

			Bit 5	予約済み, 常に0. 

			Bit 4	予約済み, 常に0. 

			Bit 3	Interrupt ID Bit #2
				8250/16450 UART では, このビットはゼロ. 
			Bit 2	Interrupt ID Bit #1
			Bit 1	Interrupt ID Bit #0
				これらの3つのビットは進行中の割り込み
				を引き起こしたイベントのカテゴリを併せ
				て報告します. これらのカテゴリは優先度
				を持つため, イベントの複数のカテゴリが
				同時に発生した場合, UART は最初に最も
				重要なイベントを報告し, ホストは報告さ
				れた順に解決するでしょう. 現在の割り込
				みを引き起こしたすべてのイベントは, 新し
				い割り込みが生成される前に解決されなけ
				ればなりません (これは PC のアーキテク
				チャの制限です). 

				2 1 0	優先度		説明

				0 1 1	First		レシーバエラー
							(OE, PE, BI または
							 FE)
							
				0 1 0	Second		有効な受信データ

				1 1 0	Second		トリガーレベル
							識別子
							(受信バッファ中の
							 古いデータ)

				0 0 1	Third		トランスミッタに
							命令用の空きがある
							(THRE)

				0 0 0	Fourth		モデムの状態が
							変わった (-CTS,
							-DSR, -RI, または
							-DCD)

			Bit 0	Interrupt Pending Bit
				このビットが「0」に設定されている場合, 
				少なくとも一つの割り込みがペンディング
				されています. 

+0x03	write/read	Line Control Register (LCR)

			Bit 7	Divisor Latch Access Bit (DLAB)
				設定されている場合, transmit/receive
				register (THR/RBR) と Interrupt Enable
				Register (IER) へのアクセスが無効にな
				ります. 現在これらのポートへのすべてのア
				クセスは Divisor Latch Register へリダ
				イレクトされます. このビットの設定, 
				Divisor Register のローディング, そし
				て DLAB のクリアは割り込みが無効になっ
				ている状態でおこなわれるべきです. 

			Bit 6	Set Break
				「1」に設定されている場合, トランスミッ
				タはこのビットが「0」に設定されるまで
				スペースを切り目なく送信します. これは
				送信されている文字のすべてのビットに優先
				します. 

			Bit 5	Stick Parity
				parity が有効になっている場合, このビッ
				トの設定はビット4の値に基づき parity 
				を常に「1」か「0」にします. 

			Bit 4	Even Parity Select (EPS)
				parity が有効でビット5が「0」の場合, 
				このビットの設定は偶数 parity が送信そ
				して要求されるようにします. そうでなけ
				れば奇数 parity が使用されます. 

			Bit 3	Parity Enable (PEN)
				「1」に設定されている場合, データの最
				後のビットとストップビットの間に 
				parity ビットが挿入されます. また UART 
				は受信データに存在する parity を要求す
				るでしょう. 

			Bit 2	Number of Stop Bits (STB)
				「1」に設定されている場合, 5-bit デー
				タ命令を使用して, 1.5の Stop ビットが
				送信され各データ命令内に要求されま
				す. 6, 7 そして 8-bit データ命令に対し
				ては, 2つの Stop ビットが送信され要求
				されます. このビットが「0」に設定され
				ている場合, 1つの Stop ビットが各デー
				タ命令で使用されます. 

			Bit 1	Word Length Select Bit #1 (WLSB1)

			Bit 0	Word Length Select Bit #0 (WLSB0)
				これらのビットは共に各データ命令内のビッ
				トの数を指定します. 

				1 0	命令長

				0 0	5 Data Bits
				0 1	6 Data Bits
				1 0	7 Data Bits
				1 1	8 Data Bits

+0x04	write/read	Modem Control Register (MCR)

			Bit 7	予約済み, 常に 0. 

			Bit 6	予約済み, 常に 0. 

			Bit 5	予約済み, 常に 0. 

			Bit 4	Loop-Back Enable 
				「1」に設定されている場合, UART のトラ
				ンスミッタとレシーバは診断処理のために
				内部的に相互に接続されます. 付け加えて 
				UART のモデム制御出力はモデム制御入力
				に接続されます. CTS は RTS へ, DTR は 
				DSRへ, OUT 1 は R1 へ, OUT 2 は DCD へ
				各々接続されます. 

			Bit 3	OUT 2
				ホストのプロセッサが high または low 
				に設定するであろう補助的な出力. IBM PC 
				のシリアルアダプタ (とクローンの殆ど) 
				では, OUT 2 は 8250/16450/16550 UART 
				からの割り込み信号をハイインピーダンス 
				(無効) にするのに使用されます. 

			Bit 2	OUT 1
				ホストのプロセッサが high または low 
				に設定するであろう補助的な出力. IBM PC 
				のシリアルアダプタではこの出力は使用
				されません. 

			Bit 1	Request to Send (RTS)
				「1」に設定されている場合, UART の 
				 -RTS ラインの出力は Low (有効) となり
				ます. 

			Bit 0	Data Terminal Ready (DTR)
				「1」に設定されている場合, UART の 
				-DTR ラインの出力は Low (有効) となり
				ます. 


+0x05	write/read	Line Status Register (LSR)

			Bit 7	Error in Receiver FIFO
				8250/16450 UART では, このビットはゼロ
				です. FIFOの中に次のエラー条件が一つ以
				上含まれている場合, このビットは「1」
				に設定されます: PE, FE, または BI. 

			Bit 6	Transmitter Empty (TEMT)
				「1」に設定されている場合, 送信 FIFO 
				または送信 shift レジスタ中に残ってい
				る命令はありません. トランスミッタは完
				全に働いていません. 

			Bit 5	Transmitter Holding Register Empty (THRE)
				「1」に設定されている場合, 現在 FIFO
				(または holding レジスタ) には少なくと
				も一つの送信される付加的な命令に対する
				空きあります. このビットが「1」に設定
				されている時は, 多分トランスミッタはま
				だ送信しています. 

			Bit 4	Break Interrupt (BI)
				レシーバは Break シグナルを検知しました. 

			Bit 3	Framing Error (FE)
				Start ビットが検知されましたが, Stop 
				ビットは要求された時間内には現れません
				でした. 受信された命令はおそらく勝手に
				解釈されます. 

			Bit 2	Parity Error (PE)
				parity ビットが受信された命令に対して
				不正です. 

			Bit 1	Overrun Error (OE)
				新しい命令が受信され, 受信バッファに空
				きがありませんでした. shift レジスタに
				新たに到着した命令は破棄されます. 
				8250/16450 UART では, holding レジスタ
				内の命令は破棄され新たに到着した命令は 
				holding レジスタに置かれます. 

			Bit 0	Data Ready (DR)
				一つ以上の命令がホストが読むであろう受
				信 FIFO にあります. このビットが設定さ
				れる前に, 命令は完全に受信され shift 
				レジスタから FIFO (または 8250/16450 
				の設計では holding レジスタ) へ移動さ
				れなければなりません. 


+0x06	write/read	Modem Status Register (MSR)
			
			Bit 7	Data Carrier Detect (DCD)
				UART の DCD ラインの状態を反映します. 

			Bit 6	Ring Indicator (RI)
				UART の RI ラインの状態を反映します. 

			Bit 5	Data Set Ready (DSR)
				UART の DSR ラインの状態を反映します. 

			Bit 4	Clear To Send (CTS)
				UART の CTS ラインの状態を反映します. 

			Bit 3	Delta Data Carrier Detect (DDCD)
				ホストによって MSR が最後に読み込まれ
				た時点から, -DCD ラインが状態を一回以
				上変えた場合に「1」に設定されます. 

			Bit 2	Trailing Edge Ring Indicator (TERI)
				ホストによって MSR が最後に読み込まれ
				た時点から, -RI ラインが low から high 
				へ移り変わった場合に「1」に設定されま
				す. 

			Bit 1	Delta Data Set Ready (DDSR)
				ホストによって MSR が最後に読み込まれ
				た時点から, -DSR ラインが状態を一回以
				上変えた場合に「1」に設定されます. 

			Bit 0	Delta Clear To Send (DCTS)
				ホストによって MSR が最後に読み込まれ
				た時点から, -CTS ラインが状態を一回以
				上変えた場合に「1」に設定されます. 


+0x07	write/read	Scratch Register (SCR)
			このレジスタは UART では機能しません. この場所
			には どんな値でもホストによって書き込まれるこ
			とができ, その後ホストによって読み込むことが可
			能です. 
</verb>

    <sect3><heading>16550A UART を越えて</heading>

	<p>ナショナル・セミコンダクタは付加的な機能を持つ 16550 と互換
	性のある部品を提供していませんが, 色々な他のベンダがそれを持っ
	ています. これらの部品の幾つかは以下に記述されています. 効果的
	にこれらの改良を使用するためには, 殆どのポピュラーなオペレーティ
	ングシステムが 16550 が提供する機能以上のものをサポートしない
	ため, ドライバはチップベンダから提供されなければならないことを
	理解しておく必要があります. 

<descrip>
<tag>ST16650</tag>デフォルトではこの部品は NS16550A と似ていますが, 拡
		張された32バイトの送受信バッファをオプションで有効にで
		きます. Startech により製造されました. 

<tag>TIL16660</tag>デフォルトではこの部品は NS16550A と類似した振舞いを
		しますが, 拡張された64バイトの送受信バッファをオプショ
		ンで有効にできます. Texas Instruments により製造されま
		した. 

<tag>Hayes ESP</tag>この専売特許のプラグインカードは, 2048バイトの送受
		信バッファを含み, 230.4Kbit/sec のデータレートをサポー
		トします. Hayes により製造されました. 

</descrip>

	<p>これらの「ダム」UART に加え, たくさんのベンダがインテリジェ
	ントシリアルコミニュケーションボードを製造しています. こ
	のタイプの設計は通常マイクロプロセッサを提供しており, このマイ
	クロプロセッサは幾つかの UART へのインタフェースとなってデータ
	を処理 / バッファリングし, そして必要な時にメインの PC のプロセッ
	サへ警告を出します. UART はこのタイプのコミニュケーションシ
	ステムにおいて PC のプロセッサによって直接アクセスされないため, 
	ベンダにとっては 8250, 16450, または 16550 UART と互換性のある 
	UART を使用する必要はありません. これにより設計者は, より良い
	性能特性を持つ部品が自由に利用できます. 

<!-- 601131 ? -->

