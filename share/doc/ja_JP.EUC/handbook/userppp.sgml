<!-- $Id: userppp.sgml,v 1.7 1997/05/10 03:45:18 max Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.17 -->

<sect>ユーザ PPP の設定<label id="userppp">

<!--  この FAQ あるいは手引は, <em>ユーザレベル ppp</em>または
   単に<em>ppp</em>としても知られている iijppp を, 
   あなたの FreeBSD 2.0.5 (以降) で動くようにすることを目的としています. 

<p>また, iijppp を ppp サーバとして使う方法の概略についても述べています. 

<p>このドキュメントは もともと Nik Clayton によって書かれたものですが, 
   現在では何年にもわたる共同作業の成果となっています. 

-->

<p>ユーザ PPP は FreeBSD 2.0.5-RELEASE において, 
   既存のカーネル実装版の PPP に加えて導入されました. 
   それでは, これまでの pppd との違い, すなわち
   この新しい PPP が追加された理由とは いったい何なのでしょうか? 
   マニュアルから引用してみます: 

<quote>
   これはユーザプロセス PPP ソフトウェアパッケージです. 
   通常, PPP は (例えば pppd でそうなっているように) カーネルの一部として
   実装されていますので, デバッグや動作の変更が少々困難です. 
   しかし, この実装では, PPP はトンネルデバイスドライバ (tun) の
   助けにより, ユーザプロセスとして実装されています. 
</quote>

  本質として, これは常に PPP デーモンを実行しておかなくても, 
  必要な時に ppp プログラムを実行できるということを意味します. 
  このプログラムはカーネルとのデータ送受のために一般のトンネルデバイスを
  使うことができるため, PPP インターフェースをカーネルに組み込んでおく
  必要がありません. 

  以降では, ユーザ ppp と他の PPP クライアント/サーバソフトウェアとを
  区別する必要がありませんので, ユーザ ppp を単に ppp とだけ呼びます. 
  特に断らない限り, このセクションのすべてのコマンドは root 権限で
  実行する必要があります. 

  訳者注: 以前の日本語ハンドブックでは, iij-ppp のオリジナルアーカイブに
          附属する日本語ドキュメントの参照をおすすめしていました. 
          しかし最近では FreeBSD 独自の拡張がいろいろと追加され, もともとの 
          iij-ppp のドキュメントではカバーしきれなくなって来ています. 
          ですが心配はいりません. 日本語マニュアルプロジェクトから 
          FreeBSD の日本語版マニュアルページが配布されるようになりました. 
          こちらもハンドブックとあわせて参照されることをおすすめします. 

<sect1><heading>スタートの前に</heading>

<p>このドキュメントでは, あなたが
   およそ以下のような状況にあると仮定しています: 

   PPP 接続の使えるインターネットサービスプロバイダ (ISP) のアカウントを
   持っている. さらに, 接続済みのモデム (またはその他のデバイス) があり, 
   プロバイダとの接続が可能なように正しく設定されている. 

   以下の情報を手に入れておく必要があるでしょう: 

<itemize>
   <item>プロバイダのゲートウェイの IP アドレス. 
         ゲートウェイとは, あなたがそこに接続をおこなって, 
         <tt>デフォルトルート</tt>として設定することになるマシンです. 

   <item>プロバイダのネットマスク設定. もし不明な場合には, 
         ネットマスクとして 0xffffff00 を仮定しておきます. 

   <item>一つ以上のネームサーバの IP アドレス. 通常, 二つの IP アドレスが
         プロバイダから示されているはずです. 

   <item>もしプロバイダが固定の IP アドレスとホスト名を割り当てているのなら, 
         同様にそれも必要になるでしょう. そうでなければ, どのアドレス範囲から
         IP アドレスの割り当てがおこなわれるかを知っておく必要があるでしょう. 
         もし範囲が示されていないとしても, 任意の IP アドレスを
         受け入れるようにすることが可能です (後で説明します). 
</itemize>

   もしこれらの情報のうち不明なものがあれば, プロバイダに連絡して
   確認しておいてください. 

   これに加えて, インターネットへの接続は常時おこなわれているわけではなく, 
   そのためネームサーバ (<tt>named(8)</tt>) を立ち上げていないと仮定します. 
   ネームサーバを立ち上げているのであれば, <tt>/etc/resolv.conf</tt>ファイルの
   設定に関する情報は無視してください. 

<sect1><heading>ppp 対応カーネルの構築</heading>

<p>説明でも述べているように, ``ppp'' はカーネルの ``tun'' デバイスを使います. 
   そのため, このデバイスがカーネルに組み込まれているかどうか
   確認しておかなくてはいけません. 

   これを確認するには, カーネルコンパイルディレクトリ
   (おそらくは /sys/i386/conf) に移動して, カーネルコンフィグレーション
   ファイルを調べます. 以下の行がどこかに含まれている必要があります. 

<tscreen><verb>
   pseudo-device tun 1
</verb></tscreen>

   元々の GENERIC カーネルは標準でこれを含んでいますので, 
   カスタムカーネルをインストールしているのではなかったり, 
   /sys ディレクトリが存在しないのであれば, 何も変更する必要はありません. 
   この行がカーネルコンフィグレーションファイルに含まれていなかったり, 
   tun デバイスが一つでは足りない場合 (例えば, 同時に 16 本の
   ダイアルアップ ppp 接続を処理できるサーバを立ち上げるとしたら, 
   ``1'' のかわりに ``16'' を指定する必要があるでしょう), この行を追加して
   カーネルの再コンパイルとインストールをおこなう必要があります. 
   それからこの新しいカーネルを使ってブートしてください. 
   カーネルコンフィグレーションの詳細については, 
   <ref id="kernelconfig" name="FreeBSD カーネルのコンフィグレーション">
   を参照してください. 

<p>以下のコマンドを実行することで, 現在のカーネルに
   いくつのトンネルデバイスが組み込まれているかを調べることができます: 

<tscreen><verb>
   # ifconfig -a
   tun0: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
           inet 200.10.100.1 --> 203.10.100.24 netmask 0xffffffff
   tun1: flags=8050<POINTOPOINT,RUNNING,MULTICAST> mtu 576
   tun2: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
           inet 203.10.100.1 --> 203.10.100.20 netmask 0xffffffff
   tun3: flags=8050<POINTOPOINT,RUNNING,MULTICAST> mtu 1500
</verb></tscreen>

   この例ではトンネルデバイスが四つあって, うち二つに設定がおこなわれていて 
   現在使用中であることがわかります. 

<p>トンネルデバイスがカーネルに組み込まれておらず, 何らかの理由で
   カーネルの再構築ができない場合でも, 方法がないわけではありません. 
   動的にデバイスをロードすることができるはずです. 詳細については
   modload(8) や lkm(4) など, 適切なマニュアルを参照してください. 

<p>この機会にファイアウォールも設定したいと思っているのであれば, 
   詳細については<ref id="firewalls" name="ファイアウォール">セクションを
   参照してください. 

<sect1><heading>tun デバイスの確認</heading>

<p>ほとんどのユーザは ``tun'' デバイス (tun0) が一つあれば充分でしょう. 
   より多くのデバイスを使う場合 (すなわち, カーネルコンフィグレーション
   ファイルで疑似デバイスの行に `1' 以外の数値を指定している場合), 
   以下の ``tun0'' に対する参照をすべて, あなたが使うデバイスの番号に
   あわせて読みかえてください. 

   tun0 デバイスが正しく設定されていることを確認する最も簡単な方法は, 
   それを作り直すことです. そのためには, 以下のコマンドを実行します: 

<tscreen><verb>
   # cd /dev
   # ./MAKEDEV tun0
</verb></tscreen>

<p>カーネルに 16 個のトンネルデバイスを組み込んだのであれば, 
   tun0 だけでなく他の tun デバイスも作成しておく必要があるでしょう: 

<tscreen><verb>
   # cd /dev
   # ./MAKEDEV tun0 tun1 tun2 tun3 tun4 tun5 tun6 tun7 tun8 tun9
   # ./MAKEDEV tun10 tun11 tun12 tun13 tun14 tun15
</verb></tscreen>

<p>また, カーネルが正しく設定されているかどうか調べるために, 
   以下のコマンドで このような出力が得られるかどうかを確認します: 

<tscreen><verb>
   $ ifconfig tun0
   tun0: flags=8050<POINTOPOINT,RUNNING,MULTICAST> mtu 1500
   $ 
</verb></tscreen>

<sect1><heading>PPP の名前解決に関する設定</heading>

<p>リゾルバ (resolver) はネットワーキングシステムの一部分で, IP アドレスと
   ホスト名との変換をおこないます. これは, IP アドレスとホスト名を
   対応させるためのマップを, 二つの場所のうちの一つから探すように設定できます. 
   一つめは<tt>/etc/hosts</tt> (<tt>man 5 hosts</tt>) と呼ばれるファイルです. 
   二つめはインターネットドメインネームサービス (DNS) とよばれる
   分散データベースですが, これに関する議論はこのドキュメントの扱える範囲を
   越えていますので, これについての説明はおこないません. 

<p>このセクションではリゾルバの設定方法について簡単に説明します. 
   既に DNS を使用しているのであれば, このセクションは飛ばしてもかまいません. 

<p>リゾルバは名前のマッピングをおこなうシステムコールの集合体です. ただし
   どこからマッピング情報を得るのかは, あなたが指示する必要があります. 
   これはまず<tt>/etc/host.conf</tt>ファイルを編集することでおこないます. 
   混乱の元ですので, このファイルを<tt>/etc/hosts.conf</tt>と
   呼んだりしては<bf>いけません</bf> (余分な ``s'' がついていますね). 

<sect2><heading>/etc/host.conf ファイルの編集</heading>

<p>このファイルは以下の 2 行を含んでいるはずです: 

<tscreen><verb>
   hosts
   bind
</verb></tscreen>
   これは, 最初に<tt>/etc/hosts</tt>ファイルを調べ, 
   目指す名前が見つからなければ DNS を引きにいくようリゾルバに指示します. 

<sect2><heading>/etc/hosts(5) ファイルの編集</heading>

<p>このファイルはローカルネットワーク上に存在するマシンの IP アドレスと
   ホスト名を含んでいるはずです. 最低でも ppp を動作させるマシンのエントリが
   含まれている必要があります. そのマシンのホスト名が foo.bar.com で, 
   IP アドレスが 10.0.0.1 であると仮定すると, <tt>/etc/hosts</tt>は
   以下の行を含んでいなければいけません: 

<tscreen><verb>
   127.0.0.1    localhost
   10.0.0.1     foo.bar.com	       foo
</verb></tscreen>

   一つめの行は ``localhost'' を現在のマシンの別名として定義しています. 
   マシン固有の IP アドレスが何であっても, この行の IP アドレスは
   常に 127.0.0.1 でなければいけません. 二つめの行はホスト名 ``foo.bar.com'' 
   (と, その省略形 ``foo'') を IP アドレス 10.0.0.1 にマップします. 

   もしプロバイダから固定の IP アドレスを割り当てられているのであれば, 
   それを 10.0.0.1 のかわりに使ってください. 

<sect2><heading>/etc/resolv.conf ファイルの編集</heading>

<p><tt>/etc/resolv.conf</tt> はネームサーバをそのマシンで走らせていない場合に
   必要になる特別な情報を含んでいます. これは実際のネームサーバの位置を
   リゾルバルーチンに示したり, その他いくつかの情報を指定したりします. 

   <tt>/etc/resolv.conf</tt>には問い合わせが可能なネームサーバを少なくとも
   一つ指定しておく必要がありますが, できれば二つ指定するのが望ましいでしょう. 
   これは (ホスト名ではなく) IP アドレスで書かなければいけません. 例えば: 

<tscreen><verb>
   nameserver 1.2.3.4
   nameserver 1.2.3.5
</verb></tscreen>

   接続するプロバイダの「ネームサーバ」指定をすべて書いてください. 
   このファイルの各エントリの詳細については, 
   resolv.conf のマニュアルページを参照してください. 

<sect1><heading>PPP の設定</heading>

<p>ユーザ ppp と pppd (カーネルレベルの PPP 実装) は
   どちらも<tt>/etc/ppp</tt>ディレクトリに置かれた設定ファイルを使います. 
   設定ファイルのサンプルが提供されていて, ユーザ ppp の設定をおこなう際に
   大変参考になりますので, 削除したりしないでください. 

<p>ppp の設定をするためには, 必要に応じて三つまでのファイルを編集する必要が
  あります. 書き込む内容は, プロバイダが静的に IP アドレスを割り当てる 
  (つまり, 固定の IP アドレスを一つ与えられて, 常にそれを使う) か, 
  または動的に IP アドレスを割り当てる (つまり, PPP セッションごとに 
  IP アドレスが変化する可能性がある) かということに ある程度依存します. 

<sect2><heading>静的 IP アドレスによる PPP 接続</heading>

<p><tt>/etc/ppp</tt>ディレクトリにファイルを三つ作成する必要があります. 

<p>一つめのファイルは<tt>ppp.conf</tt>です. 以下の例とほぼ同じようなものに
   なるでしょう. ``:'' で終る行は 1 カラム目から始まり, その他の行は
   スペースまたはタブで以下の例のように段をつける (インデントする) 必要が
   あることに注意してください. 

   <tt>/etc/ppp/ppp.conf</tt>
<tscreen><verb>
1     default:
2       set device /dev/cuaa0
3       set speed 38400
4       set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" ATE1Q0 OK-AT-OK
\\dATDT\\T TIMEOUT 40 CONNECT"
5      provider:
6        set phone 01234567890
7        set login "TIMEOUT 10 gin:-BREAK-gin: foo word: bar col: ppp"
8        set timeout 120
9        set ifaddr x.x.x.x y.y.y.y
10       delete ALL
11       add 0 0 y.y.y.y
12       set openmode active
</verb></tscreen>
   行番号はファイルに書かないでください. これは, 解説の際に
   参照する行を示すためにつけたものです. 

<descrip>
<tag/Line 1:/  デフォルトエントリを指定します. このエントリ中のコマンドは
               ppp が起動された際に自動的に実行されます. 

<tag/Line 2:/  モデムが接続されているデバイスを指定します. 
               COM1: は<tt>/dev/cuaa0</tt>に, 
               COM2: は<tt>/dev/cuaa1</tt>になります. 

<tag/Line 3:/  通信速度 (DTE 速度) を指定します. 

<tag/Line 4:/  ダイアルスクリプトを指定します. 
               ユーザ ppp は<tt>chat(8)</tt>言語に似た, 受信待ち文字列と
               送信文字列の対からなるスクリプトを使用します. 
               この言語の機能に関しては, マニュアルページを参照してください. 

<tag/Line 5:/  接続するプロバイダの名前 ``provider'' を
               エントリ名として指定します. 

<tag/Line 6:/  このプロバイダの電話番号を指定します. 
               複数の電話番号を `:' で区切って指定することができます. 

<tag/Line 7:/  ログインスクリプトを指定します. ログインスクリプトも
               ダイアルスクリプトと同様の記述方法になります. 
               この例は, 以下のようなログインセッションを使用している
               プロバイダのためのものです. 

<tscreen><verb>
   J. Random Provider
   login: foo
   password: bar
   protocol: ppp
</verb></tscreen>

               このスクリプトは必要に応じて書きかえる必要があるでしょう. 

<tag/Line 8:/  デフォルトの接続タイムアウト時間を (秒数で) 指定します. 
               この例では, 120 秒間 通信がおこなわれなければ
               自動的に接続を切るように指定しています. 

<tag/Line 9:/  インターフェースのアドレスを指定します. 文字列 x.x.x.x は
               プロバイダに割り当てられた IP アドレスで置きかえてください. 
               文字列 y.y.y.y はプロバイダから指示されたゲートウェイ
               (接続先となるマシン) の IP アドレスで置きかえてください. 

<tag/Line 10:/ この PPP 接続で使用する tun デバイスに関する, 
               既存のルーティングテーブルエントリをすべて削除します. 

<tag/Line 11:/ プロバイダ側の IP アドレスをデフォルトルートに指定します. 
               この IP アドレスは常にプロバイダのゲートウェイの
               IP アドレスでなければいけません. 

<tag/Line 12:/ こちら側からネゴシエーションを開始するように指示します. 
              これは接続相手が自分からネゴシエーションを開始するように
              設定されている場合には必要ありませんが, 両側とも自分から
              Line Control Protocol (LCP) を開始するように設定されていても
              何も問題はありません. 
</descrip>

<p>二つめのファイルは<tt>/etc/ppp/ppp.linkup</tt>です: 

<tscreen><verb>
   x.x.x.x:
    delete ALL
    add 0 0 HISADDR
</verb></tscreen>

<p>先ほどと同じように, プロバイダに割り当てられた IP アドレスで x.x.x.x を
   置きかえます. このファイルは, この PPP 接続に関する既存のルートをすべて
   自動的に削除したり, プロバイダから このマシンへのルートを
   デフォルトルートとして追加するのに使われます. 
   (HISADDR マクロは自動的にプロバイダ側のアドレスに置きかえられます) 

<p>プロバイダが静的な IP アドレスを割り当ててくれるなら, 
   実は<tt>/etc/ppp.linkup</tt>ファイルにエントリを書く必要はありません. 
   しかし, 繰り返しになりますが, 書いてあっても何の問題もありません. 

<p>最後は, 三つめのファイル<tt>/etc/ppp/ppp.secret</tt>です. 
   このファイルでは ppp サーバへのアクセスを制御するためのパスワードを
   設定することができます. 複数の人がこの ppp システムを使うのであれば, 
   パスワードを設定したいと思う場合があるかもしれません. 

<p>これらのファイルのサンプルが<tt>/etc/ppp</tt>ディレクトリに置かれています. 

<sect2><heading>動的 IP アドレスによる PPP 接続</heading>

<p>プロバイダが静的な IP アドレスの割り当てをおこなっていない場合, 
   <tt>ppp</tt>が相手側のホスト (ゲートウェイ) と交渉して, 
   こちら側と相手側のアドレスを決めるように設定することができます. 
   これは, 起動時には「仮」のアドレスを使っておいて, 
   接続時に LCP により ppp が IP アドレスを正しく設定できるようにすることで
   実現されます. その他の設定は, 静的な IP アドレスを使う場合と同じです. 

<p>静的な IP アドレスを使う場合の<tt>ppp.conf</tt>ファイルの
   エントリの該当部分を以下のように変更します: 

<tscreen><verb>
   ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0
   delete ALL
   add 0 0 10.0.0.2
</verb></tscreen>

<p>こちら側と相手側, どちらの IP アドレスに対しても, 0 を指定するべきでは
   「ありません」. もし 0 を指定すると, ppp が正しい初期エントリを
   ルーティングテーブルに設定することができなくなるでしょう. 

<p>``/'' 文字の後ろの数字は, アドレス交渉の際に固定しておきたいビット数です. 

<p><tt>ppp.conf</tt> を読み込んだ時点では, まだ HISADDR マクロが
   使えないことにも注意してください. 
   このマクロが使えるのは<tt>ppp.linkup</tt>の中でだけです. 

<p>詳細なサンプルについては, 
   <tt>/etc/ppp/ppp.conf.sample</tt>ファイル中の pmdemand エントリと
   <tt>/etc/ppp/ppp.linkup.sample</tt>を参照してください. 

<sect2><heading>かかってきた電話を PPP で受けるには</heading>

<p>このセクションでは iijppp をサーバとして設定する方法について説明します. 

<p>かかってきた電話を<tt>ppp</tt>が受けるように設定する場合, 
   <tt>ppp</tt>接続についてだけパケットをフォワードするようにしたいのか, 
   すべてのインターフェースについてフォワードするようにしたいのか, 
   それともまったくフォワードをおこないたくないのかを決めなければいけません. 
   ppp 接続についてだけフォワードをおこなうためには, 
   以下の行を<tt>ppp.conf</tt>ファイルに追加しておきます. 

<tscreen><verb>
    enable proxy
</verb></tscreen>

   すべてのインターフェースについてパケットの転送をおこないたい場合は, 
   以下のオプションを<tt>/etc/rc.conf</tt>に設定してください. (このファイルは
   以前のバージョンの FreeBSD では<tt>/etc/sysconfig</tt>と呼ばれていました) 

<tscreen><verb>
    gateway=YES
</verb></tscreen>

<sect3><heading>どの getty を使おうか?</heading>

<p>getty を使ってダイアルアップサービスをおこなうための優れた解説が
   <ref id="dialup" name="FreeBSD でダイアルアップサービスをおこなうための設定">
   にあります. 

<p>getty に代わるものとしては, 
   <url url="http://www.leo.org/~doering/mgetty/index.html" name="mgetty">
   があります. これは getty をより柔軟にしたもので, 
   ダイアルアップ回線での使用を意図して設計されています. 

<p>mgetty を使う場合の利点は, mgetty が積極的にモデムと<em>通信する</em>
   ということです. つまり, もし<tt>/etc/ttys</tt>でポートを閉じた場合, 
   モデムは電話をとらないようになります. 

<p>最近のバージョンの mgetty (0.99beta 以降) では, PPP ストリームの
   自動検出もサポートされています. これにより, クライアント側で
   スクリプトを準備しなくともサーバにアクセスすることができます. 

<p>mgetty の入手方法と正しい設定については, このドキュメントの扱う範囲を
   越えています. 
   訳者注: 最近の ports および packages には mgetty+sendfax が含まれています. 

<sect3><heading>動的 IP ユーザのための PPP シェルの設定</heading>

<p><tt>/etc/ppp/ppp-shell</tt>という名前で, 以下のような内容のファイルを
   作成します: 

<tscreen><verb>
   #!/bin/sh
   IDENT=`echo $0 | sed -e 's/^.*-\(.*\)$/\1/'`
   CALLEDAS="$IDENT"
   TTY=`tty`

   if [ x$IDENT = xdialup ]; then
       IDENT=`basename $TTY`
   fi

   echo "PPP for $CALLEDAS on $TTY"
   echo "Starting PPP for $IDENT"

   exec /usr/sbin/ppp -direct $IDENT
</verb></tscreen>

<p>このスクリプトには実行可能属性をつけておきます. 
   次に以下のコマンドを実行し, <tt>ppp-dialup</tt>という名前で
   このスクリプトへのリンクを作成します: 

<tscreen><verb>
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-dialup
</verb></tscreen>

<p>すべてのダイアルアップ ppp ユーザのログイン<em>シェル</em>として
   このスクリプトを使用します. 以下は pchilds というユーザ名の
   ダイアルアップユーザを<tt>/etc/password</tt>へ登録した場合の例です. 
   (パスワードファイルを直接エディタで編集したりせず, 
   <tt>vipw</tt>を使ってください) 

<tscreen><verb>
   pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup
</verb></tscreen>

<p>任意のユーザが読むことのできる, <tt>/home/ppp</tt>ディレクトリを
   作成します. <tt>/etc/motd</tt>が表示されないようにするため, 
   以下のように大きさが 0 バイトのファイルを このディレクトリの下に
   作成しておきます. 

<tscreen><verb>
   -r--r--r--   1 root     wheel           0 May 27 02:23 .hushlogin
   -r--r--r--   1 root     wheel           0 May 27 02:22 .rhosts
</verb></tscreen>

<sect3><heading>静的 IP ユーザのための PPP シェルの設定</heading>

<p>上記と同じように<tt>ppp-shell</tt>ファイルを作成し, 
   静的に IP アドレスを割り当てる それぞれのアカウントごとに
   <tt>ppp-shell</tt>へのシンボリックリンクを作成します. 

<p>例えば, クラス C のネットワークの経路制御を必要とする, 
   三人のダイアルアップ顧客 fred, sam, mary がいるとすると, 
   以下のコマンドを実行することになるでしょう: 

<tscreen><verb>
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary
</verb></tscreen>

<p>これらのユーザのダイアルアップアカウントでは, 上で作成した
   それぞれのシンボリックリンクをログインシェルとして設定しておきます. 
   (つまり, ユーザ mary のログインシェルは<tt>/etc/ppp/ppp-mary</tt>に
   なります). 

<sect3><heading>動的 IP ユーザのための ppp.conf の設定</heading>

<p><tt>/etc/ppp/ppp.conf</tt>ファイルは 大体以下のような内容になるでしょう: 

<tscreen><verb>
   default:
    set debug phase lcp chat
    set timeout 0

   ttyd0: 
    set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
    enable proxy

   ttyd1:
    set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
    enable proxy
</verb></tscreen>
 
<p>上の例のように段をつける (インデントする) 必要があることに注意してください. 

<p><tt>default:</tt> セクションはセッションごとにロードされます. 
   <tt>/etc/ttys</tt>で有効にしてある各ダイアルアップ回線ごとに一つ, 
   上記の<tt>ttyd0:</tt>のようなエントリを作成します. 
   各行の相手側アドレスとして, それぞれ別の IP アドレスを 
   動的 IP ユーザのための IP アドレスのプールから割り当てておく必要があります. 

<sect3><heading>静的 IP ユーザのための ppp.conf の設定</heading>

<p>上のサンプルの<tt>/etc/ppp/ppp.conf</tt>の内容に加えて, 
   静的に IP を割り当てられたダイアルアップユーザ
   それぞれのためのセクションを追加する必要があります. 
   ここでも fred, sam, mary の例を使うことにしましょう. 
 
<tscreen><verb>
   fred:
    set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255
 
   sam:
    set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255
 
   mary:
    set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255
</verb></tscreen> 

<p>必要であれば, それぞれの静的 IP ユーザのための経路制御情報も
   <tt>/etc/ppp/ppp.linkup</tt>ファイルに含めておくべきでしょう. 
   以下の例ではクライアントの ppp リンクを経由する
   クラス C の<tt>203.14.101.0</tt>ネットワークへの経路を追加しています. 

<tscreen><verb>
   fred:
    add 203.14.101.0 netmask 255.255.255.0 HISADDR
 
   sam:
    add 203.14.102.0 netmask 255.255.255.0 HISADDR
 
   mary:
    add 203.14.103.0 netmask 255.255.255.0 HISADDR
</verb></tscreen> 

<sect3><heading>mgetty, AutoPPP, マイクロソフト拡張について さらに詳しく</heading>

<sect4><heading>Mgetty と AutoPPP</heading>

<p>AUTO_PPP オプションつきでコンパイルした mgetty を使えば, mgetty が
   PPP 接続の LCP フェーズを検出して, 自動的に ppp シェルを起動するように
   設定することができます. 
   しかし この場合, デフォルトの login/password シーケンスは発生しないので, 
   ユーザの認証は PAP または CHAP を使っておこなう必要があります. 

<p>このセクションでは, ユーザ (あなた) が問題なく
   AUTO_PPP オプションつきの mgetty (v0.99beta またはそれ以降) の設定, 
   コンパイル, インストールができているものと仮定しています. 
 
<p><tt>/usr/local/etc/mgetty+sendfax/login.config</tt>ファイルが
   以下の行を含んでいることを確認してください: 
 
<tscreen><verb>
   /AutoPPP/ -     -       /etc/ppp/ppp-pap-dialup
</verb></tscreen>
 
<p>これにより, PPP 接続を検出したら mgetty が<tt>ppp-pap-dialup</tt>
   スクリプトを実行するようになります. 
 
<p><tt>/etc/ppp/ppp-pap-dialup</tt>という名前で, 以下のような内容のファイルを
   作成します (このファイルは実行可能属性をつけておく必要があるでしょう): 

<tscreen><verb>
   #!/bin/sh
   TTY=`tty`
   IDENT=`basename $TTY`
   exec /usr/sbin/ppp -direct pap$IDENT
</verb></tscreen>   

<p><tt>/etc/ttys</tt>で有効になっている各ダイアルアップ回線ごとに, 
   対応するエントリを一つ<tt>/etc/ppp/ppp.conf</tt>に作成します. 
   これは上で作成した定義と問題なく共存できるでしょう. 

<tscreen><verb>
   papttyd0:
    enable pap
    set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
    enable proxy

   papttyd1:
    enable pap
    set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
    enable proxy
</verb></tscreen>

<p>この方法でログインする各ユーザは, PAP によるユーザ認証をおこなうために
   <tt>/etc/ppp/ppp.secret</tt>ファイルにユーザ名とパスワードを書いておくか, 
   または<tt>/etc/password</tt>ファイルを使うように

<tscreen><verb>
  enable passwdauth
</verb></tscreen>

   オプションを (/etc/ppp/ppp.conf に) 追加しておく必要があるでしょう. (*)

<p>(*) このオプションは 2.2-961014-SNAP およびそれ以降のシステムか, 
   または 2.1.x のシステムにおいて ppp のコードを更新している場合にだけ
   使用可能だということに注意してください. 
   (詳細に関しては, 以下のマイクロソフト拡張を参照してください) 

<sect4><heading>マイクロソフト拡張</heading>

<p>2.2-961014-SNAP 以降では, 
   DNS と NetBIOS ネームサーバの自動交渉 (negotiation) をサポートしている
   クライアント (例えば Win95/NT クライアント) との間で
   この機能を使うことができます. 
   プロトコルの詳細については RFC1877 を参照してください. 

<p>これらの拡張機能を<tt>/etc/ppp/ppp.conf</tt>ファイルで有効にした例を
   以下に示します. 

<tscreen><verb>
   default:
    set debug phase lcp chat
    set timeout 0
    enable msext
    set ns 203.14.100.1 203.14.100.2
    set nbns 203.14.100.5
</verb></tscreen>  

<p>これにより, クライアントはプライマリとセカンダリのネームサーバアドレス
   および NetBIOS ネームサーバホストを知ることができます. 

<sect1><heading>システムの最終設定</heading>

<p>これで PPP の設定は終りました. 
   しかし PPP が動くようになる前に, もう少し必要なことがあります. 
   それらの設定は, すべて<tt>/etc/rc.conf</tt>ファイルを
   編集することでおこないます. 
   (このファイルは以前には<tt>/etc/sysconfig</tt>と呼ばれていました) 

   このファイルを上から順に設定していきます. 
   まずは ``hostname='' の行が設定されていることを確認します. 
   例えば以下のように: 

<tscreen><verb>
   hostname=foo.bar.com
</verb></tscreen>

<p>次に network_interfaces 変数を調べます. 必要に応じて (on demand) 
   プロバイダにダイアルするようにシステムを設定したい場合には, 
   tun0 デバイスがこのリストに追加されていることを確認しておきます. 
   それ以外の場合には, tun0 デバイスをリストから削除しておきます. 

<tscreen><verb>
   network_interfaces="lo0 tun0"
   ifconfig_tun0=
</verb></tscreen>

   <tt>ifconfig_tun0</tt>変数が空で, /etc/start_if.tun0 という名前の
   ファイルが作成されていなければならない ということに注意してください. 
   このファイルの内容は以下のようになります. 

<tscreen><verb>
   ppp -auto mysystem
</verb></tscreen>

   このスクリプトはネットワークの設定時に実行され, 
   ppp デーモンを自動モードで立ち上げます. 

<p>以下のようにルータプログラムを ``NO'' に設定します. 

<tscreen><verb>
   router_enable=NO            (/etc/rc.conf)
   router=NO                   (/etc/sysconfig)
</verb></tscreen>

   <tt>routed</tt>は, ppp が作成したデフォルトのルーティングテーブル
   エントリを削除してしまう場合がありますので, <tt>routed</tt>デーモンが
   起動されないようにしておくことが重要です. (これは初期設定の状態です) 

<p>``sendmail_flags'' 行が ``-q'' オプションを含まないように
   設定しておいた方がよいでしょう. さもないと, sendmail が
   アドレスを調べようとして発信をおこなってしまう場合があります. 
   以下のような設定で良いでしょう: 

<tscreen><verb>
   sendmail_flags="-bd"
</verb></tscreen>

   この結果, PPP リンクを立ち上げた時には いつでも
   以下のコマンドを実行して, キューにたまっているメールを
   sendmail に送信させる作業が必要になるでしょう. 

<tscreen><verb>
   # /usr/sbin/sendmail -q
</verb></tscreen>

   こうするのが嫌であれば, SMTP トラフィックをブロックするように
   "dfilter" を設定しておくこともできます. 
   詳細についてはサンプルファイルを参照してください. 
   また, <tt>ppp.linkup</tt>ファイルの中で
   このコマンドを実行するスクリプトを起動することもできます. 

   後はマシンをリブートするだけです. 

   さて, これで
<tscreen><verb>
   # ppp
</verb></tscreen>

   コマンドを実行し, 続いて PPP セッションを開始させるために
   ``dial provider'' と入力することもできますし, 
   (start_if.tun0 スクリプトを作成していない場合に), 
   外部へのトラフィックが発生した時に, ppp が自動的に
   セッションを確立してくれるようにしたいのであれば, 
   以下のコマンドを実行することもできます. 

<tscreen><verb>
   # ppp -auto provider
</verb></tscreen>

<sect1><heading>まとめ</heading>

<p>要約すると, 初めて ppp を設定する際には, 以下のステップが不可欠です: 

<p>クライアント側:

<itemize>
   <item>カーネルに tun デバイスが組み込まれていることを確認. 
   <item><tt>/dev</tt>ディレクトリに tunX デバイスファイルが
         存在することを確認. 
   <item><tt>/etc/ppp.conf</tt>にエントリを作成. 
         ほとんどのプロバイダでは, <tt>pmdemand</tt> の例で充分でしょう. 
   <item><tt>/etc/ppp.linkup</tt>にエントリを作成. 
   <item>rc.conf (または sysconfig) ファイルを更新. 
   <item>必要に応じてダイヤル (demand dialing) したいのであれば, 
         start_if.tun0 スクリプトを作成. 
</itemize>

<p>サーバ側:
<itemize>
   <item>カーネルに tun デバイスが組み込まれていることを確認. 
   <item><tt>/dev</tt>ディレクトリに tunX デバイスファイルが
         存在することを確認. 
   <item>(vipw(8) コマンドを使って) /etc/passwd にエントリを作成. 
   <item>このユーザのホームディレクトリに
         ``ppp -direct direct-server'' か何かを実行するプロファイルを作成. 
   <item><tt>/etc/ppp.conf</tt>にエントリを作成. 
         <tt>direct-server</tt>の例で充分でしょう. 
   <item><tt>/etc/ppp.linkup</tt>にエントリを作成. 
   <item>rc.conf (または sysconfig) ファイルを更新. 
</itemize>

<sect1><heading>謝辞</heading>

<p>批評と提案に感謝します: 

<p>&a.nik
<p>&a.dirkvangulik
<p>&a.pjc
