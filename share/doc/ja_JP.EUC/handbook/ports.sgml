<!-- $FreeBSD$ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.20 -->

<sect><heading>ports コレクション <label id="ports"></heading>

<p><em>原作: &a.jraynard;.</em>
<p><em>訳: &a.masaki;, &a.saeki;.<newline>
11 November 1996.</em>

FreeBSD の ports コレクションを利用すると, 最小限の労力で
非常に幅広くのアプリケーションのコンパイルとインストールがおこなえます. 

<p> やってみたことのある方はよくご存知でしょうが, オープンな規格とは
全くの誇大広告であって, あるプログラムを異なるバージョンの Unix 上で
動作させることは退屈で手間のかかる仕事です. 
求めているプログラムが自分のシステムでうまくコンパイルでき, 
正しいところにインストールできて, 完璧に動作するとしたらとてもラッキーです. 
しかし, あいにくこれは滅多にないことなのです. 
ほとんどのプログラムについて, あなたは髪を掻きむしることになるでしょうし, 
かなりのプログラムでは, 白髪混じりの頭になってしまったり, あるいは慢性の
脱毛症にすら なってしまうかもしれません... 

<p> いくつかのソフトウェアディストリビューションでは, 設定用のスクリプトを
配布することでこの問題を解決しようとしています. 
これらのスクリプトの中には非常に精巧なものもありますが, 残念ながら, 
中にはこれまで聞いたこともないようなシステムの名前をしゃあしゃあと
言い放ったうえに, まるでシステムレベルの Unix プログラミングに関する
最終試験のような, たくさんの質問をしてくる場合があります. 
 (例えば, 「このシステムの gethitlist 関数は fromboz への const ポインタを
返しますか? それとも const fromboz へのポインタを返しますか?」, 
「このシステムには Foonix スタイルの, 容認できない例外処理をおこなう
ルーチンがありますか? もしもないとしたら, それはなぜですか?」) 

<p> 幸いなことに, ports コレクションがあれば, これらのきつい作業はすべて
完了しています. 'make install' とタイプするだけで, 動作するプログラムを
入手することができるのです. 

<sect1><heading> なぜ ports コレクションを作ったのか?</heading>

<p>FreeBSD の基本システムは, 非常に多くのツールやユーティリティから
構成されています. しかし, よく使われるプログラムのうち多くのものが, 
この基本システムには含まれていません. その理由は:-

<enum>
<item> 「私は x と y と z のプログラムがシステムにないと生きていけない」と
いう類のプログラム (例えば Lisp ベースのエディタや DOS フロッピーを扱うための
mtools など) は, 人によって全然違うから. (Emacs に我慢ならないという人や, 
DOS フロッピーをまったく使わないという人も大勢いるのです. そういう人は
Emacs や mtools が基本システムに含まれていなくても何の問題もないでしょう.) 

<item> 基本システムに組み込むには特殊すぎるから. (CAD やデータベースなど) 

<item> 「時間があったら, ちょっと見てみようかな」というような類の, 
それがシステムに含まれていないことが致命的とは言えないプログラムだから. 
 (おそらく, 何らかの言語などでしょう.) 

<item>お楽しみのためのプログラムは, FreeBSD のような真面目な
オペレーティングシステムといっしょに配布するべきではないから. ;-)

<item> たくさんのプログラムを基本システムに組み込んだとしても, もっともっと
組み込みたいという要求が出てくるので, どこかで制限を引かなくてはならないため. 
 (そうしなければ FreeBSD の配布物は, とてつもなく膨大になってしまうでしょう.) 
</enum>

<p> すべての人が自分のお気に入りのプログラムを手作業で移植しなければ
ならないとしたら,  (途方もない膨大な作業の繰り返しをさておいたとしても) 
それは明らかに不合理な話です. 
そこで, FreeBSD プロジェクトでは, 標準のツールを使って移植のプロセスを
自動化する巧妙な方法を考え出しました. 

<p> なお, これは単純ながら非常に柔軟なツールを組み合わせることで, 
非常に強力な働きをさせるという「Unix 流」の作業の優れた実例です. 

<sect1><heading>ports コレクションはどのように動くのでしょうか?</heading>
<p>
インターネットでは通常, <ref id="ports:tarball" name="tarball"> の形で
プログラムが配布されています. これは, Makefile とソースコードで構成され, 
普通は何らかの説明書 (あいにく, いつもわかりやすく書かれているとは
限りませんが) が付属しています. 
ことによるとコンフィグレーションスクリプトも含まれているかもしれません. 
<p>
標準的な手順では, FTP で tarball を入手して, 適当なディレクトリで展開します. 
次に説明書を読んで, 必要な変更をおこないます. そして, 設定スクリプトを実行し, 
標準の make コマンドを使ってソースのコンパイルとインストールをおこないます. 
<p>
FreeBSD の ports も tarball の仕組みを利用していますが, これはユーザが
苦労して作業することを期待したものではなく, どのようにすれば FreeBSD 上で
そのプログラムが動くようになるかという「ノウハウ」を <ref id="ports:skeleton" 
name="スケルトン"> を使用して収めているものです. 
スケルトンは, カスタマイズ済みの <ref id="ports:makefile" name="Makefile"> も
提供していますので, ほとんどすべての ports は同じ手順でインストールすることが
できます. 
<p>
もしあなたが (<htmlurl url="file://localhost/usr/ports/shells/bash" 
name="あなたの FreeBSD システム"> または 
<htmlurl url="ftp://www.freebsd.org/pub/FreeBSD/ports/shells/bash" 
name="FTP サイト"> にある) ports スケルトンを見ていて, そこに潜んでいる
あらゆる種類の先端的なロケット工学的なものを見つけられると期待していると, 
つまらなそうなファイルやディレクトリがそこにあるだけなのを見て, 
がっかりするかもしれません. 
 (ports を手に入れる方法については, すぐに <ref id="ports:getting" 
name="FreeBSD ports コレクションの入手方法"> の節でお話します.) 

<p>「一体どうしたらいいんだ? ここにはソースコードが全然ないじゃないか?」
というあなたの叫びが聞こえるようです. 

<p> 心配いりません. おとなしく読んでいけば, すべてが (たぶん) 明らかに
なるでしょう. 
試しに ports をインストールして, 何が起きるのかを見てみましょう. 
かなり典型的な例だと思いますので, ここでは `bash' (Bourne-Again Shell として
知られています) を選びます. 

<em>Note</em> 自宅で試してみる場合には, root になる必要があるでしょう. 

<verb>
 # cd /usr/ports/shells/bash
 # make install
 Checksums OK.
 ===>  Extracting for bash-1.14.5
 ===>  Patching for bash-1.14.5
 ===>  Applying FreeBSD patches for bash-1.14.5
 ===>  Configuring for bash-1.14.5
 ===>  Building for bash-1.14.5
 [とてもとても大量のメッセージをコンパイラが出力します...]
 ===>  Installing for bash-1.14.5
 make -f bash-Makefile    bindir=/usr/local/bin  prefix=/usr/local install
 (cd ./documentation/; make  )
 rm -f builtins.txt
 nroff -man builtins.1 > builtins.txt
 install -c -o bin -g bin -m 555 bash /usr/local/bin/bash
 install -c -o bin -g bin -m 555 bashbug /usr/local/bin/bashbug
 ( cd ./documentation/ ; make   mandir=/usr/local/man/man1 man3dir=/usr/local/man/man3 
infodir=/usr/local/info install )
 [ -d /usr/local/man/man1 ] || mkdir /usr/local/man/man1
 [ -d /usr/local/info ] || mkdir /usr/local/info
 ../support/install.sh -c -m 644 bash.1 /usr/local/man/man1
 ../support/install.sh -c -m 644 builtins.1 /usr/local/man/man1/bash_builtins.1
 ../support/install.sh -c -m 644 features.info /usr/local/info/bash.info
 gzip -9nf /usr/local/man/man1/bash.1 /usr/local/man/man1/bash_builtins.1
 ===>  Registering installation for bash-1.14.5
</verb>

<p> ここではあなたが混乱しないように, コンパイル時とインストール時の出力を
多少省略してあります. もしもあなた自身で実行されたら, 最初にこのような
出力結果を得るはずです:-

<label id="ports:fetch">
<verb>
 >> bash-1.14.5.tar.gz doesn't seem to exist on this system.
 >> Attempting to fetch from ftp://slc2.ins.cwru.edu/pub/dist/.
</verb>

<p> `make' プログラムは, あなたの手元にソースコードがないことを検出し, 
処理を続けられるようにソースを FTP でダウンロードしようとします. 
 (結構すごいとは思いませんか? 8-)) 
この例では, あらかじめ手動でソースコードを用意してあったので, 
持ってくる必要はありませんでした. 

<p>  では, 続けて `make' プログラムが何をしているのか見てみましょう. 

<enum>
<item> ソースコード <ref id="ports:tarball" name="tarball"> のありかを
確認します. 
手元にファイルが存在しなければ, FTP サイトから入手しようとします. 

<item><ref id="ports:checksum" name="チェックサム"> テストを実行して, 
その tarball が事故か何かで途中で切れていたり, 転送中にニュートリノに
よって傷められたりして改変されたりしていないかどうかを確認します. 

<item>tarball を一時的な作業用ディレクトリに展開します. 

<item>FreeBSD 上でコンパイルしたり, 動作させるのに必要な
すべての <ref id="ports:patch" name="パッチ"> をソースコードに当てます. 

<item> 構築のために必要なコンフィグレーションスクリプトを実行します. 
コンフィグレーションスクリプトの質問には正確に答えてください. 

<item> (いよいよ!) ソースコードをコンパイルします. 

<item> 実行形式のプログラム, マニュアル, その他のサポートファイルを, 
システムのプログラムと混ざってしまわないように /usr/local 以下に
インストールします. ports はすべて同じ場所にインストールされ, 
システムのあちこちにばらまかれることはありません. 

<item> インストール結果はデータベースに登録されます. これにより, 
インストールしたプログラムがもしも気に入らなかったときも, システムから
すべての痕跡をきれいに <ref id="ports:remove" name="消去"> することができます. 

</enum>

<p> 以上のステップが make の出力と一致するかどうか確認してください. 
今まで確認していなかったのなら, 今からするようにしてください! 

<sect1><heading>FreeBSD ports コレクションの入手 <label id="ports:getting"></heading>
<p>
あるプログラムの FreeBSD port を入手するには二つの方法があります. 
ひとつは <ref id="ports:cd" name="FreeBSD CD-ROM"> を使う方法で, 
もうひとつは <ref id="ports:inet"name="インターネット接続"> を使う方法です. 

<sect2><heading>CD-ROM からコンパイルする <label id="ports:cd"></heading>
<p>
FreeBSD をインストールしたときに, ``Do you want to link the ports 
collection to your CDROM'' という質問に yes と答えていたら, 
初期設定は既に終わっています. 
<p>
そうでない場合は, <em /FreeBSD/ CD-ROM がドライブに入っており, 
/cdrom にマウントされていることを確かめてください. 
そして次のコマンドを実行すると, 

<verb>
 # mkdir /usr/ports
 # cd /usr/ports
 # ln -s /cdrom/ports/distfiles distfiles
</verb>

ports の make メカニズムが tarball を見つけることができるようになります. 
 (ports は /usr/ports/distfiles に tarball があることを期待していますので, 
そこから CD-ROM の tarball ディレクトリにシンボリックリンクを張ったのです.) 
<p>
さて, データベースディレクトリから gnats プログラムをインストールしようと
しているとします. 方法は次のとおりです:-

<verb>
 # cd /usr/ports
 # mkdir databases
 # cp -R /cdrom/ports/databases/gnats databases
 # cd databases/gnats
 # make install
</verb>

もしもあなたがまじめなデータベースユーザであって, ports コレクションの中の
すべてのデータベースを比較したいと思っているならば, 次のようにしてください. 

<verb>
 # cd /usr/ports
 # cp -R /cdrom/ports/databases .
 # cd databases
 # make install
</verb>

 (cp コマンドの最後のドットはドットそのものであって, もちろんタイプミスでは
ありません. Unix でドットは現在自分自身がいるカレントディレクトリを
意味しています.) 
<p>
ports make メカニズムは, データベースディレクトリのすべての ports を
自動的にコンパイルし, インストールをおこなってくれます. 
<p>
この方法が気に入らない場合は, まったく違うやり方もあります:-
<p>
<em>XFree86</em> の配布に含まれる <tt>lndir(1)</tt> コマンドを使用して
「リンクツリー」を作ります. ディスクの空き領域を見つけてディレクトリを作成し, 
<tt>/usr/ports</tt> からそのディレクトリへシンボリックリンクを張ります. 
そして CD-ROM 上の ``ports'' ディレクトリのフルパス名を引数として 
<tt>lndir(1)</tt> コマンドを実行します. 
 (例えば <tt>lndir /cdrom/ports</tt> のように:) 
そして, 作成したリンクツリーの中で ports を構築することで, CD-ROM から
直接 ports を構築することができます. 
<p>
ライセンスの制限により, いくつかの ports でオリジナルのソースコードを 
CD-ROM に入れることができなかったものがあることに注意してください. この場合, 
<ref id="ports:inet" name="インターネット経由で ports をコンパイルする"> の
節を参照してください. 

<sect2><heading> インターネット経由で ports をコンパイルする <label id="ports:inet"></heading>
<p>
CD-ROM を持っていなかったり, その ports の最新バージョンを確実に入手したい
場合は, その ports の <ref id="ports:skeleton" name="スケルトン"> を
ダウンロードする必要があります. 
ところで, これは落し穴 (誤ってパッチを pkg サブディレクトリに
ダウンロードしてしまうような失敗) が
たくさんある作業に見えるかもしれませんが, 実際には非常に簡単です. 
<p>
ここで鍵になるのは, FreeBSD の FTP サイトが
その場で <ref id="ports:tarball" name="tarball"> を作成できるということです. 
どのように動作するのか, ここでは例として databases ディレクトリにある 
gnats プログラムを使って説明します. (角型かっこの中の文はコメントなので, 
実際に実行する場合には, これをタイプしないでください!):-

<verb>
 # cd /usr/ports
 # mkdir databases
 # cd databases
 # ftp ftp.freebsd.org
 [ユーザ名 `ftp' でログインし, パスワードを要求されたら, あなたの電子メール
アドレスを入力してください. バイナリモードを (イメージモードと呼ばれることも
あります) 使うのをお忘れなく!] 
 > cd /pub/FreeBSD/ports/databases
 > get gnats.tar.gz		[gnats スケルトンの tarballs を取得] 
 > quit
 # tar xzf gnats.tar.gz		[gnats スケルトンの展開]
 # cd gnats
 # make install			[gnats の構築とインストール]
</verb>

さて何が起きるでしょうか? FTP サイトにいつも通りに接続して, データベースの
サブディレクトリに移動します. `get gnats.tar.gz' とコマンドを入力すると, 
FTP サイトでは gnats ディレクトリを <ref id="ports:tarball" 
name="tarball"> にして, 送信する前に圧縮までしてくれるのです. 
ですから, 圧縮をおこなわない場合よりも多少速く手に入ることでしょう. 
<p>
gnats スケルトンを展開したら, gnats ディレクトリへ移動して ports を構築します. 
<ref id="ports:fetch" name="すでに"> 説明したように, make の過程で
手元にソースコードがないことを検出すると, ソースコードを取得してから
展開し, パッチ当てと構築をおこないます. 
<p>
それでは, 少し冒険をしてみましょう. 一つの ports スケルトンを
取得するかわりに, たとえば ports コレクションの中のデータベースの
スケルトンをすべて, サブディレクトリ全体を取得してみましょう. 
やり方はほとんど同じです:-

<verb>
 # cd /usr/ports
 # ftp ftp.freebsd.org
 [ユーザ名 `ftp' でログインし, パスワードを要求されたら, あなたの電子メール
アドレスを入力してください. バイナリモードを (イメージモードと呼ばれることも
あります) 使うのをお忘れなく!] 
 > cd /pub/FreeBSD/ports
 > get databases.tar.gz		[データベースディレクトリの tarballs を取得] 
 > quit
 # tar xzf databases.tar.gz	[すべてのスケルトンを展開] 
 # cd databases
 # make install			[データベース ports 全部の構築とインストール] 
</verb>

わずかばかりの簡単なコマンドで, この FreeBSD マシン上にデータベース
プログラムを一揃い手に入れてしまいました! 一つの ports スケルトンを取ってきて
それを構築する場合との違いは, すべてのディレクトリを一度に取得して, 
全部を一度にコンパイルしたということだけです. かなり感動的だと思いませんか? 
<p>
もし一つや二つの ports だけでなく, もっと多くの ports をインストールする
つもりなら, おそらくすべての ports ディレクトリをダウンロードしておく
価値があるでしょう. これは, 圧縮されていれば 2〜3 MB 程度の大きさです. 
しかし, distfiles ディレクトリの下にあるファイルも一緒にダウンロードする
つもりがないのなら, 調子に乗って `get ports.tar.gz' とタイプしてはいけません. 
distfiles ディレクトリには, ほとんどすべての ports のソースコードが
置かれているので, すべてをダウンロードするには非常に長い時間がかかるでしょう! 

<sect1><heading> スケルトン <label id="ports:skeleton"></heading>
<p>
スケルトン (訳注: skeleton とは骸骨のことです) とは, 締め切りを守るため, 
食事をするのを忘れるほど仕事にのめり込んだハッカーたちのなれの果ての
ことでしょうか? FreeBSD の屋根裏に潜む, なにか気持ちの悪いものでしょうか? 
いいえ, ここでスケルトンの意味するところは, ports の魔術を実現するのに
必要とされるすべてのものを提供する最小の骨組みのことです. 

<sect2><heading>Makefile<label id="ports:makefile"></heading>
<p>
スケルトンのもっとも重要な要素は Makefile です. Makefile は ports を
どのようにコンパイルし, インストールをおこなうかを指示する
いろいろな命令を含んでいます. 以下に bash の Makefile を示します:-

<verb>
 # New ports collection makefile for:	bash
 # Version required:     1.14.5
 # Date created:		21 August 1994
 # Whom:			jkh
 #
 # Makefile,v 1.13 1995/10/04 14:45:01 asami Exp
 #
 
 DISTNAME=       bash-1.14.5
 CATEGORIES=     shells
 MASTER_SITES=   ftp://slc2.ins.cwru.edu/pub/dist/
 
 MAINTAINER=     ache@FreeBSD.ORG
 
 post-install:
 .if !defined(NOMANCOMPRESS)
	 gzip -9nf ${PREFIX}/man/man1/bash.1 ${PREFIX}/man/man1/bash_builtins.1
 .endif
 
 .include &lt;bsd.port.mk>
</verb>

&quot;#&quot; で始まる行は, 人間のためのコメント行です. 
 (ほとんどの Unix のスクリプトと同じですね.) 
<p>
`DISTNAME&quot; は <ref id="ports:tarball" name="tarball">
の名前から拡張子を取ったものです. 
<p>
`CATEGORIES&quot; はこのプログラムの種類を示します. 
<p>
`MASTER_SITES&quot; はマスタ FTP サイトの URL です. もしローカルシステムに 
<ref id="ports:tarball" name="tarball"> がない場合には, ここから取得します. 
これは信頼できると考えられているサイトで, 通常はそのプログラムを
インターネット上で公式に配布しているサイトです. 
 (そのソフトウェアがインターネット上で「公式に」配布されているとしたら) 
<p>
`MAINTAINER&quot; は, 例えば新しいバージョンのプログラムが出た場合に, 
必要であればスケルトンの更新をおこなう保守担当者の電子メールアドレスです. 
 (注: 「保守担当者」というのは, スケルトンの管理者という意味であって, 
プログラムのサポートをおこなう責任は <em /負っていません/. 
もし <ref id="ports:kaput" name="ports の不具合"> を見つけた場合には, 
電子メールは &a.ports; に送ってください. 
保守担当者には <em /送らないで/ ください. よろしく!)
<p>
次の数行はとりあえず飛ばします. 
<verb>
 .include <bsd.port.mk> 
</verb>
この行は, この ports に必要なその他の命令やコマンドは `bsd.port.mk&quot; に
入っているということです. すべての ports で同じものなので, すべての Makefile に
書いておく必要はありません. そのため単一の標準ファイルにまとめられています. 
<p>
ここでは Makefile がどう働くかを詳細に調査するのが目的ではありませんので, 
`post-install&quot; で始まる行は, bsd.port.mk に書かれている, プログラムを
インストールした後での処理を置き換えていて, 最終的な場所に man ページを
置いた後で圧縮するように指示している, と言っておくだけで充分でしょう. 

<sect2><heading>files ディレクトリ </heading>
<p>
ports のチェックサム算出には MD5 アルゴリズムを使用しているので, 
この <ref id="ports:checksum" name="チェックサム"> を含んでいる
ファイルは  &quot;md5&quot; と呼ばれます. 
ちょっと混乱するかもしれませんが, このファイルは &quot;files&quot; という
名前のディレクトリに置かれています. 
<p>
このディレクトリは, ports に必要だけれども, 他のどこにも属さない
雑多なファイルも含んでいます. 

<sect2><heading>patches ディレクトリ </heading>
<p>
このディレクトリには, FreeBSD ですべてを正常に動作させるのに
必要な <ref id="ports:patch" name="パッチ"> が含まれています. 

<sect2><heading>pkg ディレクトリ </heading>
<p>
このディレクトリには, 非常に役立つ三つのファイルが含まれています:-
<itemize>
<item>
COMMENT - プログラムについての 1 行の説明. 

<item>
DESCR - より詳細な説明. 

<item>
PLIST - プログラムのインストール時に作成される, すべてのファイルのリスト. 
</itemize>

<sect1><heading> あれ? 動かない!?<label id="ports:kaput"></heading>

<p>おやおや. では, 次の四つのどれかをやってみてください:

<enum>
<item> 自分で修正する. 技術的な詳細については, 
   <ref id="porting" name="アプリケーションの移殖方法">をご覧ください. 

<item> 苦情をいう. これは電子メールで * だけ * にしてください! 
   Walnut Creekの人たちは, FreeBSD システムの機能 (あるいは欠陥) について, 
   いっさい責任がありません. 
   ほとんどサードパーティの貢献による ports システムなどは特にそうです. 
    (これが信じられないならば, Walnut Creek のカタログをチェックしてください. 
   「このプロダクトに関するテクニカルサポートを提供することができません」と
   明記してあります.) 

   電子メールのアドレスは &a.ports; です. あなたがどこから ports の
   ソースコードや配布ファイルを入手したのか, どんなエラーが発生したのかなど, 
   詳細を記述してください. 

   注: 執筆当時, lang/Sather は Pentium マシンでは, Intel の呪い
   (別名, 浮動小数点除算バグ) のために動作しません. 私たちは
   これについては関知しません. 苦情をいうなら Intel にどうぞ. 
   これは彼らのバグなのですから! 

<item> 忘れてしまう. これはほとんどの場合最も簡単な方法です. 
   ports のプログラムのうち必要不可欠な物はごくわずかです. 

<item> FTP サイトからコンパイル済みのパッケージを入手する. 
   マスターパッケージコレクションは FreeBSD の FTP サイトの
   <htmlurl url="ftp://ftp.FreeBSD.org/pub/FreeBSD/packages/" 
   name="パッケージディレクトリ"> に置いてありますが, 
   まずあなたの近くのローカルミラーサイトを確認してください! 

   ソースからコンパイルに挑戦するよりパッケージを使ったほうが, 
   (ほとんど全部が) ずっと確実に動作するでしょうし, 
   より手っ取り早い方法でもあります. 
   プログラムをシステムにインストールするには, <tt>pkg_add(1)</tt> 
を使ってください. 

</enum>

<sect1><heading>ports 化したいプログラムがあるのですが...</heading>

<p> すばらしい!具体的なやり方については
<ref id="porting:starting" name="ガイドライン"> に, 詳細な手順がありますので
ご覧ください. 

<sect1><heading> 質問と回答集 </heading>
<p>
<itemize>
<item>
Q. 私はモデムについての議論をしているのかと思っていました??! 
<p>
A.なるほど, あなたはきっとコンピュータの背面についている
シリアルポートのことだと思ってしまったのでしょう. 
あるバージョンの Unixから別のバージョンの Unix へとプログラムを
移殖することを `porting' というのですが, ここで我たちは `porting' の結果
という意味で `port' を使っています. 
(コンピュータに関わる人々の悪しき習慣として, ひとつの同じ言葉を複数の
まったく違う意味として使うことがあるのです.) 

<item>
Q. 私は, 標準以外のプログラムのインストールには packages を使うと
思っていたのですが. 
<p>
A. そのとおり. 通常は packages が最も手早くて簡単な方法です. 

<item>
Q. それではどうして面倒な ports があるのですか? 
<p>
A. いくつかの理由があります:-

<enum>
<item> いくつかのソフトウェアのライセンス条件には, 
バイナリではなくソースコードでの配布を求めているものがあります. 

<item> バイナリ配布を信用していない人もいます. 少なくともソースコード
があれば, ソースコードを読んで, (理論的には) 潜在的な問題点を自分で
見つけ出すこともできるはずです. 

<item> ローカルなパッチを入手した場合, それを自分で追加するために
ソースコードが必要になります. 

<item> プログラムがいかにコンパイルされるべきかについて, 
あなたはパッケージを作った人とは異なる見解を持っているかもしれません. 
どんな最適化オプションをつけるべきかとか, デバッグバージョンを作ってから
それを strip するべきだとか, いや, そうするべきでない, などなど, 
確固たる見解を持っている人もいるでしょう. 

<item> ソースコードを手元に置いておきたい人たちもいます. 
彼らは, 退屈したときに眺めたり, あちこち解析してみたり, ソースコードを
借用したり (もちろん, ライセンスが許せばの話ですが) するのです. 

<item> あなたがソースコードを持っていなければ, それはソフトウェアとは
言えませんね! ;-)
</enum>

<item><label id="ports:patch">
Q. パッチとは何ですか? 
<p>
A. パッチとは, あるバージョンから他のバージョンへどのように変更するかを
示す, (通常は) 小さなファイルです. 「23 行目を削除」, 「468 行目の後に
これらの 2 行を追加」, または「197 行目をこのように変更」というような
内容を含んでいます. 
これは, `diff' という名前のプログラムで生成されます. 

<item><label id="ports:tarball">
Q. tarball とは一体何ですか? 
<p>
A. .tar.gz という拡張子を持つファイルです. ( .tar.Z のようなバリエーションも
ありますし, DOS のファイルシステム用に .tgz と短縮される場合もあります.) 
<p>
これは基本的に, 一つのファイルに固めて (.tar) 圧縮した (.gz) ディレクトリ
ツリーです. 
これは元々 <em /T/ape <em /AR/chives (訳注: テープアーカイブ) 
 (このため `tar' という名前なのです) で使われていたものなのですが, 
インターネット上でプログラムのソースコードを配布するために
広く使われている方法です. 
<p>
これらのファイルの中身を見たり, 展開したりすることもできます. 
FreeBSD の基本システムに付属する Unix 標準の tar コマンドを使ってみると
次のようになります:-

<verb>
 tar tvzf foobar.tar.gz		# foobar.tar.gz の内容を見る
 tar xzvf foobar.tar.gz		# カレントディレクトリに内容を展開する
</verb>

<item><label id="ports:checksum">
Q. チェックサムとは何ですか? 
<p>
A. これは, チェックしたいファイル中のすべてのデータを加えて生成した
数値です. 何か文字が書き換わっていたら, チェックサムが一致しなくなります. 
そのため, 単純な比較だけで違いを見つけることができるのです. 
 (実際には, 文字の位置が入れ替わるなどの, 単純な加算ではわからない問題も
見つけることができる複雑な方法で計算されています.) 

<item>
Q. 私は, <ref id="ports:cd" name="CD-ROM から ports をコンパイルする">
にしたがって ports をインストールしていました. 
kermit をインストールしようとするまではうまくいっていました:-

<verb>
 # make install
 >> cku190.tar.gz doesn't seem to exist on this system.
 >> Attempting to fetch from ftp://kermit.columbia.edu/kermit/archives/.
</verb>

なぜ cku190.tar.gz が見つからないのでしょうか? 
不良品の CD-ROM を買ってしまったのでしょうか? 
<p>
A. Kermit の権利を持つチームは, 私たちの CDROM に kermit の tarball を
入れることを許可しませんでした. 申し分けありませんが, 手動でファイルを
入手してください. 
このようなエラーメッセージが出たのは, あなたがそのときインターネットに
接続していなかったためです. あらかじめ上記のサイトのいずれかからファイルを
ダウンロードしておけば, プロセスを再開することができます. 
 (ダウンロードの際には, あなたに最も近いサイトを選ぶようにしてください. 
そうすれば, 時間とインターネットの帯域の節約になります) 

<item>
Q. kermit の tarball を入手しましたが, /usr/ports/distfiles に
ファイルを置こうとすると, 書き込み権がないというエラーがでます. 
<p>
A. ports のしくみは /usr/ports/distfiles から tarball を探します. 
しかし, これは read-only の CD-ROM へのシンボリックリンクなので, 
ここにファイルを置くことはできません. 
次のようにすれば, 他の場所を探すよう ports に指示することができます. 
<verb>
 DISTDIR=/where/you/put/it make install
</verb>

<item>
Q. ports では, すべてを /usr/ports に置いたときだけ動作するのでしょうか? 
システムの管理者によると, 私の個人的なファイルは
/u/people/guests/wurzburger に入れなければならないのですが, 
これでは うまくいかないように思います. 
<p>
A. PORTSDIR 変数と PREFIX 変数を変更することで, 違うディレクトリを
使用することができます. 例えば, 

<verb>
 PORTSDIR=/u/people/guests/wurzburger/ports make install
</verb>

とすると, ports は /u/people/guests/wurzburger/ports でコンパイルされ, 
すべて /usr/local 以下にインストールされます. 

<verb> 
 PREFIX=/u/people/guests/wurzburger/local make install
</verb>
 
この場合, コンパイルは /usr/ports でおこない, 
/u/people/guests/wurzburger/local にインストールします. 
もちろん, 以下のように両者を組み合わせることも可能です. 

<verb>
 PORTSDIR=.../ports PREFIX=.../local make install
</verb>

 (省略せずに記述したら, このページに収めるには長すぎるのですが, 
考え方は理解していただけたと思います)
<p>
もし ports をインストールするたびに, これらを毎回タイプするのが
気に入らないのであれば, (正直に言って, 誰もそう思わないでしょう) 
これらを環境変数にセットしてしまうという手があります. 

<item>
Q. 私は, FreeBSD の CD-ROM を持っていませんが, 私はすべての tarball を
私のシステムに置いておきたいのです. そうすれば, 私は ports をインストール
するたびに, 毎回ダウンロードが終わるのを待たなくてすむでしょう. 
これを一度におこなう簡単な方法はありませんか? 

<p>
A. ports コレクション全体の tarball を持ってくるには, 次のようにしてください. 

<verb>
 # cd /usr/ports
 # make fetch
</verb>

ports の下のディレクトリひとつの tarball を持ってくるには, 次のように
してください. 

<verb>
 # cd /usr/ports/directory
 # make fetch
</verb>

ports をひとつだけ持ってくる方法は, きっと既にご存知だと思います. 

<item>
Q. マスタ FTP サイトから tarball を持ってくるより, 近くにある FreeBSD の
ミラーサイトから持ってきた方が速いはずです. MASTER_SITES に書かれている
サイト以外から持ってくるように ports に指示する方法はありませんか? 
<p>
A. もちろんあります. 例えば ftp.FreeBSD.ORG が MASTER_SITES に書かれている
サイトより近いとしたら, 以下のようにしてください. 
<verb>
 # cd /usr/ports/directory
 # make MASTER_SITE_OVERRIDE=ftp://ftp.FreeBSD.ORG/pub/FreeBSD/distfiles/ fetch
</verb>

<item>
Q. ダウンロードをする前に, どんなファイルが必要なのか知りたいのですが. 
<p>
A. 'make fetch-list' とすると, ports に必要なファイルの一覧を表示できます. 

<item>
Q. ports のコンパイルを途中で止める方法はありますか? 
私はインストールをする前にいろいろとソースコードを解析したいのですが, 
毎回 control-C を打たなければならないのが少し面倒です. 
<p>
A. 'make extract' を実行すると, ファイル転送とソースコードの展開まで
おこなったところで停止します. 

<item>
Q. 自分で ports を作ろうとしています. 私の作ったパッチが
正しく処理できることを確認できるように, コンパイルを止めたいのです. 
パッチのための 'make extract' のようなものはありませんか? 
<p>
A. あります. 'make patch' があなたのお望みのものです. 
ところで, あなたの努力に感謝いたします!! 

<item>
Q. あるコンパイルオプションはバグの原因になるという話を聞きました. 
本当なのでしょうか? どうやったら正しい設定で ports をコンパイルできますか? 
<p>
A. 本当です. gcc の バージョン 2.6.3 (FreeBSDの 2.1.0 と 2.1.5 に付属している
バージョン) では, -O2 オプションを -fno-strength-reduce オプションなしで
使うと, バグのあるコードを出力します (ほとんどの ports は -O2 オプションを
使いません). コンバイラオプションは次のように定義 <em/ すべき / です. 

<verb>
 # CFLAGS='-O2 -fno-strength-reduce' make install
</verb>

/etc/make.conf を編集することもできますが, すべての場合でこれが反映される
訳ではありません. もっとも確実なのは 'make configure' を実行し, 
ソースディレクトリの Makefile を見て手で修整することですが, ソースが
多くのサブディレクトリにわかれていて, 各々に Makefile がある場合は
大変な仕事になります. 

<item>
Q. ports がたくさんありすぎて, 私の欲しいものがなかなか見つけられません. 
どんな ports が使えるのか, リストはどこかにありませんか? 
<p>
A. INDEX ファイルは /usr/ports の中にあります. 

<item>
Q. 'foo' ports をインストールしたいのですが, それはすぐに停止して, 
'bar' ports のコンパイルが始まってしまいます. 一体どうして? 
<p>
A. 'foo' ports が, 'bar' ports の提供する何らかの機能を必要としているからです. 
例えば 'foo' が画像を使うとすると, 'bar' は画像処理に必要な
ライブラリを持っている, などです. 
または, 'bar' は 'foo' をコンパイルするのに必要なツールなのかもしれません. 

<item><label id="ports:remove"> 
Q. ports から grizzle プログラムをインストールしましたが, まったく
ディスクスペースの浪費です. 削除したいのですが, すべてのファイルが
どこへインストールされたのかわかりません. 何か手がかりはありませんか? 
<p>
A. 大丈夫, 次のようにしてください. 

<verb>
 pkg_delete grizzle-6.5
</verb>
<item>

Q. ちょっと待ってください. 削除しようとするコマンドのバージョン番号を
知っていなくてはならないのでしょうか? あなたは, 私がバージョン番号を
覚えていることを本気で当てにしているのでしょうか? 
<p>
A. そんなことはありません. バージョン番号は次のようにすればわかります. 

<verb>
 pkg_info -a | grep grizzle
</verb>

そうすると次のように表示されます:-

<verb>
 Information for grizzle-6.5:
 grizzle-6.5 - the combined piano tutorial, LOGO interpreter and shoot 'em up arcade game.
</verb>

<item>
Q. ディスク容量のことなのですが, ports のディレクトリは非常に膨大な容量を
使うように見えます. 残しておいた方がよいのでしょうか? 削除してしまっても
よいのでしょうか? 

<p>
A. はい. インストールが首尾よく終わり, もうソースコードが必要でないと思うなら, 
それらを残しておく理由はないでしょう. 一番よい方法は, 次の通りです. 

<verb>
 # cd /usr/ports
 # make clean
</verb>

これは, すべての ports のサブディレクトリを調べ, 
各 ports のスケルトン以外の削除をおこないます. 

<item>
Q. これを試してみたのですが, tarball や ports で使われたファイルが 
distfiles ディレクトリに残っています. これも削除してしまっても大丈夫ですか? 
<p>
A.  はい. それを使った作業が終わったのであれば, 削除してしまっても大丈夫です. 

<item>
Q. 私はとてもとてもたくさんのプログラムを楽しみたいのです. 
一度にすべての ports をインストールする方法はありませんか? 
<p>
A. 次のようにしてください. 

<verb>
 # cd /usr/ports
 # make install
</verb>

<item>
Q. やってみました. 時間がとてもかかるだろうと思ったので, そのまま実行を
続けさせて, 私は寝ました. 翌朝コンピュータを見てみると, 三つ半の ports しか
処理が終わっていませんでした. なにか悪かったのでしょうか? 
<p>
A. これは ports の中には私たちの決められないこと (例えば, あなたが A4 の
用紙に印刷したいのか, US レターサイズの用紙に印刷したいのかなど) について
質問してくるものがあるからです. それらの質問には手動で答える必要があります. 

<item>
Q.  私は一日中モニタの前に座って過ごしたりしたくないのですが. 
何かよいアイデアはありませんか? 
<p>
A. では, あなたが寝に / 仕事に / 公園にいく前に以下を実行してください:-

<verb>
 # cd /usr/ports
 # make -DBATCH install
</verb>

これでユーザの入力を要求しないすべての ports をインストールします. 
そして, 戻ってきてから, 次のように実行してください. 

<verb>
 # cd /usr/ports
 # make -DIS_INTERACTIVE install
</verb>

そして, 残りの作業を実行してください. 

<item>
Q. 私たちは ports コレクションにある frobble を使っています. 
ですが, 私たちの必要に応じて ports を変更したところがあるのです. 
自分でパッケージを作って, それを私たちのサイトのまわりに
簡単に配布できるような方法がありますか? 
<p>
A. もちろんあります. 変更点をパッチにする方法は知っていますよね:-

<verb>
 # cd /usr/ports/somewhere/frobble
 # make extract
 # cd work/frobble-2.8
 [あなたのパッチを当ててください]
 # cd ../..
 # make package
</verb>

<item>
Q. この ports の技術は本当に賢いですね. どのようにして動いているのか
私はどうしても知りたいと思います. その秘密は何ですか? 
<p>
A. 秘密は一切ありません. 
<htmlurl url="file://localhost/usr/share/mk/" name="Makefiles ディレクトリ">
にある bsd.ports.mk と bsd.ports.subdir.mk ファイルを見るだけです. 
 (注: 複雑なシェルスクリプトを嫌う読者は, このリンクを追いかけないほうが
よいでしょう.) 
</itemize>
