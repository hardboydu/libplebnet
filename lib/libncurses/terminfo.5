.\" Note: this must be run through tbl befor nroff
.TH TERMINFO 5
.ds n 5
.ds d /usr/lib/terminfo
.SH NAME
terminfo \- terminal capability data base
.SH SYNOPSIS
\*d/*/*
.SH DESCRIPTION
.I Terminfo
is a data base describing terminals, used by screen-oriented programs such as
.IR vi (1),
.IR rogue (1)
and
.IR ncurses (3).
.I Terminfo
describes terminals by giving a set of capabilities which they
have, by specifying how to perform screen operations, and by
specifying padding requirements and initialization sequences.
.PP
Entries in
.I terminfo
consist of a number of `,' separated fields.
White space after each `,' is ignored.
The first entry for each terminal gives the names which are known for the
terminal, separated by `|' characters.
The first name given is the most common abbreviation for the terminal,
the last name given should be a long name fully identifying the terminal,
and all others are understood as synonyms for the terminal name.
All names but the last should be in lower case and contain no blanks;
the last name may well contain upper case and blanks for readability.
.PP
Terminal names (except for the last, verbose entry) should
be chosen using the following conventions.
The particular piece of hardware making up the terminal should
have a root name chosen, thus ``hp2621''.
This name should not contain hyphens, except that synonyms may
be chosen that do not conflict with other names.
Modes that the hardware can be in, or user preferences, should
be indicated by appending a hyphen and an indicator of the mode.
Thus, a vt100 in 132 column mode would be vt100-w.
The following suffixes should be used where possible:
.TS
center;
l c l
l l l.
\fBSuffix	Meaning	Example\fP
-w	Wide mode (more than 80 columns)	vt100-w
-am	With auto. margins (usually default)	vt100-am
-nam	Without automatic margins	vt100-nam
-\fIn\fP	Number of lines on the screen	aaa-60
-na	No arrow keys (leave them in local)	c100-na
-\fIn\fPp	Number of pages of memory	c100-4p
-rv	Reverse video	c100-rv
.TE
.SH CAPABILITIES
The variable is the name by which the programmer (at the terminfo level)
accesses the capability.
The capname is the short name used in the text of the database,
and is used by a person updating the database.
The i.code is the two letter internal code used in the compiled database,
and always corresponds to the old
.B termcap
capability name.
.P
Capability names have no hard length limit, but an informal limit of 5
characters has been adopted to keep them short and to allow the tabs in
the source file
.B caps
to line up nicely.
Whenever possible, names are chosen to be the same as or similar to
the ANSI X3.64-1979 standard.  Semantics are also intended to match
those of the specification.
.TP
(P)
indicates that padding may be specified
.TP
(G)
indicates that the string is passed through tparm with
parms as given (#\fIi\fP).
.TP
(*)
indicates that padding may be based on the number of
lines affected
.TP
(#\d\fIi\fP\u)
indicates the \fIi\fP\uth\d parameter.

.TS
center;
c c c c
c c c c
l l l l.
\fBVariable	Cap-	I.	Description\fR
\f3Booleans	name	Code\fR
\s-1auto_left_margin,	bw	bw	cub1 wraps from column 0 to last 
			column\s+1
\s-1auto_right_margin,	am	am	Terminal has automatic margins\s+1
\s-1back_color_erase,	bce	ut	screen erased with background color\s+1
\s-1can_change, 	ccc	cc	terminal can re-define exiting colors\s+1
\s-1ceol_standout_glitch,	xhp	xs	Standout not erased by overwriting 
			(hp)\s+1
\s-1col_addr_glitch,	xhpa	YA	only positive motion for hpa/mhpa caps\s+1
\s-1cpi_changes_res,	cpix	YF	changing character pitch changes resolution\s+1
\s-1cr_cancels_micro_mode,	crxm	YB	using cr turns off micro mode\s+1
\s-1eat_newline_glitch,	xenl	xn	newline ignored after 80 cols 
			(Concept)\s+1
\s-1erase_overstrike,	eo	eo	Can erase overstrikes with a blank\s+1
\s-1generic_type,	gn	gn	Generic line type (e.g.,, dialup, 
			switch).\s+1
\s-1hard_copy,	hc	hc	Hardcopy terminal\s+1
\s-1hard_cursor,	chts	HC	cursor is hard to see\s+1
\s-1has_meta_key,	km	km	Has a meta key (shift, sets parity 
			bit)\s+1
\s-1has_print_wheel,	daisy	YC	printer needs operator to change character set\s+1
\s-1has_status_line,	hs	hs	Has extra "status line"\s+1
\s-1hue_lightness_saturation,	hls	hl	terminal uses only HLS color notation (tektronix)\s+1
\s-1insert_null_glitch,	in	in	Insert mode distinguishes nulls\s+1
\s-1lpi_changes_res,	lpix	YG	changing line pitch changes resolution\s+1
\s-1memory_above,	da	da	Display may be retained above the 
			screen\s+1
\s-1memory_below,	db	db	Display may be retained below the 
			screen\s+1
\s-1move_insert_mode,	mir	mi	Safe to move while in insert mode\s+1
\s-1move_standout_mode,	msgr	ms	Safe to move in standout modes\s+1
\s-1needs_xon_xoff,	nxon	nx	padding won't work, xon/xoff required\s+1
\s-1no_esc_ctl_c,	xsb	xb	Beehive (f1=escape, f2=ctrl C)\s+1
\s-1non_rev_rmcup,	nrrmc	NR	smcup does not reverse rmcup\s+1
\s-1no_pad_char,	npc	NP	pad character does not exist\s+1
\s-1non_dest_scroll_region,	ndscr	ND	scrolling region is non-destructive\s+1
\s-1over_strike,	os	os	Terminal overstrikes\s+1
\s-1prtr_silent,	mc5i	5i	printer won't echo on screen\s+1
\s-1row_addr_glitch,	xvpa	YD	only positive motion for vhp/mvpa caps\s+1
\s-1semi_auto_right_margin,	sam	YE	printing in last column causes cr\s+1
\s-1status_line_esc_ok,	eslok	es	Escape can be used on the status line\s+1
\s-1dest_tabs_magic_smso,	xt	xt	Tabs ruin, magic so char (Teleray
			1061)\s+1
\s-1tilde_glitch,	hz	hz	Hazeltine; can not print ~'s\s+1
\s-1transparent_underline,	ul	ul	underline character overstrikes\s+1
\s-1xon_xoff,	xon	xo	Terminal uses xon/xoff handshaking\s+1

\s-1\f3Numbers:\fR\s+1
\s-1bit_image_entwining,	bitwin	Yo	Undocumented in SVr4.0\s+1
\s-1buffer_capacity,	bufsz	Ya	numbers of bytes buffered before printing\s+1
\s-1columns,	cols	co	Number of columns in a line\s+1
\s-1dot_vert_spacing,	spinv	Yb	spacing of dots horizontally in dots per inch\s+1
\s-1dot_horz_spacing,	spinh	Yc	spacing of pins vertically in pins per inch\s+1
\s-1init_tabs,	it	it	Tabs initially every # spaces\s+1
\s-1label_height,	lh	lh	rows in each label\s+1
\s-1label_width,	lw	lw	columns in each label\s+1
\s-1lines,	lines	li	Number of lines on screen or page\s+1
\s-1lines_of_memory,	lm	lm	Lines of memory if > lines.  0 means varies\s+1
\s-1magic_cookie_glitch,	xmc	sg	Number of blank chars left by smso or rmso\s+1
\s-1max_colors,	colors	Co	maximum numbers of colors on screen\s+1
\s-1max_micro_address,	maddr	Yd	maximum value in micro_..._address\s+1
\s-1max_micro_jump,	mjump	Ye	maximum value in parm_..._micro\s+1
\s-1max_pairs,	pairs	pa	maximum number of color-pairs on the screen\s+1
\s-1micro_col_size,	mcs	Yf	Character step size when in micro mode\s+1
\s-1micro_line_size,	mls	Yg	Line step size when in micro mode\s+1
\s-1no_color_video,	ncv	NC	video attributes that can't be used with colors\s+1
\s-1number_of_pins,	npins	Yh	numbers of pins in print-head\s+1
\s-1num_labels,	nlab	Nl	number of labels on screen\s+1
\s-1output_res_char,	orc	Yi	horizontal resolution in units per line\s+1
\s-1output_res_line,	orl	Yj	vertical resolution in units per line\s+1
\s-1output_res_horz_inch,	orhi	Yk	horizontal resolution in units per inch\s+1
\s-1output_res_vert_inch,	orvi	Yl	vertical resolution in units per inch\s+1
\s-1padding_baud_rate,	pb	pb	Lowest baud where cr/nl padding is needed\s+1
\s-1virtual_terminal,	vt	vt	Virtual terminal number (\s-1UNIX\s+1 system)\s+1
\s-1width_status_line,	wsl	ws	No. columns in status line\s+1
.TE

(The following numeric capabilities are present in the SVr4.0 term structure,
but are not yet documented in the man page.  Comments are from the term
structure header.)

.TS
center;
c c c c
c c c c
l l l l.
\s-1bit_image_type,	bitype	Yp	Type of bit-image device\s+1
\s-1buttons,	btns	BT	Number of mouse buttons\s+1
\s-1max_attributes,	ma	ma	Max combined attributes terminal can handle\s+1
\s-1maximum_windows,	wnum	MW	Max number of definable windows\s+1
\s-1print_rate, 	cps	Ym	Print rate in chars per second\s+1
\s-1wide_char_size,	widcs	Yn	Char step size in double wide mode\s+1

\s-1\f3Strings:\fR\s+1
\s-1acs_chars,	acsc	ac	Graphics charset pairs - def=vt100\s+1
\s-1alt_scancode_esc,	scesa	S8	Alternate esc for scancode emulation (default is vt100)\s+1
\s-1back_tab,	cbt	bt	Back tab (P)\s+1
\s-1bell,	bel	bl	Audible signal (bell) (P)\s+1
\s-1bit_image_repeat,	birep	Xy	Repeat bit image cell #1 #2 times (use tparm)\s+1
\s-1bit_image_newline,	binel	Zz	Move to next row of the bit image (use tparm)\s+1
\s-1bit_image_carriage_return,	bicr	Yv	Move to beginning of same row (use tparm)\s+1
\s-1carriage_return,	cr	cr	Carriage return (P*)\s+1
\s-1change_char_pitch,	cpi	ZA	Change # chars per inch\s+1
\s-1change_line_pitch,	lpi	ZB	Change # lines per inch\s+1
\s-1change_res_horz,	chr	ZC	Change horizontal resolution\s+1
\s-1change_res_vert,	cvr	ZD	Change vertical resolution\s+1
\s-1change_scroll_region,	csr	cs	Change to lines #1 through #2 (vt100) (PG)\s+1
\s-1char_padding,	rmp	rP	Like ip but when in insert mode\s+1
\s-1char_set_names,	csnm	Zy	List of character set names\s+1
\s-1clear_all_tabs,	tbc	ct	Clear all tab stops (P)\s+1
\s-1clear_margins,	mgc	MC	Clear all margins (top, bottom, and sides)\s+1
\s-1clear_screen,	clear	cl	Clear screen and home cursor (P*)\s+1
\s-1clr_bol.	el1	cb	Clear to beginning of line\s+1
\s-1clr_eol,	el	ce	Clear to end of line (P)\s+1
\s-1clr_eos,	ed	cd	Clear to end of display (P*)\s+1
\s-1code_set_init,	csin	ci	Init sequence for multiple code sets\s+1
\s-1color_names,	colornm	Yw	Give name for color #1\s+1
\s-1column_address,	hpa	ch	Set cursor column (PG)\s+1
\s-1command_character,	cmdch	CC	Term. settable cmd char in prototype\s+1
\s-1cursor_address,	cup	cm	Screen rel. cursor motion row #1
			col #2 (PG)\s+1
\s-1cursor_down,	cud1	do	Down one line\s+1
\s-1cursor_home,	home	ho	Home cursor (if no cup)\s+1
\s-1cursor_invisible,	civis	vi	Make cursor invisible\s+1
\s-1cursor_left,	cub1	le	Move cursor left one space\s+1
\s-1cursor_mem_address,	mrcup	CM	Memory relative cursor addressing\s+1
\s-1cursor_normal,	cnorm	ve	Make cursor appear normal (undo vs/vi)\s+1
\s-1cursor_right,	cuf1	nd	Non-destructive space (cursor right)\s+1
\s-1cursor_to_ll,	ll	ll	Last line, first column (if no cup)\s+1
\s-1cursor_up,	cuu1	up	Upline (cursor up)\s+1
\s-1cursor_visible,	cvvis	vs	Make cursor very visible\s+1
\s-1define_bit_image_region,	defbi	Yx	Define rectangular bit image region (use tparm)\s+1
\s-1define_char,	defc	ZE	Define character in a character set\s+1
\s-1delete_character,	dch1	dc	Delete character (P*)\s+1
\s-1delete_line,	dl1	dl	Delete line (P*)\s+1
\s-1device_type,	devt	dv	Indicate language/codeset support\s+1
\s-1dis_status_line,	dsl	ds	Disable status line\s+1
\s-1display_pc_char,	dispc	S1	Display PC character\s+1
\s-1down_half_line,	hd	hd	Half-line down (forward 1/2 linefeed)\s+1
\s-1ena_acs,	enacs	eA	enable alternate char set\s+1
\s-1end_bit_image_region,	endbi	Yy	End bit image region (use tparm)\s+1
\s-1enter_alt_charset_mode,	smacs	as	Start alternate character set (P)\s+1
\s-1enter_am_mode,	smam	SA	turn on automatic margins\s+1
\s-1enter_blink_mode,	blink	mb	Turn on blinking\s+1
\s-1enter_bold_mode,	bold	md	Turn on bold (extra bright) mode\s+1
\s-1enter_ca_mode,	smcup	ti	String to begin programs that use cup\s+1
\s-1enter_delete_mode,	smdc	dm	Delete mode (enter)\s+1
\s-1enter_dim_mode,	dim	mh	Turn on half-bright mode\s+1
\s-1enter_doublewide_mode,	swidm	ZF	Enable double-wide mode\s+1
\s-1enter_draft_quality,	sdrfq	ZG	Set draft-quality printing\s+1
\s-1enter_insert_mode,	smir	im	Insert mode (enter);\s+1
\s-1enter_italics_mode,	sitm	ZH	Enable italics mode\s+1
\s-1enter_leftward_mode,	slm	ZI	Enable leftward carriage motion\s+1
\s-1enter_micro_mode,	smicm	ZJ	Enable micro-motion capabilities\s+1
\s-1enter_near_letter_quality,	snlq	ZK	Set NLQ printing\s+1
\s-1enter_normal_quality,	snrmq	ZL	Set normal quality printing\s+1
\s-1enter_pc_charset_mode,	smpch	S2	Enter PC character display mode\s+1
\s-1enter_protected_mode,	prot	mp	Turn on protected mode\s+1
\s-1enter_reverse_mode, 	rev	mr	Turn on reverse video mode\s+1
\s-1enter_scancode_mode,	smsc	S4	Enter PC scancode mode\s+1
\s-1enter_secure_mode,	invis	mk	Turn on blank mode (chars invisible)\s+1
\s-1enter_shadow_mode,	sshm	ZM	Enable shadow-mode printing\s+1
\s-1enter_standout_mode,	smso	so	Begin stand out mode\s+1
\s-1enter_subscript_mode,	ssubm	ZN	Enable subscript printing\s+1
\s-1enter_superscript_mode,	ssupm	ZO	Enable superscript printing\s+1
\s-1enter_underline_mode,	smul	us	Start underscore mode\s+1
\s-1enter_upward_mode,	sum	ZP	Enable upward carriage motion\s+1
\s-1enter_xon_mode,	smxon	SX	Turn on xon/xoff handshaking\s+1
\s-1erase_chars,	ech	ec	Erase #1 characters (PG)\s+1
\s-1exit_alt_charset_mode,	rmacs	ae	End alternate character set (P)\s+1
\s-1exit_am_mode,	rmam	RA	Turn off automatic margins\s+1
\s-1exit_attribute_mode,	sgr0	me	Turn off all attributes\s+1
\s-1exit_ca_mode,	rmcup	te	String to end programs that use cup\s+1
\s-1exit_delete_mode,	rmdc	ed	End delete mode\s+1
\s-1exit_doublewide_mode,	rwidm	ZQ	Disable doublewide printing\s+1
\s-1exit_insert_mode,	rmir	ei	End insert mode\s+1
\s-1exit_italics_mode,	ritm	ZR	Disable italic printing\s+1
\s-1exit_leftward_mode,	rlm	ZS	Enable rightward (normal) carriage motion\s+1
\s-1exit_micro_mode,	rmicm	ZT	Disable micro motion capabilities\s+1
\s-1exit_pc_charset_mode,	rmpch	S3	Disable PC character display\s+1
\s-1exit_scancode_mode,	rmsc	S5	Disable PC scancode mode\s+1
\s-1exit_shadow_mode,	rshm	ZU	Disable shadow printing\s+1
\s-1exit_standout_mode,	rmso	se	End stand out mode\s+1
\s-1exit_subscript_mode,	rsubm	ZV	Disable subscript printing\s+1
\s-1exit_superscript_mode,	rsupm	ZW	Disable superscript printing\s+1
\s-1exit_underline_mode,	rmul	ue	End underscore mode\s+1
\s-1exit_upward_mode,	rum	ZX	Enable downward (normal) carriage motion\s+1
\s-1exit_xon_mode,	rmxon	RX	turn off xon/xoff handshaking\s+1
\s-1flash_screen,	flash	vb	Visible bell (may not move cursor)\s+1
\s-1form_feed,	ff	ff	Hardcopy terminal page eject (P*)\s+1
\s-1from_status_line,	fsl	fs	Return from status line\s+1
\s-1init_1string,	is1	i1	Terminal initialization string\s+1
\s-1init_2string,	is2	i2	Terminal initialization string\s+1
\s-1init_3string,	is3	i3	Terminal initialization string\s+1
\s-1init_file,	if	if	Name of file containing is\s+1
\s-1init_prog,	iprog	iP	Path name of program for init\s+1
\s-1initialize_color,	initc	Ic	Initialize the definition of color\s+1
\s-1initialize_pair,	initp	Ip	Initialize color-pair\s+1
\s-1insert_character,	ich1	ic	Insert character (P)\s+1
\s-1insert_line,	il1	al	Add new blank line (P*)\s+1
\s-1insert_padding,	ip	ip	Insert pad after character inserted
			(p*)\s+1
\s-1key_a1,	ka1	K1	Upper left of keypad\s+1
\s-1key_a3,	ka3	K3	Upper right of keypad\s+1
\s-1key_b2,	kb2	K2	Center of keypad\s+1
\s-1key_backspace,	kbs	kb	Sent by backspace key\s+1
\s-1key_beg,	kbeg	@1	begin key\s+1
\s-1key_btab,	kcbt	kB	back-tab key\s+1
\s-1key_c1,	kc1	K4	Lower left of keypad\s+1
\s-1key_c3,	kc3	K5	Lower right of keypad\s+1
\s-1key_cancel,	kcan	@2	cancel key\s+1
\s-1key_catab,	ktbc	ka	Sent by clear-all-tabs key\s+1
\s-1key_clear,	kclr	kC	Sent by clear screen or erase key\s+1
\s-1key_close,	kclo	@3	close key\s+1
\s-1key_command,	kcmd	@4	command key\s+1
\s-1key_copy,	kcpy	@5	copy key\s+1
\s-1key_create,	kcrt	@6	create key\s+1
\s-1key_ctab,	kctab	kt	Sent by clear-tab key\s+1
\s-1key_dc,	kdch1	kD	Sent by delete character key\s+1
\s-1key_dl,	kdl1	kL	Sent by delete line key\s+1
\s-1key_down,	kcud1	kd	Sent by terminal down arrow key\s+1
\s-1key_eic,	krmir	kM	Sent by rmir or smir in insert mode\s+1
\s-1key_end,	kend	@7	end key\s+1
\s-1key_enter,	kent	@8	enter/send key\s+1
\s-1key_eol,	kel	kE	Sent by clear-to-end-of-line key\s+1
\s-1key_eos,	ked	kS	Sent by clear-to-end-of-screen key\s+1
\s-1key_exit,	kext	@9	exit key\s+1
\s-1key_f0,	kf0	k0	Sent by function key f0\s+1
\s-1key_f1,	kf1	k1	Sent by function key f1\s+1
\s-1key_f2,	kf2	k2	Sent by function key f2\s+1
\s-1key_f3,	kf3	k3	Sent by function key f3\s+1
\s-1key_f4,	kf4	k4	Sent by function key f4\s+1
\s-1key_f5,	kf5	k5	Sent by function key f5\s+1
\s-1key_f6,	kf6	k6	Sent by function key f6\s+1
\s-1key_f7,	kf7	k7	Sent by function key f7\s+1
\s-1key_f8,	kf8	k8	Sent by function key f8\s+1
\s-1key_f9,	kf9	k9	Sent by function key f9\s+1
\s-1key_f10,	kf10	k;	Sent by function key f10\s+1
\s-1key_f11,	kf11	F1	F11 function key\s+1
\s-1key_f12,	kf12	F2	F12 function key\s+1
\s-1key_f13,	kf13	F3	F13 function key\s+1
\s-1key_f14,	kf14	F4	F14 function key\s+1
\s-1key_f15,	kf15	F5	F15 function key\s+1
\s-1key_f16,	kf16	F6	F16 function key\s+1
\s-1key_f17,	kf17	F7	F17 function key\s+1
\s-1key_f18,	kf18	F8	F18 function key\s+1
\s-1key_f19,	kf19	F9	F19 function key\s+1
\s-1key_f20,	kf20	FA	F20 function key\s+1
\s-1key_f21,	kf21	FB	F21 function key\s+1
\s-1key_f22,	kf22	FC	F22 function key\s+1
\s-1key_f23,	kf23	FD	F23 function key\s+1
\s-1key_f24,	kf24	FE	F24 function key\s+1
\s-1key_f25,	kf25	FF	F25 function key\s+1
\s-1key_f26,	kf26	FG	F26 function key\s+1
\s-1key_f27,	kf27	FH	F27 function key\s+1
\s-1key_f28,	kf28	FI	F28 function key\s+1
\s-1key_f29,	kf29	FJ	F29 function key\s+1
\s-1key_f30,	kf30	FK	F30 function key\s+1
\s-1key_f31,	kf31	FL	F31 function key\s+1
\s-1key_f32,	kf32	FM	F32 function key\s+1
\s-1key_f33,	kf33	FN	F33 function key\s+1
\s-1key_f34,	kf34	FO	F34 function key\s+1
\s-1key_f35,	kf35	FP	F35 function key\s+1
\s-1key_f36,	kf36	FQ	F36 function key\s+1
\s-1key_f37,	kf37	FR	F37 function key\s+1
\s-1key_f38,	kf38	FS	F38 function key\s+1
\s-1key_f39,	kf39	FT	F39 function key\s+1
\s-1key_f40,	kf40	FU	F40 function key\s+1
\s-1key_f41,	kf41	FV	F41 function key\s+1
\s-1key_f42,	kf42	FW	F42 function key\s+1
\s-1key_f43,	kf43	FX	F43 function key\s+1
\s-1key_f44,	kf44	FY	F44 function key\s+1
\s-1key_f45,	kf45	FZ	F45 function key\s+1
\s-1key_f46,	kf46	Fa	F46 function key\s+1
\s-1key_f47,	kf47	Fb	F47 function key\s+1
\s-1key_f48,	kf48	Fc	F48 function key\s+1
\s-1key_f49,	kf49	Fd	F49 function key\s+1
\s-1key_f50,	kf50	Fe	F50 function key\s+1
\s-1key_f51,	kf51	Ff	F51 function key\s+1
\s-1key_f52,	kf52	Fg	F52 function key\s+1
\s-1key_f53,	kf53	Fh	F53 function key\s+1
\s-1key_f54,	kf54	Fi	F54 function key\s+1
\s-1key_f55,	kf55	Fj	F55 function key\s+1
\s-1key_f56,	kf56	Fk	F56 function key\s+1
\s-1key_f57,	kf57	Fl	F57 function key\s+1
\s-1key_f58,	kf58	Fm	F58 function key\s+1
\s-1key_f59,	kf59	Fn	F59 function key\s+1
\s-1key_f60,	kf60	Fo	F60 function key\s+1
\s-1key_f61,	kf61	Fp	F61 function key\s+1
\s-1key_f62,	kf62	Fq	F62 function key\s+1
\s-1key_f63,	kf63	Fr	F63 function key\s+1
\s-1key_find,	kfnd	@0	find key\s+1
\s-1key_help,	khlp	%1	help key\s+1
\s-1key_home,	khome	kh	Sent by home key\s+1
\s-1key_ic,	kich1	kI	Sent by ins char/enter ins mode key\s+1
\s-1key_il,	kil1	kA	Sent by insert line\s+1
\s-1key_left,	kcub1	kl	Sent by terminal left arrow key\s+1
\s-1key_ll,	kll	kH	Sent by home-down key\s+1
\s-1key_mark,	kmrk	%2	mark key\s+1
\s-1key_message,	kmsg	%3	message key\s+1
\s-1key_move,	kmov	%4	move key\s+1
\s-1key_next,	knxt	%5	next key\s+1
\s-1key_npage,	knp	kN	Sent by next-page key\s+1
\s-1key_open,	kopn	%6	open key\s+1
\s-1key_options,	kopt	%7	options key\s+1
\s-1key_ppage,	kpp	kP	Sent by previous-page key\s+1
\s-1key_previous,	kprv	%8	previous key\s+1
\s-1key_print,	kprt	%9	print key\s+1
\s-1key_redo,	krdo	%0	redo key\s+1
\s-1key_reference,	kref	&1	reference key\s+1
\s-1key_refresh,	krfr	&2	refresh key\s+1
\s-1key_replace,	krpl	&3	replace key\s+1
\s-1key_restart,	krst	&4	restart key\s+1
\s-1key_resume,	kres	&5	resume key\s+1
\s-1key_right,	kcuf1	kr	Sent by terminal right arrow key\s+1
\s-1key_save,	ksav	&6	save key\s+1
\s-1key_sbeg,	kBEG	&9	shifted begin key\s+1
\s-1key_scancel,	kCAN	&0	shifted cancel key\s+1
\s-1key_scommand,	kCMD	*1	shifted command key\s+1
\s-1key_scopy,	kCPY	*2	shifted copy key\s+1
\s-1key_screate,	kCRT	*3	shifted create key\s+1
\s-1key_sdc,	kDC	*4	shifted delete char key\s+1
\s-1key_sdl,	kDL	*5	shifted delete line key\s+1
\s-1key_select,	kslt	*6	select key\s+1
\s-1key_send,	kEND	*7	shifted end key\s+1
\s-1key_seol,	kEOL	*8	shifted end of line key\s+1
\s-1key_sexit,	kEXT	*9	shifted exit key\s+1
\s-1key_sf,	kind	kF	Sent by scroll-forward/down key\s+1
\s-1key_sfind,	kFND	*0	shifted find key\s+1
\s-1key_shelp,	kHLP	#1	shifted help key\s+1
\s-1key_shome,	kHOM	#2	shifted home key\s+1
\s-1key_sic,	kIC	#3	shifted insert char key\s+1
\s-1key_sleft,	kLFT	#4	shifted left key\s+1
\s-1key_smessage,	kMSG	%a	shifted message key\s+1
\s-1key_smove,	kMOV	%b	shifted move key\s+1
\s-1key_snext,	kNXT	%c	shifted next key\s+1
\s-1key_soptions,	kOPT	%d	shifted options key\s+1
\s-1key_sprevious,	kPRV	%e	shifted previous key\s+1
\s-1key_sprint,	kPRT	%f	shifted print key\s+1
\s-1key_sr,	kri	kR	Sent by scroll-backward/up key\s+1
\s-1key_sredo,	kRDO	%g	shifted redo key\s+1
\s-1key_sreplace,	kRPL	%h	shifted replace key\s+1
\s-1key_sright,	kRIT	%i	shifted right key\s+1
\s-1key_srsume,	kRES	%j	shifted resume key\s+1
\s-1key_ssave,	kSAV	!1	shifted save key\s+1
\s-1key_ssuspend,	kSPD	!2	shifted suspend key\s+1
\s-1key_stab,	khts	kT	Sent by set-tab key\s+1
\s-1key_sundo,	kUND	!3	shifted undo key\s+1
\s-1key_suspend,	kspd	&7	suspend key\s+1
\s-1key_undo,	kund	&8	undo key\s+1
\s-1key_up,	kcuu1	ku	Sent by terminal up arrow key\s+1
\s-1keypad_local,	rmkx	ke	Out of "keypad transmit" mode\s+1
\s-1keypad_xmit,	smkx	ks	Put terminal in "keypad transmit" mode\s+1
\s-1lab_f0,	lf0	l0	Labels on function key f0 if not f0\s+1
\s-1lab_f1,	lf1	l1	Labels on function key f1 if not f1\s+1
\s-1lab_f2,	lf2	l2	Labels on function key f2 if not f2\s+1
\s-1lab_f3,	lf3	l3	Labels on function key f3 if not f3\s+1
\s-1lab_f4,	lf4	l4	Labels on function key f4 if not f4\s+1
\s-1lab_f5,	lf5	l5	Labels on function key f5 if not f5\s+1
\s-1lab_f6,	lf6	l6	Labels on function key f6 if not f6\s+1
\s-1lab_f7,	lf7	l7	Labels on function key f7 if not f7\s+1
\s-1lab_f8,	lf8	l8	Labels on function key f8 if not f8\s+1
\s-1lab_f9,	lf9	l9	Labels on function key f9 if not f9\s+1
\s-1lab_f10,	lf10	la	Labels on function key f10 if not f10\s+1
\s-1label_on,	smln	LO	turn on soft labels\s+1
\s-1label_off,	rmln	LF	turn off soft labels\s+1
\s-1meta_off,	rmm	mo	Turn off "meta mode"\s+1
\s-1meta_on,	smm	mm	Turn on "meta mode" (8th bit)\s+1
\s-1micro_column_address,	mhpa	ZY	Like column_address for micro adjustment\s+1
\s-1micro_down,	mcud1	ZZ	Like cursor_down for micro adjustment\s+1
\s-1micro_left,	mcub1	Za	Like cursor_left for micro adjustment\s+1
\s-1micro_right,	mcuf1	Zb	Like cursor_right for micro adjustment\s+1
\s-1micro_row_address,	mvpa	Zc	Like row_address for micro adjustment\s+1
\s-1micro_up,	mcuu1	Zd	Like cursor_up for micro adjustment\s+1
\s-1newline,	nel	nw	Newline (behaves like cr followed by lf)\s+1
\s-1order_of_pins,	porder	Ze	Matches software buts to print-head pins\s+1
\s-1orig_colors,	oc	oc	Reset all color pairs\s+1
\s-1orig_pair,	op	op	Set default color-pair to original one\s+1
\s-1pad_char,	pad	pc	Pad character (rather than null)\s+1
\s-1parm_dch,	dch	DC	Delete #1 chars (PG*)\s+1
\s-1parm_delete_line,	dl	DL	Delete #1 lines (PG*)\s+1
\s-1parm_down_cursor,	cud	DO	Move cursor down #1 lines (PG*)\s+1
\s-1parm_down_micro,	mcud	Zf	Like cud for micro adjust\s+1
\s-1parm_ich,	ich	IC	Insert #1 blank chars (PG*)\s+1
\s-1parm_index,	indn	SF	Scroll forward #1 lines (PG)\s+1
\s-1parm_insert_line,	il	AL	Add #1 new blank lines (PG*)\s+1
\s-1parm_left_cursor,	cub	LE	Move cursor left #1 spaces (PG)\s+1
\s-1parm_left_micro,	mcub	Zg	Like cul for micro adjust\s+1
\s-1parm_right_cursor,	cuf	RI	Move cursor right #1 spaces (PG*)\s+1
\s-1parm_right_micro,	mcuf	Zh	Likr cuf for micro adjust\s+1
\s-1parm_rindex,	rin	SR	Scroll backward #1 lines (PG)\s+1
\s-1parm_up_cursor,	cuu	UP	Move cursor up #1 lines (PG*)\s+1
\s-1parm_up_micro,	mcuu	Zi	Like cuu for micro adjust\s+1
\s-1pkey_key,	pfkey	pk	Prog funct key #1 to type string #2\s+1
\s-1pkey_local,	pfloc	pl	Prog funct key #1 to execute string #2\s+1
\s-1pkey_xmit,	pfx	px	Prog funct key #1 to xmit string #2\s+1
\s-1pkey_plab,	pfxl	xl	Program key #1 to xmit #2 and show #3\s+1
\s-1plab_norm,	pln	pn	program label #1 to show string #2\s+1
\s-1print_screen,	mc0	ps	Print contents of the screen\s+1
\s-1prtr_non,	mc5p	pO	Turn on the printer for #1 bytes\s+1
\s-1prtr_off,	mc4	pf	Turn off the printer\s+1
\s-1prtr_on,	mc5	po	Turn on the printer\s+1
\s-1repeat_char,	rep	rp	Repeat char #1 #2 times.  (PG*)\s+1
\s-1req_for_input,	rfi	RF	request for input\s+1
\s-1reset_1string,	rs1	r1	Reset terminal completely to sane modes.\s+1
\s-1reset_2string,	rs2	r2	Reset terminal completely to sane modes.\s+1
\s-1reset_3string,	rs3	r3	Reset terminal completely to sane modes.\s+1
\s-1reset_file,	rf	rf	Name of file containing reset string\s+1
\s-1restore_cursor,	rc	rc	Restore cursor to position of last sc\s+1
\s-1row_address,	vpa	cv	Vertical position absolute (set row) (PG)\s+1
\s-1save_cursor,	sc	sc	Save cursor position (P)\s+1
\s-1scancode_escape,	scesc	S7	Escape for scancode emulation\s+1
\s-1scroll_forward,	ind	sf	Scroll text up (P)\s+1
\s-1scroll_reverse,	ri	sr	Scroll text down (P)\s+1
\s-1select_char_set,	scs	Zj	Select character set\s+1
\s-1set0_des_seq,	s0ds	s0	Shift to codeset 0 (EUC set 0, ASCII)\s+1
\s-1set1_des_seq,	s1ds	s1	Shift to codeset 1\s+1
\s-1set2_des_seq,	s2ds	s2	Shift to codeset 2\s+1
\s-1set3_des_seq,	s3ds	s3	Shift to codeset 3\s+1
\s-1set_a_background,	setab	AB	Set background color using ANSI escape\s+1
\s-1set_a_foreground,	setaf	AF	Set foreground color using ANSI escape\s+1
\s-1set_attributes,	sgr	sa	Define the video attributes (PG9)\s+1
\s-1set_background,	setb	Sb	Set current background color\s+1
\s-1set_bottom_margin,	smgb	Zk	Set bottom margin at current line\s+1
\s-1set_bottom_margin_parm,	smgbp	Zl	Set bottom line at line #1 or #2 lines from bottom\s+1
\s-1set_color_band,	setcolor	Yz	Change to ribbon color #1\s+1
\s-1set_color_pair,	scp	sp	Set current color pair\s+1
\s-1set_foreground,	setf	Sf	Set current foreground color\s+1
\s-1set_left_margin,	smgl	ML	Set left margin at current line\s+1
\s-1set_left_margin_parm,	smglp	Zm	Set left (right) margin at #1 (#2)\s+1
\s-1set_lr_margin,	smglr	ML	Set both left and right margins\s+1
\s-1set_page_length,	slines	YZ	Set page length to #1 lines (use tparm)\s+1
\s-1set_right_margin,	smgr	MR	Set right margin at current column\s+1
\s-1set_right_margin_parm,	smgrp	Zn	Set right margin at column #1\s+1
\s-1set_tab,	hts	st	Set a tab in all rows, current column\s+1
\s-1set_tb_margin,	smgtb	MT	Sets both top and bottom margins\s+1
\s-1set_top_margin,	smgt	Zo	Set top margin at current line\s+1
\s-1set_top_margin_parm,	smgtp	Zp	Set top margin at line #1\s+1
\s-1set_window, 	wind	wi	Current window is lines #1-#2 cols #3-#4\s+1
\s-1start_bit_image,	sbim	Zq	Start printing bit image graphics\s+1
\s-1start_char_set_def,	scsd	Zr	Start definition of a character set\s+1
\s-1stop_bit_image,	rbim	Zs	End printing bit image graphics\s+1
\s-1stop_char_set_def,	rcsd	Zt	End definition of character set\s+1
\s-1subscript_characters,	subcs	Zu	List of subscriptable chars\s+1
\s-1superscript_characters,	supcs	Zv	List of superscriptable chars\s+1
\s-1tab,	ht	ta	Tab to next 8 space hardware tab stop\s+1
\s-1these_cause_cr,	docr	Zw	These characters cause a CR\s+1
\s-1to_status_line,	tsl	ts	Go to status line, column #1\s+1
\s-1underline_char,	uc	uc	Underscore one char and move past it\s+1
\s-1up_half_line,	hu	hu	Half-line up (reverse 1/2 linefeed)\s+1
\s-1xoff_character,	xoffc	XF	XON character\s+1
\s-1xon_character,	xonc	XN	XOFF character\s+1
.TE

(The following string capabilities are present in the SVr4.0 term structure,
but are not documented in the man page.  Comments are from the term
structure header.)

.TS
center;
c c c c
c c c c
l l l l.
\s-1label_format,	fln	Lf	??\s+1
\s-1set_clock,	sclk	SC	Set time-of-day clock\s+1
\s-1display_clock,	dclk	DK	Display time-of-day clock\s+1
\s-1remove_clock,	rmclk	RC	Remove time-of-day clock??\s+1
\s-1create_window,	cwin	CW	Define win #1 to go from #2,#3 to #4,#5\s+1
\s-1goto_window,	wingo	WG	Goto window #1\s+1
\s-1hangup,	hup	HU	Hang up phone\s+1
\s-1dial_phone,	dial	DI	Dial phone number #1\s+1
\s-1quick_dial,	qdial	QD	Dial phone number #1, without progress detection\s+1
\s-1tone,	tone	TO	Select touch tone dialing\s+1
\s-1pulse,	pulse	PU	Select pulse dialing\s+1
\s-1flash_hook,	hook	fh	Flash the switch hook\s+1
\s-1fixed_pause,	pause	PA	Pause for 2-3 seconds\s+1
\s-1wait_tone,	wait	WA	Wait for dial tone\s+1
\s-1user0,	u0	u0	User string # 0\s+1
\s-1user1,	u1	u1	User string # 1\s+1
\s-1user2,	u2	u2	User string # 2\s+1
\s-1user3,	u3	u3	User string # 3\s+1
\s-1user4,	u4	u4	User string # 4\s+1
\s-1user5,	u5	u5	User string # 5\s+1
\s-1user6,	u6	u6	User string # 6\s+1
\s-1user7,	u7	u7	User string # 7\s+1
\s-1user8,	u8	u8	User string # 8\s+1
\s-1user9,	u9	u9	User string # 9\s+1
\s-1get_mouse,	getm	Gm	Curses should get button events\s+1
\s-1key_mouse,	kmous	Km	??\s+1
\s-1mouse_info,	minfo	Mi	Mouse status information\s+1
\s-1pc_term_options,	pctrm	S6	PC terminal options\s+1
\s-1req_mouse_pos,	reqmp	RQ	Request mouse position report\s+1
\s-1zero_motion,	zerom,	Zx	No motion for the subsequent character\s+1
.TE
.PP
.B A Sample Entry
.PP
The following entry, which describes the Concept\-100, is among the more
complex entries in the
.I terminfo
file as of this writing.
.PP
.nf
.in -2
.ta .3i
.ft CW
\s-2concept100\||\|c100|\|\|concept\||\|c104\||\|c100-4p\||\|concept 100,
	am, bel=^G, blank=\eEH, blink=\eEC, clear=^L$<2*>, cnorm=\eEw,
	cols#80, cr=^M$<9>, cub1=^H, cud1=^J, cuf1=\eE=,
	cup=\eEa%p1%' '%+%c%p2%' '%+%c,
	cuu1=\eE;, cvvis=\eEW, db, dch1=\eE^A$<16*>, dim=\eEE, dl1=\eE^B$<3*>,
	ed=\eE^C$<16*>, el=\eE^U$<16>, eo, flash=\eEk$<20>\eEK, ht=\et$<8>,
	il1=\eE^R$<3*>, in, ind=^J, .ind=^J$<9>, ip=$<16*>,
	is2=\eEU\eEf\eE7\eE5\eE8\eEl\eENH\eEK\eE\e200\eEo&\e200\eEo\e47\eE,
	kbs=^h, kcub1=\eE>, kcud1=\eE<, kcuf1=\eE=, kcuu1=\eE;,
	kf1=\eE5, kf2=\eE6, kf3=\eE7, khome=\eE?,
	lines#24, mir, pb#9600, prot=\eEI, rep=\eEr%p1%c%p2%' '%+%c$<.2*>,
	rev=\eED, rmcup=\eEv    $<6>\eEp\er\en, rmir=\eE\e200, rmkx=\eEx,
	rmso=\eEd\eEe, rmul=\eEg, rmul=\eEg, sgr0=\eEN\e200,
	smcup=\eEU\eEv  8p\eEp\er, smir=\eE^P, smkx=\eEX, smso=\eEE\eED,
	smul=\eEG, tabs, ul, vt#8, xenl,\s+2
.in +2
.fi
.ft R
.PP
Entries may continue onto multiple lines by placing white space at
the beginning of each line except the first.
Comments may be included on lines beginning with ``#''.
Capabilities in
.I terminfo
are of three types:
Boolean capabilities which indicate that the terminal has
some particular feature, numeric capabilities giving the size of the terminal
or the size of particular delays, and string
capabilities, which give a sequence which can be used to perform particular
terminal operations.
.PP
.B Types of Capabilities
.PP
All capabilities have names.  For instance, the fact that
the Concept has
.I "automatic margins"
(i.e., an automatic return and linefeed
when the end of a line is reached) is indicated by the capability \fBam\fR.
Hence the description of the Concept includes \fBam\fR.
Numeric capabilities are followed by the character `#' and then the value.
Thus \fBcols\fR, which indicates the number of columns the terminal has,
gives the value `80' for the Concept.
.PP
Finally, string valued capabilities, such as \fBel\fR (clear to end of line
sequence) are given by the two-character code, an `=', and then a string
ending at the next following `,'.  A delay in milliseconds may appear
anywhere in such a capability, enclosed in $<..> brackets,
as in \fBel\fP=\eEK$<3>,
and padding characters are supplied by
.I tputs
to provide this delay.
The delay can be either a number, e.g., `20', or a number followed by
an `*', i.e., `3*'.  A `*' indicates that the padding required is proportional
to the number of lines affected by the operation, and the amount given is
the per-affected-unit padding required.
(In the case of insert character, the factor is still the number of
.IR lines
affected.
This is always one unless the terminal has \fBxenl\fP and the software uses it.)
When a `*' is specified, it is sometimes useful to give a delay of the form
`3.5' to specify a delay per unit to tenths of milliseconds.
(Only one decimal place is allowed.)
.PP
A number of escape sequences are provided in the string valued capabilities
for easy encoding of characters there.  Both \fB\eE\fR and \fB\ee\fR
map to an \s-1ESCAPE\s0 character,
\fB^x\fR maps to a control-x for any appropriate x, and the sequences
\fB\en \el \er \et \eb \ef \es\fR give
a newline, linefeed, return, tab, backspace, formfeed, and space.
Other escapes include \e^ for ^, \e\e for \e, \e, for comma, \e: for :,
and \e0 for null.
(\e0 will produce \e200, which does not terminate a string but behaves
as a null character on most terminals.)
Finally, characters may be given as three octal digits after a \fB\e\fR.
.PP
Sometimes individual capabilities must be commented out.
To do this, put a period before the capability name.
For example, see the second
.B ind
in the example above.
.br
.ne 5
.PP
.B Preparing Descriptions
.PP
We now outline how to prepare descriptions of terminals.
The most effective way to prepare a terminal description is by imitating
the description of a similar terminal in
.I terminfo
and to build up a description gradually, using partial descriptions
with
.I vi
or some other screen-oriented program to check that they are correct.
Be aware that a very unusual terminal may expose deficiencies in
the ability of the
.I terminfo
file to describe it
or bugs in the screen-handling code of the test program.
To easily test a new terminal description you can set the environment variable
TERMINFO to a pathname of a directory containing the
compiled description you are working
on and programs will look there rather than in
.IR \*d .
To get the padding for insert line right (if the terminal manufacturer
did not document it) a severe test is to edit /etc/passwd at 9600 baud,
delete 16 or so lines from the middle of the screen, then hit the `u'
key several times quickly.
If the terminal messes up, more padding is usually needed.
A similar test can be used for insert character.
.PP
.B Basic Capabilities
.PP
The number of columns on each line for the terminal is given by the
\fBcols\fR numeric capability.  If the terminal is a \s-1CRT\s0, then the
number of lines on the screen is given by the \fBlines\fR capability.
If the terminal wraps around to the beginning of the next line when
it reaches the right margin, then it should have the \fBam\fR capability.
If the terminal can clear its screen, leaving the cursor in the home
position, then this is given by the \fBclear\fR string capability.
If the terminal overstrikes
(rather than clearing a position when a character is struck over)
then it should have the \fBos\fR capability.
If the terminal is a printing terminal, with no soft copy unit,
give it both
.B hc
and
.BR os .
.RB ( os
applies to storage scope terminals, such as \s-1TEKTRONIX\s+1 4010
series, as well as hard copy and APL terminals.)
If there is a code to move the cursor to the left edge of the current
row, give this as
.BR cr .
(Normally this will be carriage return, control M.)
If there is a code to produce an audible signal (bell, beep, etc)
give this as
.BR bel .
.PP
If there is a code to move the cursor one position to the left
(such as backspace) that capability should be given as
.BR cub1 .
Similarly, codes to move to the right, up, and down should be
given as
.BR cuf1 ,
.BR cuu1 ,
and
.BR cud1 .
These local cursor motions should not alter the text they pass over,
for example, you would not normally use `\fBcuf1\fP=\ ' because the
space would erase the character moved over.
.PP
A very important point here is that the local cursor motions encoded
in
.I terminfo
are undefined at the left and top edges of a \s-1CRT\s0 terminal.
Programs should never attempt to backspace around the left edge,
unless
.B bw
is given,
and never attempt to go up locally off the top.
In order to scroll text up, a program will go to the bottom left corner
of the screen and send the
.B ind
(index) string.
.PP
To scroll text down, a program goes to the top left corner
of the screen and sends the
.B ri
(reverse index) string.
The strings
.B ind
and
.B ri
are undefined when not on their respective corners of the screen.
.PP
Parameterized versions of the scrolling sequences are
.B indn
and
.B rin
which have the same semantics as
.B ind
and
.B ri
except that they take one parameter, and scroll that many lines.
They are also undefined except at the appropriate edge of the screen.
.PP
The \fBam\fR capability tells whether the cursor sticks at the right
edge of the screen when text is output, but this does not necessarily
apply to a
.B cuf1
from the last column.
The only local motion which is defined from the left edge is if
.B bw
is given, then a
.B cub1
from the left edge will move to the right edge of the previous row.
If
.B bw
is not given, the effect is undefined.
This is useful for drawing a box around the edge of the screen, for example.
If the terminal has switch selectable automatic margins,
the
.I terminfo
file usually assumes that this is on; i.e., \fBam\fR.
If the terminal has a command which moves to the first column of the next
line, that command can be given as
.B nel
(newline).
It does not matter if the command clears the remainder of the current line,
so if the terminal has no
.B cr
and
.B lf
it may still be possible to craft a working
.B nel
out of one or both of them.
.PP
These capabilities suffice to describe hardcopy and \*(lqglass-tty\*(rq terminals.
Thus the model 33 teletype is described as
.PP
.DT
.nf
.ft CW
.in -7
	\s-133\||\|tty33\||\|tty\||\|model 33 teletype,
	bel=^G, cols#72, cr=^M, cud1=^J, hc, ind=^J, os,\s+1
.in +7
.ft R
.PP
while the Lear Siegler \s-1ADM\-3\s0 is described as
.PP
.DT
.nf
.ft CW
.in -7
	\s-1adm3\||\|3\||\|lsi adm3,
	am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,
	ind=^J, lines#24,\s+1
.in +7
.ft R
.fi
.PP
.B Parameterized Strings
.PP
Cursor addressing and other strings requiring parameters
in the terminal are described by a
parameterized string capability, with 
.IR printf (3S)
like escapes \fB%x\fR in it.
For example, to address the cursor, the
.B cup
capability is given, using two parameters:
the row and column to address to.
(Rows and columns are numbered from zero and refer to the
physical screen visible to the user, not to any unseen memory.)
If the terminal has memory relative cursor addressing,
that can be indicated by
.BR mrcup .
.PP
The parameter mechanism uses a stack and special \fB%\fP codes
to manipulate it.  Typically a sequence will push one of the
parameters onto the stack and then print it in some format.
Often more complex operations are necessary.
.PP
The \fB%\fR encodings have the following meanings:
.PP
.DT
.nf
.ta .5i 1.5i
	\s-1%%	outputs `%'
	%d	print pop() as in printf
	%2d	print pop() like %2d
	%3d	print pop() like %3d
	%02d
	%03d	as in printf
	%c	print pop() gives %c
	%s	print pop() gives %s

	%p[1-9]	push ith parm
	%P[a-z]	set variable [a-z] to pop()
	%g[a-z]	get variable [a-z] and push it
	%'c'	char constant c
	%{nn}	integer constant nn

	%+ %- %* %/ %m
		arithmetic (%m is mod): push(pop() op pop())
	%& %| %^	bit operations: push(pop() op pop())
	%= %> %<	logical operations: push(pop() op pop())
	%! %~	unary operations push(op pop())
	%i	add 1 to first two parms (for ANSI terminals)

	%? expr %t thenpart %e elsepart %;
		if-then-else, %e elsepart is optional.
		else-if's are possible ala Algol 68:
		%? c\d1\u %t b\d1\u %e c\d2\u %t b\d2\u %e c\d3\u %t b\d3\u %e c\d4\u %t b\d4\u %e %;
\s+1		c\di\u are conditions, b\di\u are bodies.
.fi
.PP
Binary operations are in postfix form with the operands in the usual order.
That is, to get x-5 one would use "%gx%{5}%-".
.PP
Consider the HP2645, which, to get to row 3 and column 12, needs
to be sent \eE&a12c03Y padded for 6 milliseconds.  Note that the order
of the rows and columns is inverted here, and that the row and column
are printed as two digits.
Thus its \fBcup\fR capability is \*(lqcup=6\eE&%p2%2dc%p1%2dY\*(rq.
.PP
The Microterm \s-1ACT-IV\s0 needs the current row and column sent
preceded by a \fB^T\fR, with the row and column simply encoded in binary,
\*(lqcup=^T%p1%c%p2%c\*(rq.
Terminals which use \*(lq%c\*(rq need to be able to
backspace the cursor (\fBcub1\fR),
and to move the cursor up one line on the screen (\fBcuu1\fR).
This is necessary because it is not always safe to transmit \fB\en\fR
\fB^D\fR and \fB\er\fR, as the system may change or discard them.
(The library routines dealing with terminfo set tty modes so that
tabs are never expanded, so \et is safe to send.
This turns out to be essential for the Ann Arbor 4080.)
.PP
A final example is the \s-1LSI ADM\s0-3a, which uses row and column
offset by a blank character, thus \*(lqcup=\eE=%p1%' '%+%c%p2%' '%+%c\*(rq.
After sending `\eE=', this pushes the first parameter, pushes the
ASCII value for a space (32), adds them (pushing the sum on the stack
in place of the two previous values) and outputs that value as a character.
Then the same is done for the second parameter.
More complex arithmetic is possible using the stack.
.PP
If the terminal has row or column absolute cursor addressing,
these can be given as single parameter capabilities
.B hpa
(horizontal position absolute)
and
.B vpa
(vertical position absolute).
Sometimes these are shorter than the more general two parameter
sequence (as with the hp2645) and can be used in preference to
.B cup .
If there are parameterized local motions (e.g., move
.I n
spaces to the right) these can be given as
.BR cud ,
.BR cub ,
.BR cuf ,
and
.BR cuu
with a single parameter indicating how many spaces to move.
These are primarily useful if the terminal does not have
.BR cup ,
such as the \s-1TEKTRONIX\s+1 4025.
.PP
.B Cursor Motions
.PP
If the terminal has a fast way to home the cursor
(to very upper left corner of screen) then this can be given as
\fBhome\fR; similarly a fast way of getting to the lower left-hand corner
can be given as \fBll\fR; this may involve going up with \fBcuu1\fR
from the home position,
but a program should never do this itself (unless \fBll\fR does) because it
can make no assumption about the effect of moving up from the home position.
Note that the home position is the same as addressing to (0,0):
to the top left corner of the screen, not of memory.
(Thus, the \eEH sequence on HP terminals cannot be used for
.BR home .)
.PP
.B Area Clears
.PP
If the terminal can clear from the current position to the end of the
line, leaving the cursor where it is, this should be given as \fBel\fR.
If the terminal can clear from the current position to the end of the
display, then this should be given as \fBed\fR.
\fBEd\fR is only defined from the first column of a line.
(Thus, it can be simulated by a request to delete a large number of lines,
if a true
.B ed
is not available.)
.PP
.B Insert/delete line
.PP
If the terminal can open a new blank line before the line where the cursor
is, this should be given as \fBil1\fR; this is done only from the first
position of a line.  The cursor must then appear on the newly blank line.
If the terminal can delete the line which the cursor is on, then this
should be given as \fBdl1\fR; this is done only from the first position on
the line to be deleted.
Versions of
.B il1
and
.B dl1
which take a single parameter and insert or delete that many lines can
be given as
.B il
and
.BR dl .
If the terminal has a settable scrolling region (like the vt100)
the command to set this can be described with the
.B csr
capability, which takes two parameters:
the top and bottom lines of the scrolling region.
The cursor position is, alas, undefined after using this command.
It is possible to get the effect of insert or delete line using
this command \- the
.B sc
and
.B rc
(save and restore cursor) commands are also useful.
Inserting lines at the top or bottom of the screen can also be
done using
.B ri
or
.B ind
on many terminals without a true insert/delete line,
and is often faster even on terminals with those features.
.PP
If the terminal has the ability to define a window as part of
memory, which all commands affect,
it should be given as the parameterized string
.BR wind .
The four parameters are the starting and ending lines in memory
and the starting and ending columns in memory, in that order.
.PP
If the terminal can retain display memory above, then the
\fBda\fR capability should be given; if display memory can be retained
below, then \fBdb\fR should be given.  These indicate
that deleting a line or scrolling may bring non-blank lines up from below
or that scrolling back with \fBri\fR may bring down non-blank lines.
.PP
.B Insert/Delete Character
.PP
There are two basic kinds of intelligent terminals with respect to
insert/delete character which can be described using
.I terminfo.
The most common insert/delete character operations affect only the characters
on the current line and shift characters off the end of the line rigidly.
Other terminals, such as the Concept 100 and the Perkin Elmer Owl, make
a distinction between typed and untyped blanks on the screen, shifting
upon an insert or delete only to an untyped blank on the screen which is
either eliminated, or expanded to two untyped blanks.  You can determine the
kind of terminal you have by clearing the screen and then typing
text separated by cursor motions.  Type \*(lqabc\ \ \ \ def\*(rq using local
cursor motions (not spaces) between the \*(lqabc\*(rq and the \*(lqdef\*(rq.
Then position the cursor before the \*(lqabc\*(rq and put the terminal in insert
mode.  If typing characters causes the rest of the line to shift
rigidly and characters to fall off the end, then your terminal does
not distinguish between blanks and untyped positions.  If the \*(lqabc\*(rq
shifts over to the \*(lqdef\*(rq which then move together around the end of the
current line and onto the next as you insert, you have the second type of
terminal, and should give the capability \fBin\fR, which stands for
\*(lqinsert null\*(rq.
While these are two logically separate attributes (one line vs. multiline
insert mode, and special treatment of untyped spaces) we have seen no
terminals whose insert mode cannot be described with the single attribute.
.PP
Terminfo can describe both terminals which have an insert mode, and terminals
which send a simple sequence to open a blank position on the current line.
Give as \fBsmir\fR the sequence to get into insert mode.
Give as \fBrmir\fR the sequence to leave insert mode.
Now give as \fBich1\fR any sequence needed to be sent just before sending
the character to be inserted.  Most terminals with a true insert mode
will not give \fBich1\fR; terminals which send a sequence to open a screen
position should give it here.
(If your terminal has both, insert mode is usually preferable to \fBich1\fP.
Do not give both unless the terminal actually requires both
to be used in combination.)
If post insert padding is needed, give this as a number of milliseconds
in \fBip\fR (a string option).  Any other sequence which may need to be
sent after an insert of a single character may also be given in \fBip\fR.
If your terminal needs both to be placed into an `insert mode' and
a special code to precede each inserted character, then both
.BR smir / rmir
and
.B ich1
can be given, and both will be used.
The
.B ich
capability, with one parameter,
.IR n ,
will repeat the effects of
.B ich1
.I n
times.
.PP
It is occasionally necessary to move around while in insert mode
to delete characters on the same line (e.g., if there is a tab after
the insertion position).  If your terminal allows motion while in
insert mode you can give the capability \fBmir\fR to speed up inserting
in this case.  Omitting \fBmir\fR will affect only speed.   Some terminals
(notably Datamedia's) must not have \fBmir\fR because of the way their
insert mode works.
.PP
Finally, you can specify
.B dch1
to delete a single character,
.B dch
with one parameter,
.IR n ,
to delete
.I n characters,
and delete mode by giving \fBsmdc\fR and \fBrmdc\fR
to enter and exit delete mode (any mode the terminal needs to be placed
in for
.B dch1
to work).
.PP
A command to erase
.I n
characters (equivalent to outputting
.I n
blanks without moving the cursor)
can be given as
.B ech
with one parameter.
.PP
.B "Highlighting, Underlining, and Visible Bells"
.PP
If your terminal has one or more kinds of display attributes,
these can be represented in a number of different ways.
You should choose one display form as
\f2standout mode\fR,
representing a good, high contrast, easy-on-the-eyes,
format for highlighting error messages and other attention getters.
(If you have a choice, reverse video plus half-bright is good,
or reverse video alone.)
The sequences to enter and exit standout mode
are given as \fBsmso\fR and \fBrmso\fR, respectively.
If the code to change into or out of standout
mode leaves one or even two blank spaces on the screen,
as the TVI 912 and Teleray 1061 do,
then \fBxmc\fR should be given to tell how many spaces are left.
.PP
Codes to begin underlining and end underlining can be given as \fBsmul\fR
and \fBrmul\fR respectively.
If the terminal has a code to underline the current character and move
the cursor one space to the right, 
such as the Microterm Mime,
this can be given as \fBuc\fR.
.PP
Other capabilities to enter various highlighting modes include
.B blink
(blinking)
.B bold
(bold or extra bright)
.B dim
(dim or half-bright)
.B invis
(blanking or invisible text)
.B prot
(protected)
.B rev
(reverse video)
.B sgr0
(turn off
.I all
attribute modes)
.B smacs
(enter alternate character set mode)
and
.B rmacs
(exit alternate character set mode).
Turning on any of these modes singly may or may not turn off other modes.
.PP
If there is a sequence to set arbitrary combinations of modes,
this should be given as
.B sgr
(set attributes),
taking 9 parameters.
Each parameter is either 0 or 1, as the corresponding attribute is on or off.
The 9 parameters are, in order:
standout, underline, reverse, blink, dim, bold, blank, protect, alternate
character set.
Not all modes need be supported by
.BR sgr ,
only those for which corresponding separate attribute commands exist.
.PP
Terminals with the ``magic cookie'' glitch
.RB ( xmc )
deposit special ``cookies'' when they receive mode-setting sequences,
which affect the display algorithm rather than having extra bits for
each character.
Some terminals, such as the HP 2621, automatically leave standout
mode when they move to a new line or the cursor is addressed.
Programs using standout mode should exit standout mode before
moving the cursor or sending a newline,
unless the
.B msgr
capability, asserting that it is safe to move in standout mode, is present.
.PP
If the terminal has
a way of flashing the screen to indicate an error quietly (a bell replacement)
then this can be given as \fBflash\fR; it must not move the cursor.
.PP
If the cursor needs to be made more visible than normal when it is
not on the bottom line (to make, for example, a non-blinking underline into an
easier to find block or blinking underline)
give this sequence as
.BR cvvis .
If there is a way to make the cursor completely invisible, give that as
.BR civis .
The capability
.BR cnorm
should be given which undoes the effects of both of these modes.
.PP
If the terminal needs to be in a special mode when running
a program that uses these capabilities,
the codes to enter and exit this mode can be given as \fBsmcup\fR and \fBrmcup\fR.
This arises, for example, from terminals like the Concept with more than
one page of memory.
If the terminal has only memory relative cursor addressing and not screen
relative cursor addressing, a one screen-sized window must be fixed into
the terminal for cursor addressing to work properly.
This is also used for the \s-1TEKTRONIX\s+1 4025,
where
.B smcup
sets the command character to be the one used by terminfo.
.PP
If your terminal correctly generates underlined characters
(with no special codes needed)
even though it does not overstrike,
then you should give the capability \fBul\fR.
If overstrikes are erasable with a blank,
then this should be indicated by giving \fBeo\fR.
.PP
.B Keypad
.PP
If the terminal has a keypad that transmits codes when the keys are pressed,
this information can be given. Note that it is not possible to handle
terminals where the keypad only works in local (this applies, for example,
to the unshifted HP 2621 keys).
If the keypad can be set to transmit or not transmit,
give these codes as \fBsmkx\fR and \fBrmkx\fR.
Otherwise the keypad is assumed to always transmit.
The codes sent by the left arrow, right arrow, up arrow, down arrow,
and home keys can be given as \fBkcub1, kcuf1, kcuu1, kcud1,
\fRand\fB khome\fR respectively.
If there are function keys such as f0, f1, ..., f10, the codes they send
can be given as \fBkf0, kf1, ..., kf10\fR.
If these keys have labels other than the default f0 through f10, the labels
can be given as \fBlf0, lf1, ..., lf10\fR.
The codes transmitted by certain other special keys can be given:
.B kll
(home down),
.B kbs
(backspace),
.B ktbc
(clear all tabs),
.B kctab
(clear the tab stop in this column),
.B kclr
(clear screen or erase key),
.B kdch1
(delete character),
.B kdl1
(delete line),
.B krmir
(exit insert mode),
.B kel
(clear to end of line),
.B ked
(clear to end of screen),
.B kich1
(insert character or enter insert mode),
.B kil1
(insert line),
.B knp
(next page),
.B kpp
(previous page),
.B kind
(scroll forward/down),
.B kri
(scroll backward/up),
.B khts
(set a tab stop in this column).
In addition, if the keypad has a 3 by 3 array of keys including the four
arrow keys, the other five keys can be given as
.BR ka1 ,
.BR ka3 ,
.BR kb2 ,
.BR kc1 ,
and
.BR kc3 .
These keys are useful when the effects of a 3 by 3 directional pad are needed.
.PP
.B Tabs and Initialization
.PP
If the terminal has hardware tabs, the command to advance to the next
tab stop can be given as
.B ht
(usually control I).
A ``backtab'' command which moves leftward to the next tab stop can
be given as
.BR cbt .
By convention, if the teletype modes indicate that tabs are being
expanded by the computer rather than being sent to the terminal,
programs should not use
.B ht
or
.B cbt
even if they are present, since the user may not have the tab stops
properly set.
If the terminal has hardware tabs which are initially set every
.I n
spaces when the terminal is powered up,
the numeric parameter
.B it
is given, showing the number of spaces the tabs are set to.
This is normally used by the
.IR tset
command to determine whether to set the mode for hardware tab expansion,
and whether to set the tab stops.
If the terminal has tab stops that can be saved in nonvolatile memory,
the terminfo description can assume that they are properly set.
.PP
Other capabilities
include
.BR is1 ,
.BR is2 ,
and
.BR is3 ,
initialization strings for the terminal,
.BR iprog ,
the path name of a program to be run to initialize the terminal,
and \fBif\fR, the name of a file containing long initialization strings.
These strings are expected to set the terminal into modes consistent
with the rest of the terminfo description.
They are normally sent to the terminal, by the
.IR tset
program, each time the user logs in.
They will be printed in the following order:
.BR is1 ;
.BR is2 ;
setting tabs using
.B tbc
and
.BR hts ;
.BR if ;
running the program
.BR iprog ;
and finally
.BR is3 .
Most initialization is done with
.BR is2 .
Special terminal modes can be set up without duplicating strings
by putting the common sequences in
.B is2
and special cases in
.B is1
and
.BR is3 .
A pair of sequences that does a harder reset from a totally unknown state
can be analogously given as
.BR rs1 ,
.BR rs2 ,
.BR rf ,
and
.BR rs3 ,
analogous to
.B is2
and
.BR if .
These strings are output by the
.IR reset
program, which is used when the terminal gets into a wedged state.
Commands are normally placed in
.B rs2
and
.B rf
only if they produce annoying effects on the screen and are not
necessary when logging in.
For example, the command to set the vt100 into 80-column mode would
normally be part of
.BR is2 ,
but it causes an annoying glitch of the screen and is not normally
needed since the terminal is usually already in 80 column mode.
.PP
If there are commands to set and clear tab stops, they can be given as
.B tbc
(clear all tab stops)
and
.B hts
(set a tab stop in the current column of every row).
If a more complex sequence is needed to set the tabs than can be
described by this, the sequence can be placed in
.B is2
or
.BR if .
.PP
Delays
.PP
Certain capabilities control padding in the teletype driver.
These are primarily needed by hard copy terminals, and are used
by the
.IR tset
program to set teletype modes appropriately.
Delays embedded in the capabilities
.BR cr ,
.BR ind ,
.BR cub1 ,
.BR ff ,
and
.B tab
will cause the appropriate delay bits to be set in the teletype driver.
If
.B pb
(padding baud rate)
is given,
these values can be ignored at baud rates below the value of
.BR pb .
.PP
.B Miscellaneous
.PP
If the terminal requires other than a null (zero) character as a pad,
then this can be given as \fBpad\fR.
Only the first character of the
.B pad
string is used.
.PP
If the terminal has an extra ``status line'' that is not normally
used by software, this fact can be indicated.
If the status line is viewed as an extra line below the bottom line,
into which one can cursor address normally
(such as the Heathkit h19's 25th line, or the 24th line of a vt100
which is set to a 23-line scrolling region),
the capability
.B hs
should be given.
Special strings to go to the beginning of the status
line and to return from the status line can be given as
.B tsl
and
.BR fsl .
.RB ( fsl
must leave the cursor position in the same place it was before
.BR tsl .
If necessary, the
.B sc
and
.B rc
strings can be included in
.B tsl
and
.B fsl
to get this effect.)
The parameter
.B tsl
takes one parameter, which is the column number of the status line
the cursor is to be moved to.
If escape sequences and other special commands, such as tab, work
while in the status line, the flag
.B eslok
can be given.
A string which turns off the status line (or otherwise erases its
contents) should be given as
.BR dsl .
If the terminal has commands to save and restore the position of the cursor,
give them as
.B sc
and
.BR rc .
The status line is normally assumed to be the same width as the rest
of the screen, e.g.,
.BR cols .
If the status line is a different width (possibly because the terminal
does not allow an entire line to be loaded) the width, in columns,
can be indicated with the numeric parameter
.BR wsl .
.PP
If the terminal can move up or down half a line,
this can be indicated with
.B hu
(half-line up)
and
.B hd
(half-line down).
This is primarily useful for superscripts and subscripts on hardcopy terminals.
If a hardcopy terminal can eject to the next page (form feed), give this as
.B ff
(usually control L).
.PP
If there is a command to repeat a given character a given number of
times (to save time transmitting a large number of identical characters)
this can be indicated with the parameterized string
.BR rep .
The first parameter is the character to be repeated and the second
is the number of times to repeat it.
Thus, tparm(repeat_char, 'x', 10) is the same as `xxxxxxxxxx'.
.PP
If the terminal has a settable command character, such as the \s-1TEKTRONIX\s+1 4025,
this can be indicated with
.BR cmdch .
A prototype command character is chosen which is used in all capabilities.
This character is given in the
.B cmdch
capability to identify it.
The following convention is supported on some UNIX systems:
The environment is to be searched for a
.B CC
variable, and if found, all
occurrences of the prototype character are replaced with the character
in the environment variable.
.PP
Terminal descriptions that do not represent a specific kind of known
terminal, such as
.IR switch ,
.IR dialup ,
.IR patch ,
and
.IR network ,
should include the
.B gn
(generic) capability so that programs can complain that they do not know
how to talk to the terminal.
(This capability does not apply to
.I virtual
terminal descriptions for which the escape sequences are known.)
.PP
If the terminal uses xon/xoff handshaking for flow control, give
.BR xon .
Padding information should still be included so that routines can
make better decisions about costs, but actual pad characters will
not be transmitted.
.PP
If the terminal has a ``meta key'' which acts as a shift key,
setting the 8th bit of any character transmitted, this fact can
be indicated with
.BR km .
Otherwise, software will assume that the 8th bit is parity and it
will usually be cleared.
If strings exist to turn this ``meta mode'' on and off, they
can be given as
.B smm
and
.BR rmm .
.PP
If the terminal has more lines of memory than will fit on the screen
at once, the number of lines of memory can be indicated with
.BR lm .
A value of
.BR lm #0
indicates that the number of lines is not fixed,
but that there is still more memory than fits on the screen.
.PP
If the terminal is one of those supported by the \s-1UNIX\s+1 virtual
terminal protocol, the terminal number can be given as
.BR vt .
.PP
Media copy
strings which control an auxiliary printer connected to the terminal
can be given as
.BR mc0 :
print the contents of the screen,
.BR mc4 :
turn off the printer, and
.BR mc5 :
turn on the printer.
When the printer is on, all text sent to the terminal will be sent
to the printer.
It is undefined whether the text is also displayed on the terminal screen
when the printer is on.
A variation
.B mc5p
takes one parameter, and leaves the printer on for as many characters
as the value of the parameter, then turns the printer off.
The parameter should not exceed 255.
All text, including
.BR mc4 ,
is transparently passed to the printer while an
.B mc5p
is in effect.
.PP
Strings to program function keys can be given as
.BR pfkey ,
.BR pfloc ,
and
.BR pfx .
Each of these strings takes two parameters: the function key number to
program (from 0 to 10) and the string to program it with.
Function key numbers out of this range may program undefined keys in
a terminal dependent manner.
The difference between the capabilities is that
.B pfkey
causes pressing the given key to be the same as the user typing the
given string;
.B pfloc
causes the string to be executed by the terminal in local; and
.B pfx
causes the string to be transmitted to the computer.
.PP
.B Glitches and Braindamage
.PP
Hazeltine terminals, which do not allow `~' characters to be displayed should
indicate \fBhz\fR.
.PP
Terminals which ignore a linefeed immediately after an \fBam\fR wrap,
such as the Concept and vt100,
should indicate \fBxenl\fR.
.PP
If
.B el
is required to get rid of standout
(instead of merely writing normal text on top of it),
\fBxhp\fP should be given.
.PP
Teleray terminals, where tabs turn all characters moved over to blanks,
should indicate \fBxt\fR (destructive tabs).
Note: the variable indicating this is now `dest_tabs_magic_smso'; in
older versions, it was teleray_glitch.
This glitch is also taken to mean that it is not possible to position
the cursor on top of a ``magic cookie'',
that to erase standout mode it is instead necessary to use
delete and insert line.
.PP
The Beehive Superbee, which is unable to correctly transmit the escape
or control C characters, has
.BR xsb ,
indicating that the f1 key is used for escape and f2 for control C.
(Only certain Superbees have this problem, depending on the ROM.)
Note that in older terminfo versions, this capability was called
`beehive_glitch'; it is now `no_esc_ctl_c'.
.PP
Other specific terminal problems may be corrected by adding more
capabilities of the form \fBx\fIx\fR.
.PP
.B Similar Terminals
.PP
If there are two very similar terminals,
one can be defined as being just like the other with certain exceptions.
The string capability \fBuse\fR can be given
with the name of the similar terminal.
The capabilities given before
.B use
override those in the terminal type invoked by
.BR use .
A capability can be canceled by placing \fBxx@\fR to the left of the
capability definition, where xx is the capability.
For example, the entry
.PP
	2621-nl, smkx@, rmkx@, use=2621,
.PP
defines a 2621-nl that does not have the \fBsmkx\fR or \fBrmkx\fR capabilities,
and hence does not turn on the function key labels when in visual mode.
This is useful for different modes for a terminal, or for different
user preferences.
.SH FILES
.TP 25
\*d/?/*
files containing terminal descriptions
.SH "SEE ALSO"
tic(1), curses(3), printf(3), term(5).
.SH AUTHORS
Pavel Curtis, Zeyd M. Ben-Halim
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
