
  [Note: the version included in i4b does not output any data you can
   plot, but will just print the values of the tones it detected. -hm]


Poul-Henning Kamp wrote:
------------------------

I remember that somebody asked about this long time ago, so I sat
down and hacked a digital filter for that.

The following piece of code will read a ".g711a" file, and output
9 columns of data.  The first is the linear value of the sample,
the other 8 are strength of the 8 DTMF tones.  

Try to run the "beep.g711a" file from i4b through it, and plot the
output columns with gnuplot.  It seems Hellmuth pressed a '1' :-)

The implementation is a recursive resonance filter, actually 8 of
them, one for each frequency, done in floating point.  With a little
attention to rounding, it can be done just as good, and much faster
in integer math, in fact 16 bit should be enough, but may not be
faster than 32bit.

The "POLRAD" quantity determines the resonance width of the filters,
if you make it too low, it will confuse tones and recognize them
where they are not.  If you make it too high (never, ever >= 1.0!)
it will take longer to react and maybe not catch a slightly offbeat
tone.  If you set it above or equal to 1.0 you get a tone generator.

This could also be a good basis for a 300Baud FSK modem emulation.

It seems that the .g711a files are bit-flipped, therefore the flip[]
array trick in this code.  The alaw->linear converter is lifted from
sox.

Now, who writes the answering-machine to end all answering machines
for i4b ?

Poul-Henning
--
Poul-Henning Kamp             FreeBSD coreteam member
phk@FreeBSD.ORG               "Real hackers run -current on their laptop."
"ttyv0" -- What UNIX calls a $20K state-of-the-art, 3D, hi-res color terminal
