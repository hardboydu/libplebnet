
Received: from louie.udel.edu by huey.udel.edu id aa12898; 26 Jan 94 21:06 EST
Received: from sony.com by louie.udel.edu id aa05924; 26 Jan 94 21:01 EST
Received: by sony.com id AA18168; Wed, 26 Jan 94 18:00:44 -0800
X-Btw: sony.com is also sonygate.sony.com
Received: by mail1.gw.in.sel.sony.com id AA25072; Wed, 26 Jan 94 18:00:43 -0800
Received: by mail1.sjc.in.sel.sony.com id AA13634; Wed, 26 Jan 94 18:00:41 -0800
Received: by morality.sjc.hw.sony.com; id AA23624; Wed, 26 Jan 94 18:00:40 -0800
Date: Wed, 26 Jan 94 18:00:40 -0800
From: Paul Vixie <Paul_Vixie@corpmis.sjc.hw.sony.com>
Message-Id: <9401270200.AA23624@morality.sjc.hw.sony.com>
To: mills@udel.edu
Subject: diffs against 3.3c (26-jan 11:36)
Cc: paul@vix.com

These have been tested on BSD/386 1.0 and on HP-UX 8.??.  I have more to do,
but this is the last I'm going to do before 3.3d (or whatever) comes out with
the other patches you're expecting.  I need to have a day with just me and NTP
and everybody else with their mits outa the code while I finish the portability
stuff.

*** /tmp/RCSA023397	Wed Jan 26 17:56:22 1994
--- adjtime/adjtimed.c	Wed Jan 26 16:33:27 1994
***************
*** 42,47 ****
  
  double atof();
! extern int optind;
! extern char *optarg;
  
  int InitClockRate();
--- 42,47 ----
  
  double atof();
! extern int ntp_optind;
! extern char *ntp_optarg;
  
  int InitClockRate();
***************
*** 84,88 ****
    openlog("adjtimed", LOG_PID, LOG_LOCAL6);
  
!   while ((ch = getopt(argc, argv, "hkrvdfp:")) != EOF) {
      switch (ch) {
      case 'k':
--- 84,88 ----
    openlog("adjtimed", LOG_PID, LOG_LOCAL6);
  
!   while ((ch = ntp_getopt(argc, argv, "hkrvdfp:")) != EOF) {
      switch (ch) {
      case 'k':
***************
*** 114,118 ****
  
      case 'p':
!       if ((RATE = atof(optarg)) <= 0.0 || RATE >= 100.0) {
  	fputs("adjtimed: percentage must be between 0.0 and 100.0\n", stderr);
  	exit(1);
--- 114,118 ----
  
      case 'p':
!       if ((RATE = atof(ntp_optarg)) <= 0.0 || RATE >= 100.0) {
  	fputs("adjtimed: percentage must be between 0.0 and 100.0\n", stderr);
  	exit(1);
*** /tmp/RCSA023401	Wed Jan 26 17:56:23 1994
--- authstuff/authspeed.c	Wed Jan 26 16:33:28 1994
***************
*** 66,75 ****
  	int i;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  
  	progname = argv[0];
  	loops = DEFLOOPS;
! 	while ((c = getopt_l(argc, argv, "cdmn:")) != EOF)
  		switch (c) {
  		case 'c':
--- 66,75 ----
  	int i;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	progname = argv[0];
  	loops = DEFLOOPS;
! 	while ((c = ntp_getopt(argc, argv, "cdmn:")) != EOF)
  		switch (c) {
  		case 'c':
***************
*** 83,91 ****
  			break;
  		case 'n':
! 			loops = atoi(optarg);
  			if (loops <= 0) {
  				(void) fprintf(stderr, 
  			"%s: %s is unlikely to be a useful number of loops\n",
! 				    progname, optarg);
  				errflg++;
  			}
--- 83,91 ----
  			break;
  		case 'n':
! 			loops = atoi(ntp_optarg);
  			if (loops <= 0) {
  				(void) fprintf(stderr, 
  			"%s: %s is unlikely to be a useful number of loops\n",
! 					       progname, ntp_optarg);
  				errflg++;
  			}
***************
*** 95,99 ****
  			break;
  		}
! 	if (errflg || optind == argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [-d] [-n loops] [ -c ] auth.samplekeys\n",
--- 95,99 ----
  			break;
  		}
! 	if (errflg || ntp_optind == argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [-d] [-n loops] [ -c ] auth.samplekeys\n",
***************
*** 109,113 ****
  
  	init_auth();
! 	authreadkeys(argv[optind]);
  	for (i = 0; i < 16; i++) {
  		if (!auth_havekey(i + domd5)) {
--- 109,113 ----
  
  	init_auth();
! 	authreadkeys(argv[ntp_optind]);
  	for (i = 0; i < 16; i++) {
  		if (!auth_havekey(i + domd5)) {
*** /tmp/RCSA023401	Wed Jan 26 17:56:23 1994
--- authstuff/keyparity.c	Wed Jan 26 16:33:28 1994
***************
*** 50,58 ****
  	int keytype;
  	U_LONG key[2];
! 	extern int optind;
! 	extern char *optarg;
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "adno:s")) != EOF)
  		switch (c) {
  		case 'a':
--- 50,58 ----
  	int keytype;
  	U_LONG key[2];
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "adno:s")) != EOF)
  		switch (c) {
  		case 'a':
***************
*** 69,76 ****
  			break;
  		case 'o':
! 			if (*optarg == 'n') {
  				ntpoutflag = 1;
  				gotoopt = 1;
! 			} else if (*optarg == 's') {
  				ntpoutflag = 0;
  				gotoopt = 1;
--- 69,76 ----
  			break;
  		case 'o':
! 			if (*ntp_optarg == 'n') {
  				ntpoutflag = 1;
  				gotoopt = 1;
! 			} else if (*ntp_optarg == 's') {
  				ntpoutflag = 0;
  				gotoopt = 1;
***************
*** 86,90 ****
  			break;
  		}
! 	if (errflg || optind == argc) {
  		(void) fprintf(stderr,
  		    "usage: %s -n|-s [-a] [-o n|s] key [...]\n",
--- 86,90 ----
  			break;
  		}
! 	if (errflg || ntp_optind == argc) {
  		(void) fprintf(stderr,
  		    "usage: %s -n|-s [-a] [-o n|s] key [...]\n",
***************
*** 119,127 ****
  		keytype = KEY_TYPE_STD;
  
! 	for (; optind < argc; optind++) {
! 		if (!decodekey(keytype, argv[optind], key)) {
  			(void) fprintf(stderr,
  			    "%s: format of key %s invalid\n",
! 			    progname, argv[optind]);
  			exit(1);
  		}
--- 119,127 ----
  		keytype = KEY_TYPE_STD;
  
! 	for (; ntp_optind < argc; ntp_optind++) {
! 		if (!decodekey(keytype, argv[ntp_optind], key)) {
  			(void) fprintf(stderr,
  			    "%s: format of key %s invalid\n",
! 			    progname, argv[ntp_optind]);
  			exit(1);
  		}
***************
*** 243,247 ****
  		 * Make up key from ascii representation
  		 */
! 		bzero(keybytes, sizeof(keybytes));
  		for (i = 0; i < 8 && i < len; i++)
  			keybytes[i] = *cp++ << 1;
--- 243,247 ----
  		 * Make up key from ascii representation
  		 */
! 		memset(keybytes, 0, sizeof(keybytes));
  		for (i = 0; i < 8 && i < len; i++)
  			keybytes[i] = *cp++ << 1;
*** /tmp/RCSA023401	Wed Jan 26 17:56:23 1994
--- authstuff/makeIPFP.c	Wed Jan 26 16:33:28 1994
***************
*** 29,37 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
--- 29,37 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 184,188 ****
  	int octbits;
  
! 	bzero((char *)bits, sizeof bits);
  
  	/*
--- 184,188 ----
  	int octbits;
  
! 	memset((char *)bits, 0, sizeof bits);
  
  	/*
*** /tmp/RCSA023401	Wed Jan 26 17:56:23 1994
--- authstuff/makePC1.c	Wed Jan 26 16:33:28 1994
***************
*** 26,34 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
--- 26,34 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 83,88 ****
  	u_char d[28];
  
! 	bzero((char *)c, sizeof c);
! 	bzero((char *)d, sizeof d);
  
  	for (i = 0; i < 28; i++) {
--- 83,88 ----
  	u_char d[28];
  
! 	memset((char *)c, 0, sizeof c);
! 	memset((char *)d, 0, sizeof d);
  
  	for (i = 0; i < 28; i++) {
***************
*** 141,145 ****
  	u_char bits[64];
  
! 	bzero((char *)bits, sizeof bits);
  
  	printf("static U_LONG PC1_CL[8] = {");
--- 141,145 ----
  	u_char bits[64];
  
! 	memset((char *)bits, 0, sizeof bits);
  
  	printf("static U_LONG PC1_CL[8] = {");
*** /tmp/RCSA023401	Wed Jan 26 17:56:24 1994
--- authstuff/makePC2.c	Wed Jan 26 16:33:28 1994
***************
*** 27,35 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
--- 27,35 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 88,92 ****
  	u_char res[24];
  
! 	bzero((char *)res, sizeof res);
  
  	for (i = 0; i < 24; i++) {
--- 88,92 ----
  	u_char res[24];
  
! 	memset((char *)res, 0, sizeof res);
  
  	for (i = 0; i < 24; i++) {
***************
*** 118,122 ****
  	u_char res[24];
  
! 	bzero((char *)res, sizeof res);
  
  	for (i = 0; i < 24; i++) {
--- 118,122 ----
  	u_char res[24];
  
! 	memset((char *)res, 0, sizeof res);
  
  	for (i = 0; i < 24; i++) {
***************
*** 169,173 ****
  	u_char bits[28];
  
! 	bzero((char *)bits, sizeof bits);
  
  	printf("static U_LONG PC2_C[4][64] = {");
--- 169,173 ----
  	u_char bits[28];
  
! 	memset((char *)bits, 0, sizeof bits);
  
  	printf("static U_LONG PC2_C[4][64] = {");
*** /tmp/RCSA023401	Wed Jan 26 17:56:24 1994
--- authstuff/makeSP.c	Wed Jan 26 16:33:28 1994
***************
*** 26,34 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
--- 26,34 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 166,170 ****
  	int sixbits;
  
! 	bzero((char *)bits, sizeof bits);
  	printf("static U_LONG SP[8][64] = {");
  	for (selno = 0; selno < 8; selno++) {
--- 166,170 ----
  	int sixbits;
  
! 	memset((char *)bits, 0, sizeof bits);
  	printf("static U_LONG SP[8][64] = {");
  	for (selno = 0; selno < 8; selno++) {
*** /tmp/RCSA023401	Wed Jan 26 17:56:24 1994
--- authstuff/mkrandkeys.c	Wed Jan 26 16:33:28 1994
***************
*** 35,40 ****
  	U_LONG tmp;
  	char *passwd;
! 	extern int optind;
! 	extern char *optarg;
  	extern char *getpass();
  
--- 35,40 ----
  	U_LONG tmp;
  	char *passwd;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  	extern char *getpass();
  
***************
*** 42,46 ****
  	progname = argv[0];
  	passwd = NULL;
! 	while ((c = getopt_l(argc, argv, "dnp:s")) != EOF)
  		switch (c) {
  		case 'd':
--- 42,46 ----
  	progname = argv[0];
  	passwd = NULL;
! 	while ((c = ntp_getopt(argc, argv, "dnp:s")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 51,55 ****
  			break;
  		case 'p':
! 			passwd = optarg;
  			break;
  		case 's':
--- 51,55 ----
  			break;
  		case 'p':
! 			passwd = ntp_optarg;
  			break;
  		case 's':
***************
*** 62,70 ****
  
  	numkeys = 0;
! 	for (; !errflg && optind < argc; optind++) {
! 		c = atoi(argv[optind]);
  		if (c <= 0 || c > 15) {
  			(void) fprintf(stderr, "%s: invalid key number `%s'\n",
! 				       progname, argv[optind]);
  			exit(2);
  		}
--- 62,70 ----
  
  	numkeys = 0;
! 	for (; !errflg && ntp_optind < argc; ntp_optind++) {
! 		c = atoi(argv[ntp_optind]);
  		if (c <= 0 || c > 15) {
  			(void) fprintf(stderr, "%s: invalid key number `%s'\n",
! 				       progname, argv[ntp_optind]);
  			exit(2);
  		}
*** /tmp/RCSA023401	Wed Jan 26 17:56:24 1994
--- authstuff/omakeIPFP.c	Wed Jan 26 16:33:29 1994
***************
*** 35,43 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
--- 35,43 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "d")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 189,193 ****
  	int quadbits;
  
! 	bzero((char *)bits, sizeof bits);
  
  	/*
--- 189,193 ----
  	int quadbits;
  
! 	memset((char *)bits, 0, sizeof bits);
  
  	/*
*** /tmp/RCSA023419	Wed Jan 26 17:56:25 1994
--- clockstuff/chutest.c	Wed Jan 26 16:33:29 1994
***************
*** 69,78 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  	void init_chu();
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "cdfpt")) != EOF)
  		switch (c) {
  		case 'c':
--- 69,78 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  	void init_chu();
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "cdfpt")) != EOF)
  		switch (c) {
  		case 'c':
***************
*** 108,112 ****
  			break;
  		}
! 	if (errflg || optind+1 != argc) {
  #ifdef STREAM
  		(void) fprintf(stderr, "usage: %s [-dft] tty_device\n",
--- 108,112 ----
  			break;
  		}
! 	if (errflg || ntp_optind+1 != argc) {
  #ifdef STREAM
  		(void) fprintf(stderr, "usage: %s [-dft] tty_device\n",
***************
*** 127,131 ****
  
  	(void) gettimeofday(&lasttv, (struct timezone *)0);
! 	c = openterm(argv[optind]);
  	init_chu();
  #ifdef STREAM
--- 127,131 ----
  
  	(void) gettimeofday(&lasttv, (struct timezone *)0);
! 	c = openterm(argv[ntp_optind]);
  	init_chu();
  #ifdef STREAM
*** /tmp/RCSA023419	Wed Jan 26 17:56:25 1994
--- clockstuff/clktest.c	Wed Jan 26 16:33:29 1994
***************
*** 106,111 ****
  	struct sgttyb ttyb;
  	struct itimerval itimer;
! 	extern int optind;
! 	extern char *optarg;
  	int alarming();
  	int ioready();
--- 106,111 ----
  	struct sgttyb ttyb;
  	struct itimerval itimer;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  	int alarming();
  	int ioready();
***************
*** 115,119 ****
  	magic[0] = 0;
  #endif
! 	while ((c = getopt_l(argc, argv, "a:b:c:dfs:t:")) != EOF)
  		switch (c) {
  #ifdef CLKLDISC
--- 115,119 ----
  	magic[0] = 0;
  #endif
! 	while ((c = ntp_getopt(argc, argv, "a:b:c:dfs:t:")) != EOF)
  		switch (c) {
  #ifdef CLKLDISC
***************
*** 121,125 ****
  #endif
  		case 'c':
! 			if (!atouint(optarg, &tmp)) {
  				(void) fprintf(stderr,
  				    "%s: argument for -%c must be integer\n",
--- 121,125 ----
  #endif
  		case 'c':
! 			if (!atouint(ntp_optarg, &tmp)) {
  				(void) fprintf(stderr,
  				    "%s: argument for -%c must be integer\n",
***************
*** 140,144 ****
  			break;
  		case 'b':
! 			if (!atouint(optarg, &tmp)) {
  				errflg++;
  				break;
--- 140,144 ----
  			break;
  		case 'b':
! 			if (!atouint(ntp_optarg, &tmp)) {
  				errflg++;
  				break;
***************
*** 164,175 ****
  			break;
  		case 's':
! 			cmdlen = strlen(optarg);
  			if (cmdlen == 0)
  				errflg++;
  			else
! 				cmd = optarg;
  			break;
  		case 't':
! 			if (!atouint(optarg, &tmp))
  				errflg++;
  			else {
--- 164,175 ----
  			break;
  		case 's':
! 			cmdlen = strlen(ntp_optarg);
  			if (cmdlen == 0)
  				errflg++;
  			else
! 				cmd = ntp_optarg;
  			break;
  		case 't':
! 			if (!atouint(ntp_optarg, &tmp))
  				errflg++;
  			else {
***************
*** 182,186 ****
  			break;
  		}
! 	if (errflg || optind+1 != argc) {
  		(void) fprintf(stderr,
  #ifdef CLKLDISC
--- 182,186 ----
  			break;
  		}
! 	if (errflg || ntp_optind+1 != argc) {
  		(void) fprintf(stderr,
  #ifdef CLKLDISC
***************
*** 200,209 ****
  
  	if (docmd)
! 		fd = open(argv[optind], O_RDWR, 0777);
  	else
! 		fd = open(argv[optind], O_RDONLY, 0777);
  	if (fd == -1) {
  		(void) fprintf(stderr, "%s: open(%s): ", progname,
! 		    argv[optind]);
  		perror("");
  		exit(1);
--- 200,209 ----
  
  	if (docmd)
! 		fd = open(argv[ntp_optind], O_RDWR, 0777);
  	else
! 		fd = open(argv[ntp_optind], O_RDONLY, 0777);
  	if (fd == -1) {
  		(void) fprintf(stderr, "%s: open(%s): ", progname,
! 			       argv[ntp_optind]);
  		perror("");
  		exit(1);
*** /tmp/RCSA023419	Wed Jan 26 17:56:25 1994
--- clockstuff/propdelay.c	Wed Jan 26 16:33:29 1994
***************
*** 141,149 ****
  	double lat2, long2;
  	double lat3, long3;
! 	extern int optind;
! 	extern char *optarg;
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "dh:CWG")) != EOF)
  		switch (c) {
  		case 'd':
--- 141,149 ----
  	double lat2, long2;
  	double lat3, long3;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "dh:CWG")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 152,159 ****
  		case 'h':
  			hflag++;
! 			height = atof(optarg);
  			if (height <= 0.0) {
  				(void) fprintf(stderr, "height %s unlikely\n",
! 				    optarg);
  				errflg++;
  			}
--- 152,159 ----
  		case 'h':
  			hflag++;
! 			height = atof(ntp_optarg);
  			if (height <= 0.0) {
  				(void) fprintf(stderr, "height %s unlikely\n",
! 					       ntp_optarg);
  				errflg++;
  			}
***************
*** 172,177 ****
  			break;
  		}
! 	if (errflg || (!(Cflag || Wflag || Gflag) && optind+4 != argc) || 
!             ((Cflag || Wflag || Gflag) && optind+2 != argc)) {
  		(void) fprintf(stderr,
  		    "usage: %s [-d] [-h height] lat1 long1 lat2 long2\n",
--- 172,177 ----
  			break;
  		}
! 	if (errflg || (!(Cflag || Wflag || Gflag) && ntp_optind+4 != argc) || 
!             ((Cflag || Wflag || Gflag) && ntp_optind+2 != argc)) {
  		(void) fprintf(stderr,
  		    "usage: %s [-d] [-h height] lat1 long1 lat2 long2\n",
***************
*** 186,193 ****
  		   
  	if (!(Cflag || Wflag || Gflag)) {
! 		lat1 = latlong(argv[optind], 1);
! 		long1 = latlong(argv[optind + 1], 0);
! 		lat2 = latlong(argv[optind + 2], 1);
! 		long2 = latlong(argv[optind + 3], 0);
  		if (hflag) {
  			doit(lat1, long1, lat2, long2, height, "");
--- 186,193 ----
  		   
  	if (!(Cflag || Wflag || Gflag)) {
! 		lat1 = latlong(argv[ntp_optind], 1);
! 		long1 = latlong(argv[ntp_optind + 1], 0);
! 		lat2 = latlong(argv[ntp_optind + 2], 1);
! 		long2 = latlong(argv[ntp_optind + 3], 0);
  		if (hflag) {
  			doit(lat1, long1, lat2, long2, height, "");
***************
*** 202,207 ****
  		 * Compute delay from WWV
  	         */
! 		lat1 = latlong(argv[optind], 1);
! 		long1 = latlong(argv[optind + 1], 0);
  		lat2 = latlong(wwvlat, 1);
  		long2 = latlong(wwvlong, 0);
--- 202,207 ----
  		 * Compute delay from WWV
  	         */
! 		lat1 = latlong(argv[ntp_optind], 1);
! 		long1 = latlong(argv[ntp_optind + 1], 0);
  		lat2 = latlong(wwvlat, 1);
  		long2 = latlong(wwvlong, 0);
***************
*** 229,234 ****
  		}
  	} else if (Cflag) {
! 		lat1 = latlong(argv[optind], 1);
! 		long1 = latlong(argv[optind + 1], 0);
  		lat2 = latlong(chulat, 1);
  		long2 = latlong(chulong, 0);
--- 229,234 ----
  		}
  	} else if (Cflag) {
! 		lat1 = latlong(argv[ntp_optind], 1);
! 		long1 = latlong(argv[ntp_optind + 1], 0);
  		lat2 = latlong(chulat, 1);
  		long2 = latlong(chulong, 0);
***************
*** 244,249 ****
  		lat1 = latlong(goes_up_lat, 1);
  		long1 = latlong(goes_up_long, 0);
! 		lat3 = latlong(argv[optind], 1);
! 		long3 = latlong(argv[optind + 1], 0);
  
  		lat2 = latlong(goes_sat_lat, 1);
--- 244,249 ----
  		lat1 = latlong(goes_up_lat, 1);
  		long1 = latlong(goes_up_long, 0);
! 		lat3 = latlong(argv[ntp_optind], 1);
! 		long3 = latlong(argv[ntp_optind + 1], 0);
  
  		lat2 = latlong(goes_sat_lat, 1);
*** /tmp/RCSA023428	Wed Jan 26 17:56:27 1994
--- conf/Config.CHATHAM	Wed Jan 26 16:33:29 1994
***************
*** 90,96 ****
  #	CLOCKDEFS= line below.  This flag affects xntpd only.
  #
- # There is an occurance of a call to rindex() in the daemon.  You may
- #	have to include a -Drindex=strrchr to get this to load right.
- #
  # To change the location of the configuration file, use a
  #	-DCONFIG_FILE=\\"/local/etc/ntp.conf\\" or something similar.
--- 90,93 ----
***************
*** 110,114 ****
  #	generated by the pps signal. Only one of these flags should be defined.
  #
! DEFS= -DUSELIBKVM -DDEBUG -DSTREAM -DREFCLOCK -DNO_SIGNED_CHAR_DECL -DPPS -DPPSDEV -DXNTP_RETROFIT_STDLIB -DHAVE_UNISTD_H
  
  #
--- 107,111 ----
  #	generated by the pps signal. Only one of these flags should be defined.
  #
! DEFS= -DUSELIBKVM -DDEBUG -DSTREAM -DREFCLOCK -DNO_SIGNED_CHAR_DECL -DPPS -DPPSDEV -DXNTP_RETROFIT_STDLIB -DNTP_POSIX_SOURCE
  
  #
*** /tmp/RCSA023428	Wed Jan 26 17:56:27 1994
--- conf/Config.MONOMOY	Wed Jan 26 16:33:29 1994
***************
*** 85,91 ****
  #	CLOCKDEFS= line below.  This flag affects xntpd only.
  #
- # There is an occurance of a call to rindex() in the daemon.  You may
- #	have to include a -Drindex=strrchr to get this to load right.
- #
  # To change the location of the configuration file, use a
  #	-DCONFIG_FILE=\\"/local/etc/ntp.conf\\" or something similar.
--- 85,88 ----
***************
*** 105,109 ****
  #	be used)
  #
! DEFS= -DBSDI -DUSELIBKVM -DDEBUG -DREFCLOCK -DPPS -DCONFIG_FILE=\\"/usr/local/etc/xntp.conf\\" -DHAVE_UNISTD_H
  
  #
--- 102,106 ----
  #	be used)
  #
! DEFS= -DBSDI -DUSELIBKVM -DDEBUG -DREFCLOCK -DPPS -DCONFIG_FILE=\\"/usr/local/etc/xntp.conf\\" -DNTP_POSIX_SOURCE
  
  #
*** /tmp/RCSA023428	Wed Jan 26 17:56:27 1994
--- conf/Config.TIGER	Wed Jan 26 16:33:30 1994
***************
*** 81,87 ****
  #	CLOCKDEFS= line below.  This flag affects xntpd only.
  #
- # There is an occurance of a call to rindex() in the daemon.  You may
- #	have to include a -Drindex=strrchr to get this to load right.
- #
  # To change the location of the configuration file, use a
  #	-DCONFIG_FILE=\\"/local/etc/ntp.conf\\" or something similar.
--- 81,84 ----
***************
*** 101,105 ****
  #	be used)
  #
! DEFS= -DREFCLOCK -DS_CHAR_DEFINED -DREADKMEM -DDEBUG -DPLL -DXNTP_RETROFIT_STDLIB -DHAVE_UNISTD_H
  
  #
--- 98,102 ----
  #	be used)
  #
! DEFS= -DREFCLOCK -DS_CHAR_DEFINED -DREADKMEM -DDEBUG -DPLL -DXNTP_RETROFIT_STDLIB -DNTP_POSIX_SOURCE
  
  #
*** /tmp/RCSA023428	Wed Jan 26 17:56:27 1994
--- conf/Config.TRURO	Wed Jan 26 16:33:30 1994
***************
*** 87,93 ****
  #	CLOCKDEFS= line below.  This flag affects xntpd only.
  #
- # There is an occurance of a call to rindex() in the daemon.  You may
- #	have to include a -Drindex=strrchr to get this to load right.
- #
  # To change the location of the configuration file, use a
  #	-DCONFIG_FILE=\\"/local/etc/ntp.conf\\" or something similar.
--- 87,90 ----
***************
*** 110,114 ****
  #	generated by the pps signal. Only one of these flags should be defined.
  #
! DEFS= -DDEBUG -DSTREAM -DREFCLOCK -DNO_SIGNED_CHAR_DECL -DSLEWALWAYS -DSOLARIS -DPPS -DSTUPID_SIGNAL -DXNTP_RETROFIT_STDLIB -DHAVE_UNISTD_H
  
  #
--- 107,111 ----
  #	generated by the pps signal. Only one of these flags should be defined.
  #
! DEFS= -DDEBUG -DSTREAM -DREFCLOCK -DNO_SIGNED_CHAR_DECL -DSLEWALWAYS -DSOLARIS -DPPS -DSTUPID_SIGNAL -DXNTP_RETROFIT_STDLIB -DNTP_POSIX_SOURCE
  
  #
*** /tmp/RCSA023441	Wed Jan 26 17:56:29 1994
--- include/l_stdlib.h	Wed Jan 26 16:33:30 1994
***************
*** 39,43 ****
  #if !defined(NTP_POSIX_SOURCE)
  extern  int	atoi		P((char *));
- extern  void	bcopy		P((char *, char *, int));
  extern	int	dup2		P((int, int));
  extern	int	execve		P((char *, char **,char **));
--- 39,42 ----
***************
*** 51,58 ****
  #endif
  
- #ifndef bzero			/* XXX macro prototyping clash */
- extern  void    bzero		P((char *, int));
- extern  int	bcmp		P((char *, char *, int));
- #endif
  extern  char   *mktemp		P((char *));	
  
--- 50,53 ----
***************
*** 193,200 ****
  #ifndef NTP_POSIX_SOURCE
  extern  int	atoi		P((char *));
- extern  void	bcopy		P((char *, char *, int));
- extern  void    bzero		P((char *, int));
- extern  int	bcmp		P((char *, char *, int));
- extern  void	bcopy		P((char *, char *, int));
  extern	int	execve		P((char *, char **,char **));
  extern	int	fork		P((void));
--- 188,191 ----
*** /tmp/RCSA023441	Wed Jan 26 17:56:29 1994
--- include/ntp.h	Wed Jan 26 16:33:30 1994
***************
*** 329,333 ****
  
  /*
!  * Definitions for the clear() routine.  We use bzero() to clear
   * the parts of the peer structure which go to zero.  These are
   * used to calculate the start address and length of the area.
--- 329,333 ----
  
  /*
!  * Definitions for the clear() routine.  We use memset() to clear
   * the parts of the peer structure which go to zero.  These are
   * used to calculate the start address and length of the area.
*** /tmp/RCSA023441	Wed Jan 26 17:56:29 1994
--- include/ntp_machine.h	Wed Jan 26 16:33:31 1994
***************
*** 1,3 ****
! /* ntp_compat.h,v 3.1 1993/07/06 01:06:49 jbj Exp
   * Collect all machine dependent idiosyncrasies in one place.
   */
--- 1,3 ----
! /* ntp_machine.h,v 3.1 1993/07/06 01:06:49 jbj Exp
   * Collect all machine dependent idiosyncrasies in one place.
   */
***************
*** 53,61 ****
  
  THIS MAKES PORTS TO NEW SYSTEMS EASY - You only have to wory about
! 		                       kernal mucking.
  
    NTP_POSIX_SOURCE  - Use POSIX functions over bsd functions and att functions.
  		      This is NOT the same as _POSIX_SOURCE.
! 		      It is much weeker!
  
  
--- 53,61 ----
  
  THIS MAKES PORTS TO NEW SYSTEMS EASY - You only have to wory about
! 		                       kernel mucking.
  
    NTP_POSIX_SOURCE  - Use POSIX functions over bsd functions and att functions.
  		      This is NOT the same as _POSIX_SOURCE.
! 		      It is much weaker!
  
  
***************
*** 95,99 ****
    UNIX V.4 machines implement a sockets library on top of streams.
    When requesting the IP interface configuration with an ioctl(2) calll,
!   an arrat of ifreq structures are placed in the provided buffer.  Some
    implementations also place the length of the buffer information in
    the first integer position of the buffer.  
--- 95,99 ----
    UNIX V.4 machines implement a sockets library on top of streams.
    When requesting the IP interface configuration with an ioctl(2) calll,
!   an array of ifreq structures are placed in the provided buffer.  Some
    implementations also place the length of the buffer information in
    the first integer position of the buffer.  
***************
*** 115,121 ****
    RETSIGTYPE        - Define signal function type.
    NO_SIGNED_CHAR_DECL - No "signed char" see include/ntp.h
!   LOCK_PROCESS      -  Have plock.
    UDP_WILDCARD_DELIVERY
! 		    - these systems deliver broadcast pakets to the wildcard
  		      port instead to a port bound to the interface bound
  		      to the correct broadcast address - are these
--- 115,121 ----
    RETSIGTYPE        - Define signal function type.
    NO_SIGNED_CHAR_DECL - No "signed char" see include/ntp.h
!   LOCK_PROCESS      - Have plock.
    UDP_WILDCARD_DELIVERY
! 		    - these systems deliver broadcast packets to the wildcard
  		      port instead to a port bound to the interface bound
  		      to the correct broadcast address - are these
***************
*** 122,133 ****
  		      implementations broken or did the spec change ?
  
-   HAVE_UNISTD_H     - Maybe should be part of NTP_POSIX_SOURCE ?
- 
  You could just put the defines on the DEFS line in machines/<os> file.
! I don't since there are lost of different types compiler that a systemm might
! have, some that can do proto typing and others that cannot on the saem system.
! I get a chanse to twiddle some of the configuration paramasters at compile
! time based on compler/machine combinatsions by using this include file.
! See convex, aix and sun configurations see how complex it get.
  
  */
--- 122,135 ----
  		      implementations broken or did the spec change ?
  
  You could just put the defines on the DEFS line in machines/<os> file.
! I don't since there are lots of different types of compiler that a system might
! have, some that can do prototyping and others that cannot on the saem system.
! I get a chance to twiddle some of the configuration paramasters at compile
! time based on compler/machine combinations by using this include file.
! See convex, aix and sun configurations see how complex it gets.
! 
! Note that it _is_ considered reasonable to add some system-specific defines
! to the machine/<os> file if it would be too inconvenient to puzzle them out
! in this file.
  
  */
***************
*** 145,152 ****
   * Keep USE_PROTOTYPES and _NO_PROTO in step.
   */
! #if  defined(_NO_PROTO)&&defined(USE_PROTOTYPES)
  #undef USE_PROTOTYPES
  #endif
! #if  !defined(_NO_PROTO)&&!defined(USE_PROTOTYPES)
  #define USE_PROTOTYPES
  #endif
--- 147,154 ----
   * Keep USE_PROTOTYPES and _NO_PROTO in step.
   */
! #if defined(_NO_PROTO) && defined(USE_PROTOTYPES)
  #undef USE_PROTOTYPES
  #endif
! #if !defined(_NO_PROTO) && !defined(USE_PROTOTYPES)
  #define USE_PROTOTYPES
  #endif
***************
*** 204,208 ****
   * Convex
   */
! #if  defined(SYS_CONVEXOS10)||defined(SYS_CONVEXOS9)
  #define HAVE_SIGNALED_IO
  #define HAVE_N_UN
--- 206,210 ----
   * Convex
   */
! #if defined(SYS_CONVEXOS10) || defined(SYS_CONVEXOS9)
  #define HAVE_SIGNALED_IO
  #define HAVE_N_UN
***************
*** 213,221 ****
  #define NO_SIGNED_CHAR_DECL
  #else
! #if defined(__stdc__)&&!defined(USE_PROTOTYPES)
  #define USE_PROTOTYPES
  #endif
! #if !defined(__stdc__)&&defined(USE_PROTOTYPES)
! #undef  USE_PROTOTYPES
  #endif
  #define NTP_POSIX_SOURCE
--- 215,223 ----
  #define NO_SIGNED_CHAR_DECL
  #else
! #if defined(__stdc__) && !defined(USE_PROTOTYPES)
  #define USE_PROTOTYPES
  #endif
! #if !defined(__stdc__) && defined(USE_PROTOTYPES)
! #undef USE_PROTOTYPES
  #endif
  #define NTP_POSIX_SOURCE
***************
*** 253,257 ****
   * AUX
   */
! #if defined(SYS_AUX2)||defined(SYS_AUX3)
  #define NO_SIGNED_CHAR_DECL
  #define HAVE_READKMEM
--- 255,259 ----
   * AUX
   */
! #if defined(SYS_AUX2) || defined(SYS_AUX3)
  #define NO_SIGNED_CHAR_DECL
  #define HAVE_READKMEM
***************
*** 292,296 ****
  #define NTP_POSIX_SOURCE
  #define HAVE_SIGNALED_IO
- #define HAVE_UNISTD_H
  #define NO_SIGNED_CHAR_DECL
  #define LOCK_PROCESS
--- 294,297 ----
***************
*** 302,305 ****
--- 303,308 ----
  #define HAVE_READKMEM
  #endif
+ #define getdtablesize() sysconf(_SC_OPEN_MAX)
+ #define setlinebuf(f) setvbuf(f, NULL, _IOLBF, 0)
  #endif
  
***************
*** 313,316 ****
--- 316,320 ----
  #define HAVE_BSD_NICE
  #define HAVE_BSD_TTYS
+ #define HAVE_TERMIOS
  #endif
  
***************
*** 342,346 ****
  
  /*
!  * DECOSF1
   */
  #if defined(SYS_DECOSF1)
--- 346,350 ----
  
  /*
!  * DEC AXP OSF/1
   */
  #if defined(SYS_DECOSF1)
***************
*** 354,357 ****
--- 358,362 ----
  /*
   * I386
+  * XXX - what OS?
   */
  #if defined(SYS_I386)
***************
*** 412,416 ****
  
  /*
!  * Sony
   */
  #if defined(SYS_SONY)
--- 417,421 ----
  
  /*
!  * Sony NEWS
   */
  #if defined(SYS_SONY)
***************
*** 422,425 ****
--- 427,431 ----
  /*
   * VAX
+  * XXX - VMS?
   */
  #if defined(SYS_VAX)
***************
*** 435,439 ****
  #define HAVE_ATT_SETPGRP
  #define USE_PROTOTYPES
- #define HAVE_UNISTD_H
  #define NTP_POSIX_SOURCE
  #define HAVE_ATT_NICE
--- 441,444 ----
***************
*** 484,490 ****
  #endif	/* NTP_SYSCALLS_STD */
  
! #if	!defined(HAVE_ATT_NICE) && !defined(HAVE_BSD_NICE) && !defined(HAVE_NO_NICE)
  	ERROR You_must_define_one_of_the_HAVE_xx_NICE_defines
  #endif
  
  #endif /* __ntp_machine */
--- 489,545 ----
  #endif	/* NTP_SYSCALLS_STD */
  
! #if	!defined(HAVE_ATT_NICE) \
! 	&& !defined(HAVE_BSD_NICE) \
! 	&& !defined(HAVE_NO_NICE)
  	ERROR You_must_define_one_of_the_HAVE_xx_NICE_defines
  #endif
+ 
+ 
+ #if !defined(XNTP_BIG_ENDIAN) && !defined(XNTP_LITTLE_ENDIAN)
+ 
+ # if defined(XNTP_AUTO_ENDIAN)
+ #  include <netinet/in.h>
+ 
+ #  if BYTE_ORDER == BIG_ENDIAN
+ #   define XNTP_BIG_ENDIAN
+ #  endif
+ #  if BYTE_ORDER == LITTLE_ENDIAN
+ #   define XNTP_LITTLE_ENDIAN
+ #  endif
+ 
+ # else	/* AUTO */
+ 
+ #  ifdef	WORDS_BIGENDIAN
+ #   define	XNTP_BIG_ENDIAN	1
+ #  else
+ #   define	XNTP_LITTLE_ENDIAN	1
+ #  endif
+ 
+ # endif	/* AUTO */
+ 
+ #endif	/* !BIG && !LITTLE */
+ 
+ /*
+  * Byte order woes.  The DES code is sensitive to byte order.  This
+  * used to be resolved by calling ntohl() and htonl() to swap things
+  * around, but this turned out to be quite costly on Vaxes where those
+  * things are actual functions.  The code now straightens out byte
+  * order troubles on its own, with no performance penalty for little
+  * end first machines, but at great expense to cleanliness.
+  */
+ #if !defined(XNTP_BIG_ENDIAN) && !defined(XNTP_LITTLE_ENDIAN)
+ 	/*
+ 	 * Pick one or the other.
+ 	 */
+ 	BYTE_ORDER_NOT_DEFINED_FOR_AUTHENTICATION
+ #endif
+ 
+ #if defined(XNTP_BIG_ENDIAN) && defined(XNTP_LITTLE_ENDIAN)
+ 	/*
+ 	 * Pick one or the other.
+ 	 */
+ 	BYTE_ORDER_NOT_DEFINED_FOR_AUTHENTICATION
+ #endif
+ 
  
  #endif /* __ntp_machine */
*** /tmp/RCSA023441	Wed Jan 26 17:56:30 1994
--- include/ntp_select.h	Wed Jan 26 16:33:31 1994
***************
*** 15,19 ****
  #define FD_CLR(n, p)    ((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
  #define FD_ISSET(n, p)  ((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
! #define FD_ZERO(p)      bzero((char *)(p), sizeof(*(p)))
  #endif
  
--- 15,19 ----
  #define FD_CLR(n, p)    ((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
  #define FD_ISSET(n, p)  ((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
! #define FD_ZERO(p)      memset((char *)(p), 0, sizeof(*(p)))
  #endif
  
*** /tmp/RCSA023441	Wed Jan 26 17:56:30 1994
--- include/ntp_stdlib.h	Wed Jan 26 16:33:31 1994
***************
*** 48,52 ****
  extern	int	clocktime	P((int, int, int, int, int, U_LONG, U_LONG *, U_LONG *));
  extern	char *	emalloc		P((u_int));
! extern	int	getopt_l	P((int, char **, char *));
  extern	void	init_auth	P((void));
  extern	void	init_lib	P((void));
--- 48,52 ----
  extern	int	clocktime	P((int, int, int, int, int, U_LONG, U_LONG *, U_LONG *));
  extern	char *	emalloc		P((u_int));
! extern	int	ntp_getopt	P((int, char **, char *));
  extern	void	init_auth	P((void));
  extern	void	init_lib	P((void));
*** /tmp/RCSA023441	Wed Jan 26 17:56:30 1994
--- include/ntp_string.h	Wed Jan 26 16:33:31 1994
***************
*** 1,4 ****
  /*
!  * Define bcopy, bzero, and bcmp and string op's
   */
  
--- 1,4 ----
  /*
!  * Define string ops: strchr strrchr memcmp memmove memset 
   */
  
***************
*** 8,27 ****
  #ifdef NTP_POSIX_SOURCE
  
! #if defined(HAVE_MEMORY_H)
! #include <memory.h>
! #endif
! 
! #include <string.h>
! 
! #define bcopy(s1,s2,n) memcpy(s2, s1, n)
! #define bzero(s,n)     memset(s, 0, n)
! #define bcmp(s1,s2,n)  memcmp(s1, s2, n)
  
  #else /* NTP_POSIX_SOURCE */
  
! #include <strings.h>
  
! #define  strrchr    rindex
! #define  strchr     index
  
  #endif /*  NTP_POSIX_SOURCE */
--- 8,27 ----
  #ifdef NTP_POSIX_SOURCE
  
! # if defined(HAVE_MEMORY_H)
! #  include <memory.h>
! # endif
  
+ # include <string.h>
+ 
  #else /* NTP_POSIX_SOURCE */
  
! # include <strings.h>
  
! # define strchr(s,c) index(s,c)
! # define strrchr(s,c) rindex(s,c)
! # define memcmp(a,b,c) bcmp(a,b,c)
! # define memmove(t,f,c) bcopy(f,t,c)
! # define memset(a,x,c) if (x == 0x00) bzero(a,c) else ntp_memset((char*)a,x,c)
! void ntp_memset P((char *, int, int));
  
  #endif /*  NTP_POSIX_SOURCE */
*** /tmp/RCSA023456	Wed Jan 26 17:56:31 1994
--- kernel/tty_clk_STREAMS.c	Wed Jan 26 16:33:31 1994
***************
*** 63,67 ****
  
  /*
!  * God only knows why, but linking with strchr() and index() fail
   * on my system, so here's a renamed copy.
   */
--- 63,67 ----
  
  /*
!  * God only knows why, but linking with strchr() fails
   * on my system, so here's a renamed copy.
   */
*** /tmp/RCSA023460	Wed Jan 26 17:56:32 1994
--- lib/a_md512crypt.c	Wed Jan 26 16:33:31 1994
***************
*** 81,86 ****
      MD5Final(&ctx);
  
!     bcopy((char *)ctx.digest, (char *) &pkt[NOCRYPT_LONGS + length/sizeof(U_LONG)],
! 	  BLOCK_OCTETS);
!     return 4 + BLOCK_OCTETS;
  }
--- 81,87 ----
      MD5Final(&ctx);
  
!     memmove((char *) &pkt[NOCRYPT_LONGS + length/sizeof(U_LONG)],
! 	    (char *) ctx.digest,	    
! 	    BLOCK_OCTETS);
!     return (4 + BLOCK_OCTETS);
  }
*** /tmp/RCSA023460	Wed Jan 26 17:56:33 1994
--- lib/a_md5decrypt.c	Wed Jan 26 16:33:32 1994
***************
*** 55,58 ****
      MD5Final(&ctx);
  
!     return (0 == bcmp((char *)ctx.digest, (char *)pkt + length + 4, BLOCK_OCTETS));
  }
--- 55,60 ----
      MD5Final(&ctx);
  
!     return (!memcmp((char *)ctx.digest,
! 		    (char *)pkt + length + 4,
! 		    BLOCK_OCTETS));
  }
*** /tmp/RCSA023460	Wed Jan 26 17:56:33 1994
--- lib/a_md5encrypt.c	Wed Jan 26 16:33:32 1994
***************
*** 64,68 ****
      MD5Final(&ctx);
  
!     bcopy((char *)ctx.digest, (char *) &pkt[NOCRYPT_LONGS + len], BLOCK_OCTETS);
!     return 4 + BLOCK_OCTETS;	/* return size of key and MAC  */
  }
--- 64,70 ----
      MD5Final(&ctx);
  
!     memmove((char *)&pkt[NOCRYPT_LONGS + len],
! 	    (char *)ctx.digest,
! 	    BLOCK_OCTETS);
!     return (4 + BLOCK_OCTETS);	/* return size of key and MAC  */
  }
*** /tmp/RCSA023460	Wed Jan 26 17:56:33 1994
--- lib/authdes.c	Wed Jan 26 16:33:32 1994
***************
*** 4,31 ****
  #include "ntp_stdlib.h"
  
- #if !defined(XNTP_BIG_ENDIAN) && !defined(XNTP_LITTLE_ENDIAN)
- 
- #if defined(XNTP_AUTO_ENDIAN)
- #include <netinet/in.h>
- 
- #if BYTE_ORDER == BIG_ENDIAN
- #define XNTP_BIG_ENDIAN
- #endif
- #if BYTE_ORDER == LITTLE_ENDIAN
- #define XNTP_LITTLE_ENDIAN
- #endif
- 
- #else	/* AUTO */
- 
- #ifdef	WORDS_BIGENDIAN
- #define	XNTP_BIG_ENDIAN	1
- #else
- #define	XNTP_LITTLE_ENDIAN	1
- #endif
- 
- #endif	/* AUTO */
- 
- #endif	/* !BIG && !LITTLE */
- 
  /*
   * There are two entries in here.  auth_subkeys() called to
--- 4,7 ----
***************
*** 33,58 ****
   * auth_des() is called to do the actual encryption/decryption
   */
- 
- /*
-  * Byte order woes.  The DES code is sensitive to byte order.  This
-  * used to be resolved by calling ntohl() and htonl() to swap things
-  * around, but this turned out to be quite costly on Vaxes where those
-  * things are actual functions.  The code now straightens out byte
-  * order troubles on its own, with no performance penalty for little
-  * end first machines, but at great expense to cleanliness.
-  */
- #if !defined(XNTP_BIG_ENDIAN) && !defined(XNTP_LITTLE_ENDIAN)
- 	/*
- 	 * Pick one or the other.
- 	 */
- 	BYTE_ORDER_NOT_DEFINED_FOR_AUTHENTICATION
- #endif
- 
- #if defined(XNTP_BIG_ENDIAN) && defined(XNTP_LITTLE_ENDIAN)
- 	/*
- 	 * Pick one or the other.
- 	 */
- 	BYTE_ORDER_NOT_DEFINED_FOR_AUTHENTICATION
- #endif
  
  /*
--- 9,12 ----
*** /tmp/RCSA023460	Wed Jan 26 17:56:33 1994
--- lib/authkeys.c	Wed Jan 26 16:33:32 1994
***************
*** 110,114 ****
  	 * Initialize hash table and free list
  	 */
! 	bzero((char *)key_hash, sizeof key_hash);
  	cache_flags = cache_keyid = 0;
  
--- 110,114 ----
  	 * Initialize hash table and free list
  	 */
! 	memset((char *)key_hash, 0, sizeof key_hash);
  	cache_flags = cache_keyid = 0;
  
*** /tmp/RCSA023460	Wed Jan 26 17:56:34 1994
--- lib/authusekey.c	Wed Jan 26 16:33:32 1994
***************
*** 97,101 ****
  		 * Make up key from ascii representation
  		 */
! 		bzero((char *) keybytes, sizeof(keybytes));
  		for (i = 0; i < 8 && i < len; i++)
  			keybytes[i] = *cp++ << 1;
--- 97,101 ----
  		 * Make up key from ascii representation
  		 */
! 		memset((char *) keybytes, 0, sizeof(keybytes));
  		for (i = 0; i < 8 && i < len; i++)
  			keybytes[i] = *cp++ << 1;
*** /tmp/RCSA023460	Wed Jan 26 17:56:34 1994
--- lib/dofptoa.c	Wed Jan 26 16:33:33 1994
***************
*** 32,36 ****
  	 * Zero out the buffer
  	 */
! 	bzero((char *)cbuf, sizeof cbuf);
  
  	/*
--- 32,36 ----
  	 * Zero out the buffer
  	 */
! 	memset((char *)cbuf, 0, sizeof cbuf);
  
  	/*
*** /tmp/RCSA023460	Wed Jan 26 17:56:34 1994
--- lib/dolfptoa.c	Wed Jan 26 16:33:33 1994
***************
*** 33,37 ****
  	 * Zero the character buffer
  	 */
! 	bzero((char *) cbuf, sizeof(cbuf));
  
  	/*
--- 33,37 ----
  	 * Zero the character buffer
  	 */
! 	memset((char *) cbuf, 0, sizeof(cbuf));
  
  	/*
*** /tmp/RCSA023460	Wed Jan 26 17:56:34 1994
--- lib/getopt.c	Wed Jan 26 16:33:33 1994
***************
*** 5,9 ****
   * Henry Spencer, changed for 4.3BSD compatibility (in addition to System V).
   * It allows rescanning of an option list by setting optind to 0 before
!  * calling.  Thanks to Dennis Ferguson for the appropriate modifications.
   *
   * This file is in the Public Domain.
--- 5,11 ----
   * Henry Spencer, changed for 4.3BSD compatibility (in addition to System V).
   * It allows rescanning of an option list by setting optind to 0 before
!  * calling, which is why we use it even if the system has its own (in fact,
!  * this one has a unique name so as not to conflict with the system's).
!  * Thanks to Dennis Ferguson for the appropriate modifications.
   *
   * This file is in the Public Domain.
***************
*** 21,57 ****
  #endif	/* lint */
  
! char	*optarg;	/* Global argument pointer. */
! #ifndef	__convex__
! int	optind = 0;	/* Global argv index. */
! #else	/* __convex__ */
! extern	int	optind;	/* Global argv index. */
! #endif	/* __convex__ */
  
- /*
-  * N.B. use following at own risk
-  */
- #ifndef	__convex__
- int	opterr = 1;	/* for compatibility, should error be printed? */
- #else	/* __convex__ */
- extern	int	opterr;	/* for compatibility, should error be printed? */
- #endif	/* __convex__ */
- int	optopt;		/* for compatibility, option character checked */
- 
  static char	*scan = NULL;	/* Private scan pointer. */
  
  /*
!  * Print message about a bad option.  Watch this definition, it's
!  * not a single statement.
   */
! #define	BADOPT(mess, ch)	if (opterr) { \
! 					fputs(argv[0], stderr); \
! 					fputs(mess, stderr); \
! 					(void) putc(ch, stderr); \
! 					(void) putc('\n', stderr); \
! 				} \
! 				return('?')
  
  int
! getopt_l(argc, argv, optstring)
  	int argc;
  	char *argv[];
--- 23,53 ----
  #endif	/* lint */
  
! char	*ntp_optarg;	/* Global argument pointer. */
! int	ntp_optind = 0;	/* Global argv index. */
! int	ntp_opterr = 1;	/* for compatibility, should error be printed? */
! int	ntp_optopt;	/* for compatibility, option character checked */
  
  static char	*scan = NULL;	/* Private scan pointer. */
+ static char	*prog = "amnesia";
  
  /*
!  * Print message about a bad option.
   */
! static int
! badopt(mess, ch)
! 	char *mess;
! 	int ch;
! {
! 	if (ntp_opterr) {
! 		fputs(prog, stderr);
! 		fputs(mess, stderr);
! 		(void) putc(ch, stderr);
! 		(void) putc('\n', stderr);
! 	}
! 	return ('?');
! }
  
  int
! ntp_getopt(argc, argv, optstring)
  	int argc;
  	char *argv[];
***************
*** 61,85 ****
  	register char *place;
  
! 	optarg = NULL;
  
! 	if (optind == 0) {
  		scan = NULL;
! 		optind++;
  	}
  	
  	if (scan == NULL || *scan == '\0') {
! 		if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0')
! 			return EOF;
! 		if (argv[optind][1] == '-' && argv[optind][2] == '\0') {
! 			optind++;
! 			return EOF;
  		}
  	
! 		scan = argv[optind]+1;
! 		optind++;
  	}
  
  	c = *scan++;
! 	optopt = c & 0377;
  	for (place = optstring; place != NULL && *place != '\0'; ++place)
  		if (*place == c)
--- 57,85 ----
  	register char *place;
  
! 	prog = argv[0];
! 	ntp_optarg = NULL;
  
! 	if (ntp_optind == 0) {
  		scan = NULL;
! 		ntp_optind++;
  	}
  	
  	if (scan == NULL || *scan == '\0') {
! 		if (ntp_optind >= argc
! 		    || argv[ntp_optind][0] != '-'
! 		    || argv[ntp_optind][1] == '\0') {
! 			return (EOF);
! 		}
! 		if (argv[ntp_optind][1] == '-'
! 		    && argv[ntp_optind][2] == '\0') {
! 			ntp_optind++;
! 			return (EOF);
  		}
  	
! 		scan = argv[ntp_optind++]+1;
  	}
  
  	c = *scan++;
! 	ntp_optopt = c & 0377;
  	for (place = optstring; place != NULL && *place != '\0'; ++place)
  		if (*place == c)
***************
*** 87,91 ****
  
  	if (place == NULL || *place == '\0' || c == ':' || c == '?') {
! 		BADOPT(": unknown option -", c);
  	}
  
--- 87,91 ----
  
  	if (place == NULL || *place == '\0' || c == ':' || c == '?') {
! 		return (badopt(": unknown option -", c));
  	}
  
***************
*** 93,106 ****
  	if (*place == ':') {
  		if (*scan != '\0') {
! 			optarg = scan;
  			scan = NULL;
! 		} else if (optind >= argc) {
! 			BADOPT(": option requires argument -", c);
  		} else {
! 			optarg = argv[optind];
! 			optind++;
  		}
  	}
  
! 	return c&0377;
  }
--- 93,105 ----
  	if (*place == ':') {
  		if (*scan != '\0') {
! 			ntp_optarg = scan;
  			scan = NULL;
! 		} else if (ntp_optind >= argc) {
! 			return (badopt(": option requires argument -", c));
  		} else {
! 			ntp_optarg = argv[ntp_optind++];
  		}
  	}
  
! 	return (c & 0377);
  }
*** /tmp/RCSA023460	Wed Jan 26 17:56:34 1994
--- lib/machines.c	Wed Jan 26 16:33:33 1994
***************
*** 1,18 ****
! /*
!  * provide special support for peculiar architectures
   *
   * Real bummers unite !
   */
  
  #ifdef SYS_PTX
  #include <sys/types.h>
  #include <sys/procstats.h>
! int settimeofday(tvp)
  	struct timeval *tvp;
  {
! 	return stime(&tvp->tv_sec);	/* lie as bad as SysVR4 */
  }
  
! int gettimeofday(tvp)
  	struct timeval *tvp;
  {
--- 1,24 ----
! /* machines.c - provide special support for peculiar architectures
   *
   * Real bummers unite !
+  *
+  * $Id:$
   */
  
+ #include "ntp_stdlib.h"
+ 
  #ifdef SYS_PTX
  #include <sys/types.h>
  #include <sys/procstats.h>
! 
! int
! settimeofday(tvp)
  	struct timeval *tvp;
  {
! 	return (stime(&tvp->tv_sec));	/* lie as bad as SysVR4 */
  }
  
! int
! gettimeofday(tvp)
  	struct timeval *tvp;
  {
***************
*** 21,118 ****
  	 * this is also the most logical syscall for such a function
  	 */
! 	return get_process_stats(tvp, PS_SELF, (struct procstats *) 0,
! 				 (struct procstats *) 0);
! }
! #endif
! 
! #ifdef SYS_HPUX
! /* hpux.c,v 3.1 1993/07/06 01:08:23 jbj Exp
!  * hpux.c -- compatibility routines for HP-UX.
!  * XXX many of these are not needed anymore.
!  */
! #include "ntp_machine.h"
! 
! #ifdef	HAVE_UNISTD_H
! #include <unistd.h>
! #endif
! #include <stdio.h>
! 
! #include "ntp_stdlib.h"
! 
! #if (SYS_HPUX < 8)
! char 
! *index(s, c)
! register char *s;
! register int c;
! {
!     return strchr (s, c);
! }
! 
! 
! char 
! *rindex(s, c)
! register char *s;
! register int c;
! {
!     return strrchr (s, c);
! }
! 
! 
! int 
! bcmp(a, b, count)
! register char *a, *b;
! register int count;
! {
!     return memcmp (a, b, count);
! }
! 
! 
! void 
! bcopy(from, to, count)
! register char *from;
! register char *to;
! register int count;
! {
!    if ((to == from) || (count <= 0))
!        return;
! 
!    if ((to > from) && (to <= (from + count))) {
!        to += count;
!        from += count;
! 
!        do {
! 	   *--to = *--from;
!        }   while (--count);
!    }
!    else {
!        do {
! 	   *to++ = *from++;
!        }   while (--count);
!    }
! }
! 
! 
! void 
! bzero(area, count)
! register char *area;
! register int count;
! {
!     memset(area, 0, count);
  }
  #endif
  
! 
! getdtablesize()
! {
!     return(sysconf(_SC_OPEN_MAX));
! }
! 
! 
! int 
! setlinebuf(a_stream)
!     FILE *a_stream;
  {
!     return setvbuf(a_stream, (char *) NULL, _IOLBF, 0);
  }
! 
! #endif
--- 27,43 ----
  	 * this is also the most logical syscall for such a function
  	 */
! 	return (get_process_stats(tvp, PS_SELF, (struct procstats *) 0,
! 				  (struct procstats *) 0));
  }
  #endif
  
! #if !defined(NTP_POSIX_SOURCE)
! void
! ntp_memset(a, x, c)
! 	char *a;
! 	int x, c;
  {
! 	while (c-- > 0)
! 		*a++ = x;
  }
! #endif /*POSIX*/
*** /tmp/RCSA023460	Wed Jan 26 17:56:34 1994
--- lib/numtohost.c	Wed Jan 26 16:37:59 1994
***************
*** 2,6 ****
   * numtohost - convert network number to host name.
   */
- #include "ntp_string.h"
  #include <netdb.h>
  
--- 2,5 ----
*** /tmp/RCSA023460	Wed Jan 26 17:56:34 1994
--- lib/systime.c	Wed Jan 26 16:33:33 1994
***************
*** 346,350 ****
  	 */
  	if (oldtime != timetv.tv_sec) {
! 		bzero((char *)&ut, sizeof(ut));
  		ut.ut_type = OLD_TIME;
  		ut.ut_time = oldtime;
--- 346,350 ----
  	 */
  	if (oldtime != timetv.tv_sec) {
! 		memset((char *)&ut, 0, sizeof(ut));
  		ut.ut_type = OLD_TIME;
  		ut.ut_time = oldtime;
*** /tmp/RCSA023486	Wed Jan 26 17:56:35 1994
--- machines/bsdi	Wed Jan 26 16:33:33 1994
***************
*** 1,5 ****
  RANLIB=	    ranlib
  DEFS_LOCAL=-DREFCLOCK
! DEFS=      -DSYS_BSDI -DHAVE_TERMIOS
  AUTHDEFS=  -DDES -DMD5
  CLOCKDEFS= -DLOCAL_CLOCK
--- 1,5 ----
  RANLIB=	    ranlib
  DEFS_LOCAL=-DREFCLOCK
! DEFS=      -DSYS_BSDI
  AUTHDEFS=  -DDES -DMD5
  CLOCKDEFS= -DLOCAL_CLOCK
*** /tmp/RCSA023490	Wed Jan 26 17:56:36 1994
--- ntpdate/ntpdate.c	Wed Jan 26 16:33:34 1994
***************
*** 168,173 ****
  	int errflg;
  	int c;
! 	extern char *optarg;
! 	extern int optind;
  	extern char *Version;
  
--- 168,173 ----
  	int errflg;
  	int c;
! 	extern char *ntp_optarg;
! 	extern int ntp_optind;
  	extern char *Version;
  
***************
*** 179,186 ****
  	 * Decode argument list
  	 */
! 	while ((c = getopt_l(argc, argv, "a:bde:k:o:p:qst:v")) != EOF)
  		switch (c) {
  		case 'a':
! 			c = atoi(optarg);
  			sys_authenticate = 1;
  			sys_authkey = (U_LONG)c;
--- 179,186 ----
  	 * Decode argument list
  	 */
! 	while ((c = ntp_getopt(argc, argv, "a:bde:k:o:p:qst:v")) != EOF)
  		switch (c) {
  		case 'a':
! 			c = atoi(ntp_optarg);
  			sys_authenticate = 1;
  			sys_authkey = (U_LONG)c;
***************
*** 193,201 ****
  			break;
  		case 'e':
! 			if (!atolfp(optarg, &tmp)
  			    || tmp.l_ui != 0) {
  				(void) fprintf(stderr,
  				    "%s: encryption delay %s is unlikely\n",
! 				    progname, optarg);
  				errflg++;
  			} else {
--- 193,201 ----
  			break;
  		case 'e':
! 			if (!atolfp(ntp_optarg, &tmp)
  			    || tmp.l_ui != 0) {
  				(void) fprintf(stderr,
  				    "%s: encryption delay %s is unlikely\n",
! 				    progname, ntp_optarg);
  				errflg++;
  			} else {
***************
*** 204,214 ****
  			break;
  		case 'k':
! 			key_file = optarg;
  			break;
  		case 'o':
! 			sys_version = atoi(optarg);
  			break;
  		case 'p':
! 			c = atoi(optarg);
  			if (c <= 0 || c > NTP_SHIFT) {
  				(void) fprintf(stderr,
--- 204,214 ----
  			break;
  		case 'k':
! 			key_file = ntp_optarg;
  			break;
  		case 'o':
! 			sys_version = atoi(ntp_optarg);
  			break;
  		case 'p':
! 			c = atoi(ntp_optarg);
  			if (c <= 0 || c > NTP_SHIFT) {
  				(void) fprintf(stderr,
***************
*** 227,234 ****
  			break;
  		case 't':
! 			if (!atolfp(optarg, &tmp)) {
  				(void) fprintf(stderr,
  				    "%s: timeout %s is undecodeable\n",
! 				    progname, optarg);
  				errflg++;
  			} else {
--- 227,234 ----
  			break;
  		case 't':
! 			if (!atolfp(ntp_optarg, &tmp)) {
  				(void) fprintf(stderr,
  				    "%s: timeout %s is undecodeable\n",
! 				    progname, ntp_optarg);
  				errflg++;
  			} else {
***************
*** 249,253 ****
  		}
  	
! 	sys_maxservers = argc - optind;
  	if (errflg || sys_maxservers == 0) {
  		(void) fprintf(stderr,
--- 249,253 ----
  		}
  	
! 	sys_maxservers = argc - ntp_optind;
  	if (errflg || sys_maxservers == 0) {
  		(void) fprintf(stderr,
***************
*** 294,299 ****
  	 * Add servers we are going to be polling
  	 */
! 	for ( ; optind < argc; optind++)
! 		addserver(argv[optind]);
  
  	if (sys_numservers == 0) {
--- 294,299 ----
  	 * Add servers we are going to be polling
  	 */
! 	for ( ; ntp_optind < argc; ntp_optind++)
! 		addserver(argv[ntp_optind]);
  
  	if (sys_numservers == 0) {
***************
*** 1031,1035 ****
  
  	server = (struct server *)emalloc(sizeof(struct server));
! 	bzero((char *)server, sizeof(struct server));
  
  	server->srcadr.sin_family = AF_INET;
--- 1031,1035 ----
  
  	server = (struct server *)emalloc(sizeof(struct server));
! 	memset((char *)server, 0, sizeof(struct server));
  
  	server->srcadr.sin_family = AF_INET;
***************
*** 1189,1193 ****
  		struct sockaddr_in addr;
  
! 		bzero((char *)&addr, sizeof addr);
  		addr.sin_family = AF_INET;
  		addr.sin_port = htons(NTP_PORT);
--- 1189,1193 ----
  		struct sockaddr_in addr;
  
! 		memset((char *)&addr, 0, sizeof addr);
  		addr.sin_family = AF_INET;
  		addr.sin_port = htons(NTP_PORT);
***************
*** 1483,1490 ****
  		return 1;
  	} else if ((hp = gethostbyname(host)) != 0) {
! 		bcopy(hp->h_addr, (char *)num, sizeof(U_LONG));
! 		return 1;
  	}
! 	return 0;
  }
  
--- 1483,1490 ----
  		return 1;
  	} else if ((hp = gethostbyname(host)) != 0) {
! 		memmove((char *)num, hp->h_addr, sizeof(U_LONG));
! 		return (1);
  	}
! 	return (0);
  }
  
***************
*** 1520,1524 ****
  	if (pp->stratum == 1) {
  		junk[4] = 0;
! 		bcopy((char *)&pp->refid, junk, 4);
  		str = junk;
  	} else {
--- 1520,1524 ----
  	if (pp->stratum == 1) {
  		junk[4] = 0;
! 		memmove(junk, (char *)&pp->refid, 4);
  		str = junk;
  	} else {
*** /tmp/RCSA023494	Wed Jan 26 17:56:37 1994
--- ntpq/ntpq.c	Wed Jan 26 16:33:34 1994
***************
*** 510,515 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  
  	delay_time.l_ui = 0;
--- 510,515 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	delay_time.l_ui = 0;
***************
*** 517,524 ****
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "c:dinp")) != EOF)
  		switch (c) {
  		case 'c':
! 			ADDCMD(optarg);
  			break;
  		case 'd':
--- 517,524 ----
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "c:dinp")) != EOF)
  		switch (c) {
  		case 'c':
! 			ADDCMD(ntp_optarg);
  			break;
  		case 'd':
***************
*** 544,552 ****
  		exit(2);
  	}
! 	if (optind == argc) {
  		ADDHOST(DEFHOST);
  	} else {
! 		for (; optind < argc; optind++)
! 			ADDHOST(argv[optind]);
  	}
  
--- 544,552 ----
  		exit(2);
  	}
! 	if (ntp_optind == argc) {
  		ADDHOST(DEFHOST);
  	} else {
! 		for (; ntp_optind < argc; ntp_optind++)
! 			ADDHOST(argv[ntp_optind]);
  	}
  
***************
*** 983,987 ****
  	 * Copy the data into the data buffer.
  	 */
! 	bcopy((char *)rpkt.data, (char *)pktdata + offset, count);
  
  	/*
--- 983,987 ----
  	 * Copy the data into the data buffer.
  	 */
! 	memmove((char *)pktdata + offset, (char *)rpkt.data, count);
  
  	/*
***************
*** 1051,1055 ****
  	 */
  	if (qsize > 0) {
! 		bcopy(qdata, (char *)qpkt.data, qsize);
  		pktsize = qsize + CTL_HEADER_LEN;
  		while (pktsize & (sizeof(U_LONG)-1)) {
--- 1051,1055 ----
  	 */
  	if (qsize > 0) {
! 		memmove((char *)qpkt.data, qdata, qsize);
  		pktsize = qsize + CTL_HEADER_LEN;
  		while (pktsize & (sizeof(U_LONG)-1)) {
***************
*** 1542,1546 ****
  		return 1;
  	} else if ((hp = gethostbyname(host)) != 0) {
! 		bcopy(hp->h_addr, (char *)num, sizeof(U_LONG));
  		if (fullhost != 0)
  			(void) strcpy(fullhost, hp->h_name);
--- 1542,1546 ----
  		return 1;
  	} else if ((hp = gethostbyname(host)) != 0) {
! 		memmove((char *)num, hp->h_addr, sizeof(U_LONG));
  		if (fullhost != 0)
  			(void) strcpy(fullhost, hp->h_name);
*** /tmp/RCSA023494	Wed Jan 26 17:56:37 1994
--- ntpq/ntpq_ops.c	Wed Jan 26 16:33:34 1994
***************
*** 218,221 ****
--- 218,222 ----
  /*
   * strsave - save a string
+  * XXX - should be in libntp.a
   */
  static char *
***************
*** 232,237 ****
  	}
  
! 	bcopy(str, cp, len);
! 	return cp;
  }
  
--- 233,238 ----
  	}
  
! 	memmove(cp, str, len);
! 	return (cp);
  }
  
***************
*** 373,381 ****
  		if (cp != data)
  			*cp++ = ',';
! 		bcopy(vl->name, cp, namelen);
  		cp += namelen;
  		if (valuelen != 0) {
  			*cp++ = '=';
! 			bcopy(vl->value, cp, valuelen);
  			cp += valuelen;
  		}
--- 374,382 ----
  		if (cp != data)
  			*cp++ = ',';
! 		memmove(cp, vl->name, namelen);
  		cp += namelen;
  		if (valuelen != 0) {
  			*cp++ = '=';
! 			memmove(cp, vl->value, valuelen);
  			cp += valuelen;
  		}
***************
*** 601,605 ****
  		return;
  
! 	bzero((char *)tmplist, sizeof(tmplist));
  	if (pcmd->nargs >= 2)
  		doaddvlist(tmplist, pcmd->argval[1].string);
--- 602,606 ----
  		return;
  
! 	memset((char *)tmplist, 0, sizeof(tmplist));
  	if (pcmd->nargs >= 2)
  		doaddvlist(tmplist, pcmd->argval[1].string);
***************
*** 632,636 ****
  		return;
  
! 	bzero((char *)tmplist, sizeof(tmplist));
  	doaddvlist(tmplist, pcmd->argval[1].string);
  
--- 633,637 ----
  		return;
  
! 	memset((char *)tmplist, 0, sizeof(tmplist));
  	doaddvlist(tmplist, pcmd->argval[1].string);
  
***************
*** 691,695 ****
  		return;
  
! 	bzero((char *)tmplist, sizeof(tmplist));
  	if (pcmd->nargs >= 2)
  		doaddvlist(tmplist, pcmd->argval[1].string);
--- 692,696 ----
  		return;
  
! 	memset((char *)tmplist, 0, sizeof(tmplist));
  	if (pcmd->nargs >= 2)
  		doaddvlist(tmplist, pcmd->argval[1].string);
***************
*** 803,807 ****
  		return;
  
! 	bzero((char *)tmplist, sizeof(tmplist));
  	if (pcmd->nargs >= 3)
  		doaddvlist(tmplist, pcmd->argval[2].string);
--- 804,808 ----
  		return;
  
! 	memset((char *)tmplist, 0, sizeof(tmplist));
  	if (pcmd->nargs >= 3)
  		doaddvlist(tmplist, pcmd->argval[2].string);
***************
*** 1283,1287 ****
  	extern struct ctl_var peer_var[];
  
! 	bzero((char *)havevar, sizeof(havevar));
  	gettstamp(&ts);
  	
--- 1284,1288 ----
  	extern struct ctl_var peer_var[];
  
! 	memset((char *)havevar, 0, sizeof(havevar));
  	gettstamp(&ts);
  	
*** /tmp/RCSA023500	Wed Jan 26 17:56:38 1994
--- ntptrace/ntptrace.c	Wed Jan 26 16:33:35 1994
***************
*** 112,117 ****
  	int errflg;
  	int c;
! 	extern char *optarg;
! 	extern int optind;
  	extern char *Version;
  
--- 112,117 ----
  	int errflg;
  	int c;
! 	extern char *ntp_optarg;
! 	extern int ntp_optind;
  	extern char *Version;
  
***************
*** 122,126 ****
  	 * Decode argument list
  	 */
! 	while ((c = getopt_l(argc, argv, "do:nr:t:v")) != EOF)
  		switch (c) {
  		case 'd':
--- 122,126 ----
  	 * Decode argument list
  	 */
! 	while ((c = ntp_getopt(argc, argv, "do:nr:t:v")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 131,138 ****
  			break;
  		case 'o':
! 			sys_version = atoi(optarg);
  			break;
  		case 'r':
! 			sys_retries = atoi(optarg);
  			if (sys_retries < 1) {
  			    (void)fprintf(stderr,
--- 131,138 ----
  			break;
  		case 'o':
! 			sys_version = atoi(ntp_optarg);
  			break;
  		case 'r':
! 			sys_retries = atoi(ntp_optarg);
  			if (sys_retries < 1) {
  			    (void)fprintf(stderr,
***************
*** 143,147 ****
  			break;
  		case 't':
! 			sys_timeout = atoi(optarg);
  			if (sys_timeout < 1) {
  			    (void)fprintf(stderr,
--- 143,147 ----
  			break;
  		case 't':
! 			sys_timeout = atoi(ntp_optarg);
  			if (sys_timeout < 1) {
  			    (void)fprintf(stderr,
***************
*** 161,165 ****
  		}
  	
! 	if (errflg || (argc - optind) > 1) {
  		(void) fprintf(stderr,
  			"usage: %s [-vnd] [-r retries] [-t timeout] [server]\n",
--- 161,165 ----
  		}
  	
! 	if (errflg || (argc - ntp_optind) > 1) {
  		(void) fprintf(stderr,
  			"usage: %s [-vnd] [-r retries] [-t timeout] [server]\n",
***************
*** 183,188 ****
  		syslog(LOG_NOTICE, "%s", Version);
  
! 	if ((argc - optind) == 1)
! 		firstserver = addservbyname(argv[optind]);
  	else
  		firstserver = addservbyname("localhost");
--- 183,188 ----
  		syslog(LOG_NOTICE, "%s", Version);
  
! 	if ((argc - ntp_optind) == 1)
! 		firstserver = addservbyname(argv[ntp_optind]);
  	else
  		firstserver = addservbyname("localhost");
***************
*** 503,507 ****
  
  	server = (struct server *)emalloc(sizeof(struct server));
! 	bzero((char *)server, sizeof(struct server));
  
  	server->srcadr.sin_family = AF_INET;
--- 503,507 ----
  
  	server = (struct server *)emalloc(sizeof(struct server));
! 	memset((char *)server, 0, sizeof(struct server));
  
  	server->srcadr.sin_family = AF_INET;
***************
*** 617,621 ****
  		return 1;
  	} else if ((hp = gethostbyname(host)) != 0) {
! 		bcopy(hp->h_addr, (char *)num, sizeof(U_LONG));
  		return 1;
  	}
--- 617,621 ----
  		return 1;
  	} else if ((hp = gethostbyname(host)) != 0) {
! 		memmove((char *)num, hp->h_addr, sizeof(U_LONG));
  		return 1;
  	}
***************
*** 736,740 ****
  	if (pp->stratum == 1) {
  		junk[4] = 0;
! 		bcopy((char *)&pp->refid, junk, 4);
  		str = junk;
  		(void) fprintf(fp, "'%s'", str);
--- 736,740 ----
  	if (pp->stratum == 1) {
  		junk[4] = 0;
! 		memmove(junk, (char *)&pp->refid, 4);
  		str = junk;
  		(void) fprintf(fp, "'%s'", str);
*** /tmp/RCSA023505	Wed Jan 26 17:56:39 1994
--- parse/util/testdcf.c	Wed Jan 26 16:33:35 1994
***************
*** 353,357 ****
  	    }
  
! 	  bzero(term.c_cc, sizeof(term.c_cc));
  	  term.c_cc[VMIN] = 1;
  	  term.c_cflag = B50|CS8|CREAD|CLOCAL;
--- 353,357 ----
  	    }
  
! 	  memset(term.c_cc, 0, sizeof(term.c_cc));
  	  term.c_cc[VMIN] = 1;
  	  term.c_cflag = B50|CS8|CREAD|CLOCAL;
*** /tmp/RCSA023510	Wed Jan 26 17:56:40 1994
--- ppsclock/ppstest/ppstest.c	Wed Jan 26 16:33:35 1994
***************
*** 103,107 ****
  	speed_t speed = B4800;
  
! 	bzero((char *)&termios, sizeof(termios));
  	termios.c_cflag = CS8 | CREAD | CLOCAL;
  	termios.c_iflag = IGNCR;
--- 103,107 ----
  	speed_t speed = B4800;
  
! 	memset((char *)&termios, 0, sizeof(termios));
  	termios.c_cflag = CS8 | CREAD | CLOCAL;
  	termios.c_iflag = IGNCR;
*** /tmp/RCSA023525	Wed Jan 26 17:56:43 1994
--- scripts/autoconf	Wed Jan 26 16:33:35 1994
***************
*** 324,329 ****
    {
  test -n "$verbose" && \
! echo '	defining' HAVE_UNISTD_H
! DEFS="$DEFS -DHAVE_UNISTD_H=1"
  }
  
--- 324,329 ----
    {
  test -n "$verbose" && \
! echo '	defining' NTP_POSIX_SOURCE
! DEFS="$DEFS -DNTP_POSIX_SOURCE=1"
  }
  
*** /tmp/RCSA023535	Wed Jan 26 17:56:46 1994
--- util/Makefile.tmpl	Wed Jan 26 16:33:35 1994
***************
*** 33,37 ****
  
  tickadj: $(TKOBJS)
! 	$(CC) $(COPTS) -o $@ $(TKOBJS) $(DAEMONLIBS) $(RESLIB) $(COMPAT)
  
  ntptime: $(NTOBJS)
--- 33,37 ----
  
  tickadj: $(TKOBJS)
! 	$(CC) $(COPTS) -o $@ $(TKOBJS) $(LIB) $(DAEMONLIBS) $(RESLIB) $(COMPAT)
  
  ntptime: $(NTOBJS)
*** /tmp/RCSA023535	Wed Jan 26 17:56:47 1994
--- util/ntptime.c	Wed Jan 26 16:33:36 1994
***************
*** 38,42 ****
  extern int sigvec	P((int, struct sigvec *, struct sigvec *));
  void pll_trap		P((void));
- extern int getopt_l	P((int, char **, char *));
  
  static struct sigvec newsigsys;	/* new sigvec status */
--- 38,41 ----
***************
*** 52,57 ****
  	char *argv[];
  {
! 	extern int optind;
! 	extern char *optarg;
  	int status;
  	struct ntptimeval ntv;
--- 51,56 ----
  	char *argv[];
  {
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  	int status;
  	struct ntptimeval ntv;
***************
*** 67,71 ****
  	ntx.mode = 0;
          progname = argv[0];
! 	while ((c = getopt_l(argc, argv, optargs)) != EOF) switch (c) {
  		case 'c':
  			cost++;
--- 66,70 ----
  	ntx.mode = 0;
          progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, optargs)) != EOF) switch (c) {
  		case 'c':
  			cost++;
***************
*** 73,81 ****
  		case 'e':
  			ntx.mode |= ADJ_ESTERROR;
! 			ntx.esterror = atoi(optarg);
  			break;
  		case 'f':
  			ntx.mode |= ADJ_FREQUENCY;
! 			ntx.frequency = (int) (atof(optarg) * (1 << SHIFT_USEC));
  			if (ntx.frequency < (-100 << SHIFT_USEC)
  			||  ntx.frequency > ( 100 << SHIFT_USEC)) errflg++;
--- 72,81 ----
  		case 'e':
  			ntx.mode |= ADJ_ESTERROR;
! 			ntx.esterror = atoi(ntp_optarg);
  			break;
  		case 'f':
  			ntx.mode |= ADJ_FREQUENCY;
! 			ntx.frequency = (int) (atof(ntp_optarg)
! 					       * (1 << SHIFT_USEC));
  			if (ntx.frequency < (-100 << SHIFT_USEC)
  			||  ntx.frequency > ( 100 << SHIFT_USEC)) errflg++;
***************
*** 83,91 ****
  		case 'm':
  			ntx.mode |= ADJ_MAXERROR;
! 			ntx.maxerror = atoi(optarg);
  			break;
  		case 'o':
  			ntx.mode |= ADJ_OFFSET;
! 			ntx.offset = atoi(optarg);
  			break;
  		case 'r':
--- 83,91 ----
  		case 'm':
  			ntx.mode |= ADJ_MAXERROR;
! 			ntx.maxerror = atoi(ntp_optarg);
  			break;
  		case 'o':
  			ntx.mode |= ADJ_OFFSET;
! 			ntx.offset = atoi(ntp_optarg);
  			break;
  		case 'r':
***************
*** 94,98 ****
  		case 's':
  			ntx.mode |= ADJ_STATUS;
! 			ntx.status = atoi(optarg);
  			if (ntx.status < 0 || ntx.status > 4) errflg++;
  			break;
--- 94,98 ----
  		case 's':
  			ntx.mode |= ADJ_STATUS;
! 			ntx.status = atoi(ntp_optarg);
  			if (ntx.status < 0 || ntx.status > 4) errflg++;
  			break;
***************
*** 99,103 ****
  		case 't':
  			ntx.mode |= ADJ_TIMECONST;
! 			ntx.time_constant = atoi(optarg);
  			if (ntx.time_constant < 0 || ntx.time_constant > MAXTC)
  				errflg++;
--- 99,103 ----
  		case 't':
  			ntx.mode |= ADJ_TIMECONST;
! 			ntx.time_constant = atoi(ntp_optarg);
  			if (ntx.time_constant < 0 || ntx.time_constant > MAXTC)
  				errflg++;
***************
*** 106,110 ****
  			errflg++;
  	}
! 	if (errflg || (optind != argc)) {
  		(void) fprintf(stderr,
  			"usage: %s [-%s]\n\n\
--- 106,110 ----
  			errflg++;
  	}
! 	if (errflg || (ntp_optind != argc)) {
  		(void) fprintf(stderr,
  			"usage: %s [-%s]\n\n\
*** /tmp/RCSA023535	Wed Jan 26 17:56:47 1994
--- util/tickadj.c	Wed Jan 26 16:33:36 1994
***************
*** 62,68 ****
  static	void	writevar	P((int, unsigned long, int));
  static	void	readvar		P((int, unsigned long, int *));
- #ifndef NTP_POSIX_SOURCE
- extern	int	getopt		P((int, char **, char *));
- #endif
  
  /*
--- 62,65 ----
***************
*** 76,81 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  	unsigned long tickadj_offset;
  	unsigned long tick_offset;
--- 73,78 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  	unsigned long tickadj_offset;
  	unsigned long tick_offset;
***************
*** 95,99 ****
  
  	progname = argv[0];
! 	while ((c = getopt(argc, argv, "a:Adkqpst:")) != EOF)
  		switch (c) {
  		case 'd':
--- 92,96 ----
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "a:Adkqpst:")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 110,118 ****
  			break;
  		case 'a':
! 			writetickadj = atoi(optarg);
  			if (writetickadj <= 0) {
  				(void) fprintf(stderr,
  				    "%s: unlikely value for tickadj: %s\n",
! 				    progname, optarg);
  				errflg++;
  			}
--- 107,115 ----
  			break;
  		case 'a':
! 			writetickadj = atoi(ntp_optarg);
  			if (writetickadj <= 0) {
  				(void) fprintf(stderr,
  				    "%s: unlikely value for tickadj: %s\n",
! 				    progname, ntp_optarg);
  				errflg++;
  			}
***************
*** 125,133 ****
  			break;
  		case 't':
! 			writetick = atoi(optarg);
  			if (writetick <= 0) {
  				(void) fprintf(stderr,
  				    "%s: unlikely value for tick: %s\n",
! 				    progname, optarg);
  				errflg++;
  			}
--- 122,130 ----
  			break;
  		case 't':
! 			writetick = atoi(ntp_optarg);
  			if (writetick <= 0) {
  				(void) fprintf(stderr,
  				    "%s: unlikely value for tick: %s\n",
! 				    progname, ntp_optarg);
  				errflg++;
  			}
***************
*** 137,141 ****
  			break;
  		}
! 	if (errflg || optind != argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [-Aqsp] [-a newadj] [-t newtick]\n", progname);
--- 134,138 ----
  			break;
  		}
! 	if (errflg || ntp_optind != argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [-Aqsp] [-a newadj] [-t newtick]\n", progname);
*** /tmp/RCSA023543	Wed Jan 26 17:56:49 1994
--- xntpd/ntp_config.c	Wed Jan 26 16:33:36 1994
***************
*** 341,345 ****
  	int errflg;
  	int c;
! 	extern int optind;
  
  	debug = 0;		/* no debugging by default */
--- 341,345 ----
  	int errflg;
  	int c;
! 	extern int ntp_optind;
  
  	debug = 0;		/* no debugging by default */
***************
*** 353,357 ****
  	 * the terminal, but we won't know to do that until we've
  	 * parsed the command line.  Do that now, crudely, and do it
! 	 * again later.  Our getopt_l() is explicitly reusable, by the
  	 * way.  Your own mileage may vary.
  	 */
--- 353,357 ----
  	 * the terminal, but we won't know to do that until we've
  	 * parsed the command line.  Do that now, crudely, and do it
! 	 * again later.  Our ntp_getopt() is explicitly reusable, by the
  	 * way.  Your own mileage may vary.
  	 */
***************
*** 362,366 ****
  	 * Decode argument list
  	 */
! 	while ((c = getopt_l(argc, argv, xntp_options)) != EOF)
  		switch (c) {
  		case 'd':
--- 362,366 ----
  	 * Decode argument list
  	 */
! 	while ((c = ntp_getopt(argc, argv, xntp_options)) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 374,378 ****
  		}
  	
! 	if (errflg || optind != argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [ -bd ] [ -c config_file ]\n", progname);
--- 374,378 ----
  		}
  	
! 	if (errflg || ntp_optind != argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [ -bd ] [ -c config_file ]\n", progname);
***************
*** 379,383 ****
  		exit(2);
  	}
! 	optind = 0;		/* reset optind to restart getopt_l */
  
  	if (debug) {
--- 379,383 ----
  		exit(2);
  	}
! 	ntp_optind = 0;		/* reset optind to restart ntp_getopt() */
  
  	if (debug) {
***************
*** 427,432 ****
  	int have_keyfile;
  	char keyfile[MAXFILENAME];
! 	extern int optind;
! 	extern char *optarg;
  	extern U_LONG info_auth_keyid;
  	FILEGEN *filegen;
--- 427,432 ----
  	int have_keyfile;
  	char keyfile[MAXFILENAME];
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  	extern U_LONG info_auth_keyid;
  	FILEGEN *filegen;
***************
*** 451,455 ****
  	 * Decode argument list
  	 */
! 	while ((c = getopt_l(argc, argv, xntp_options)) != EOF) {
  		switch (c) {
  		case 'a':
--- 451,455 ----
  	 * Decode argument list
  	 */
! 	while ((c = ntp_getopt(argc, argv, xntp_options)) != EOF) {
  		switch (c) {
  		case 'a':
***************
*** 460,464 ****
  			break;
  		case 'c':
! 			config_file = optarg;
  			break;
  		case 'd':
--- 460,464 ----
  			break;
  		case 'c':
! 			config_file = ntp_optarg;
  			break;
  		case 'd':
***************
*** 474,481 ****
  				l_fp tmp;
  				
! 				if (!atolfp(optarg, &tmp)) {
  					syslog(LOG_ERR,
  			"command line encryption delay value %s undecodable",
! 					    optarg);
  					errflg++;
  				} else if (tmp.l_ui != 0) {
--- 474,481 ----
  				l_fp tmp;
  				
! 				if (!atolfp(ntp_optarg, &tmp)) {
  					syslog(LOG_ERR,
  			"command line encryption delay value %s undecodable",
! 					       ntp_optarg);
  					errflg++;
  				} else if (tmp.l_ui != 0) {
***************
*** 482,486 ****
  					syslog(LOG_ERR,
  			"command line encryption delay value %s is unlikely",
! 					    optarg);
  					errflg++;
  				} else {
--- 482,486 ----
  					syslog(LOG_ERR,
  			"command line encryption delay value %s is unlikely",
! 					       ntp_optarg);
  					errflg++;
  				} else {
***************
*** 491,500 ****
  			
  		case 'f':
! 			stats_config(STATS_FREQ_FILE, optarg);
  			break;
  
  		case 'k':
! 			getauthkeys(optarg);
! 			if ((int)strlen(optarg) >= MAXFILENAME) {
  				syslog(LOG_ERR,
  				    "key file name too LONG (>%d, sigh), no name resolution possible",
--- 491,500 ----
  			
  		case 'f':
! 			stats_config(STATS_FREQ_FILE, ntp_optarg);
  			break;
  
  		case 'k':
! 			getauthkeys(ntp_optarg);
! 			if ((int)strlen(ntp_optarg) >= MAXFILENAME) {
  				syslog(LOG_ERR,
  				    "key file name too LONG (>%d, sigh), no name resolution possible",
***************
*** 502,506 ****
  			} else {
  				have_keyfile = 1;
! 				(void)strcpy(keyfile, optarg);
  			}
  			break;
--- 502,506 ----
  			} else {
  				have_keyfile = 1;
! 				(void)strcpy(keyfile, ntp_optarg);
  			}
  			break;
***************
*** 507,511 ****
  
  		case 'p':
! 			stats_config(STATS_PID_FILE, optarg);
  			break;
  
--- 507,511 ----
  
  		case 'p':
! 			stats_config(STATS_PID_FILE, ntp_optarg);
  			break;
  
***************
*** 514,525 ****
  				l_fp tmp;
  				
! 				if (!atolfp(optarg, &tmp)) {
  					syslog(LOG_ERR,
  			"command line broadcast delay value %s undecodable",
! 					    optarg);
  				} else if (tmp.l_ui != 0) {
  					syslog(LOG_ERR,
  			 "command line broadcast delay value %s is unlikely",
! 					    optarg);
  				} else {
  					proto_config(PROTO_BROADDELAY, tmp.l_f);
--- 514,525 ----
  				l_fp tmp;
  				
! 				if (!atolfp(ntp_optarg, &tmp)) {
  					syslog(LOG_ERR,
  			"command line broadcast delay value %s undecodable",
! 					       ntp_optarg);
  				} else if (tmp.l_ui != 0) {
  					syslog(LOG_ERR,
  			 "command line broadcast delay value %s is unlikely",
! 					       ntp_optarg);
  				} else {
  					proto_config(PROTO_BROADDELAY, tmp.l_f);
***************
*** 529,533 ****
  			
  		case 's':
! 			stats_config(STATS_STATSDIR, optarg);
  			break;
  			
--- 529,533 ----
  			
  		case 's':
! 			stats_config(STATS_STATSDIR, ntp_optarg);
  			break;
  			
***************
*** 536,544 ****
  				int tkey;
  				
! 				tkey = atoi(optarg);
  				if (tkey <= 0 || tkey > NTP_MAXKEY) {
  					syslog(LOG_ERR,
  				"command line trusted key %s is unlikely",
! 					    optarg);
  				} else {
  					authtrust(tkey, (LONG)1);
--- 536,544 ----
  				int tkey;
  				
! 				tkey = atoi(ntp_optarg);
  				if (tkey <= 0 || tkey > NTP_MAXKEY) {
  					syslog(LOG_ERR,
  				"command line trusted key %s is unlikely",
! 					       ntp_optarg);
  				} else {
  					authtrust(tkey, (LONG)1);
***************
*** 554,558 ****
  	}
  	
! 	if (errflg || optind != argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [ -bd ] [ -c config_file ]\n", progname);
--- 554,558 ----
  	}
  	
! 	if (errflg || ntp_optind != argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [ -bd ] [ -c config_file ]\n", progname);
***************
*** 1130,1134 ****
  			}
  			
! 			bzero((char *)&clock, sizeof clock);
  			errflg = 0;
  			for (i = 2; i < ntokens-1; i++) {
--- 1130,1134 ----
  			}
  			
! 			memset((char *)&clock, 0, sizeof clock);
  			errflg = 0;
  			for (i = 2; i < ntokens-1; i++) {
***************
*** 1582,1586 ****
  	 * make up socket address.  Clear it out for neatness.
  	 */
! 	bzero((char *)addr, sizeof(struct sockaddr_in));
  	addr->sin_family = AF_INET;
  	addr->sin_port = htons(NTP_PORT);
--- 1582,1586 ----
  	 * make up socket address.  Clear it out for neatness.
  	 */
! 	memset((char *)addr, 0, sizeof(struct sockaddr_in));
  	addr->sin_family = AF_INET;
  	addr->sin_port = htons(NTP_PORT);
*** /tmp/RCSA023543	Wed Jan 26 17:56:49 1994
--- xntpd/ntp_control.c	Wed Jan 26 16:33:36 1994
***************
*** 873,877 ****
  	}
  
! 	bcopy(dp, (char *)datapt, dlen);
  	datapt += dlen;
  	datalinelen += dlen;
--- 873,877 ----
  	}
  
! 	memmove((char *)datapt, dp, dlen);
  	datapt += dlen;
  	datalinelen += dlen;
***************
*** 901,905 ****
  		if (len > (sizeof(buffer) - (cp - buffer) - 1))
  			len = sizeof(buffer) - (cp - buffer) - 1;
! 		bcopy(data, cp, len);
  		cp += len;
  		*cp++ = '"';
--- 901,905 ----
  		if (len > (sizeof(buffer) - (cp - buffer) - 1))
  			len = sizeof(buffer) - (cp - buffer) - 1;
! 		memmove(cp, data, len);
  		cp += len;
  		*cp++ = '"';
***************
*** 1697,1701 ****
  		if (res_authokay)
  			ctl_sys_num_events = 0;
! 		bzero((char *)wants, CS_MAXCODE+1);
  		gotvar = 0;
  		while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
--- 1697,1701 ----
  		if (res_authokay)
  			ctl_sys_num_events = 0;
! 		memset((char *)wants, 0, CS_MAXCODE+1);
  		gotvar = 0;
  		while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
***************
*** 1733,1737 ****
  		if (res_authokay)
  			peer->num_events = 0;
! 		bzero((char*)wants, CP_MAXCODE+1);
  		gotvar = 0;
  		while ((v = ctl_getitem(peer_var, &valuep)) != 0) {
--- 1733,1737 ----
  		if (res_authokay)
  			peer->num_events = 0;
! 		memset((char*)wants, 0, CP_MAXCODE+1);
  		gotvar = 0;
  		while ((v = ctl_getitem(peer_var, &valuep)) != 0) {
***************
*** 1906,1910 ****
  	rpkt.status = htons(ctlclkstatus(&clock));
  	gotvar = 0;
! 	bzero((char*)wants, CC_MAXCODE+1);
  	while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
  		if (v->flags & EOV) {
--- 1906,1910 ----
  	rpkt.status = htons(ctlclkstatus(&clock));
  	gotvar = 0;
! 	memset((char*)wants, 0, CC_MAXCODE+1);
  	while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
  		if (v->flags & EOV) {
*** /tmp/RCSA023543	Wed Jan 26 17:56:50 1994
--- xntpd/ntp_intres.c	Wed Jan 26 16:33:37 1994
***************
*** 295,299 ****
  	len = strlen(name) + 1;
  	cp = emalloc((unsigned)len);
! 	bcopy(name, cp, len);
  
  	ce = (struct conf_entry *)emalloc(sizeof(struct conf_entry));
--- 295,299 ----
  	len = strlen(name) + 1;
  	cp = emalloc((unsigned)len);
! 	memmove(cp, name, len);
  
  	ce = (struct conf_entry *)emalloc(sizeof(struct conf_entry));
***************
*** 348,354 ****
  
  		if (h_errno == TRY_AGAIN)
! 			return 1;
  #endif
! 		return 0;
  	}
  
--- 348,354 ----
  
  		if (h_errno == TRY_AGAIN)
! 			return (1);
  #endif
! 		return (0);
  	}
  
***************
*** 358,364 ****
  	 * only return one.
  	 */
! 	(void) bcopy(hp->h_addr, (char *)&(entry->ce_peeraddr),
! 	    sizeof(struct in_addr));
! 	return 1;
  }
  
--- 358,365 ----
  	 * only return one.
  	 */
! 	memmove((char *)&(entry->ce_peeraddr),
! 		(char *)hp->h_addr,
! 		sizeof(struct in_addr));
! 	return (1);
  }
  
***************
*** 381,385 ****
  	}
  
! 	bzero((char *)&saddr, sizeof(saddr));
  	saddr.sin_family = AF_INET;
  	saddr.sin_port = htons(NTP_PORT);		/* trash */
--- 382,386 ----
  	}
  
! 	memset((char *)&saddr, 0, sizeof(saddr));
  	saddr.sin_family = AF_INET;
  	saddr.sin_port = htons(NTP_PORT);		/* trash */
***************
*** 449,453 ****
  	 * Make up a request packet with the configuration info
  	 */
! 	bzero((char *)&reqpkt, sizeof(reqpkt));
  
  	reqpkt.rm_vn_mode = RM_VN_MODE(0, 0);
--- 450,454 ----
  	 * Make up a request packet with the configuration info
  	 */
! 	memset((char *)&reqpkt, 0, sizeof(reqpkt));
  
  	reqpkt.rm_vn_mode = RM_VN_MODE(0, 0);
***************
*** 457,461 ****
  	reqpkt.err_nitems = ERR_NITEMS(0, 1);	/* one item */
  	reqpkt.mbz_itemsize = MBZ_ITEMSIZE(sizeof(struct conf_peer));
! 	bcopy((char *)conf, reqpkt.data, sizeof(struct conf_peer));
  	reqpkt.keyid = htonl(req_keyid);
  
--- 458,462 ----
  	reqpkt.err_nitems = ERR_NITEMS(0, 1);	/* one item */
  	reqpkt.mbz_itemsize = MBZ_ITEMSIZE(sizeof(struct conf_peer));
! 	memmove(reqpkt.data, (char *)conf, sizeof(struct conf_peer));
  	reqpkt.keyid = htonl(req_keyid);
  
*** /tmp/RCSA023543	Wed Jan 26 17:56:50 1994
--- xntpd/ntp_monitor.c	Wed Jan 26 16:33:37 1994
***************
*** 103,107 ****
  	mon_hash = 0;
  	mon_hash_count = 0;
! 	bzero((char *)&mon_mru_list, sizeof mon_mru_list);
  }
  
--- 103,107 ----
  	mon_hash = 0;
  	mon_hash_count = 0;
! 	memset((char *)&mon_mru_list, 0, sizeof mon_mru_list);
  }
  
***************
*** 122,126 ****
  		mon_hash = (struct mon_data *)
  		    emalloc(MON_HASH_SIZE * sizeof(struct mon_data));
! 		bzero((char *)mon_hash, MON_HASH_SIZE*sizeof(struct mon_data));
  		mon_hash_count = (int *)emalloc(MON_HASH_SIZE * sizeof(int));
  		mon_free_mem = 0;
--- 122,127 ----
  		mon_hash = (struct mon_data *)
  		    emalloc(MON_HASH_SIZE * sizeof(struct mon_data));
! 		memset((char *)mon_hash, 0,
! 		       MON_HASH_SIZE*sizeof(struct mon_data));
  		mon_hash_count = (int *)emalloc(MON_HASH_SIZE * sizeof(int));
  		mon_free_mem = 0;
*** /tmp/RCSA023543	Wed Jan 26 17:56:50 1994
--- xntpd/ntp_peer.c	Wed Jan 26 16:33:37 1994
***************
*** 440,444 ****
  	 * Zero the whole thing for now.  We might be pickier later.
  	 */
! 	bzero((char *)peer, sizeof(struct peer));
  
  	peer->srcadr = *srcadr;
--- 440,444 ----
  	 * Zero the whole thing for now.  We might be pickier later.
  	 */
! 	memset((char *)peer, 0, sizeof(struct peer));
  
  	peer->srcadr = *srcadr;
*** /tmp/RCSA023543	Wed Jan 26 17:56:51 1994
--- xntpd/ntp_proto.c	Wed Jan 26 16:33:37 1994
***************
*** 1079,1083 ****
  	else {
  		if (pps_control)
! 		    bcopy(PPSREFID, (char *)&sys_refid, 4);
  		else
  		    sys_refid = peer->srcadr.sin_addr.s_addr;
--- 1079,1083 ----
  	else {
  		if (pps_control)
! 		    memmove((char *)&sys_refid, PPSREFID, 4);
  		else
  		    sys_refid = peer->srcadr.sin_addr.s_addr;
***************
*** 1128,1132 ****
  			sys_refid = peer->refid;
  		else
! 			bcopy(PPSREFID, (char *)&sys_refid, 4);
  	}
  }
--- 1128,1132 ----
  			sys_refid = peer->refid;
  		else
! 			memmove((char *)&sys_refid, PPSREFID, 4);
  	}
  }
***************
*** 1251,1255 ****
  		printf("clear(%s)\n", ntoa(&peer->srcadr));
  #endif
! 	bzero(CLEAR_TO_ZERO(peer), LEN_CLEAR_TO_ZERO);
  	peer->hpoll = peer->minpoll;
  	peer->dispersion = NTP_MAXDISPERSE;
--- 1251,1255 ----
  		printf("clear(%s)\n", ntoa(&peer->srcadr));
  #endif
! 	memset(CLEAR_TO_ZERO(peer), 0, LEN_CLEAR_TO_ZERO);
  	peer->hpoll = peer->minpoll;
  	peer->dispersion = NTP_MAXDISPERSE;
*** /tmp/RCSA023543	Wed Jan 26 17:56:51 1994
--- xntpd/ntp_request.c	Wed Jan 26 16:33:38 1994
***************
*** 313,317 ****
  		 * Copy data out of exbuf into the packet.
  		 */
! 		bcopy(exbuf, &rpkt.data[0], itemsize);
  		seqno++;
  		databytes = 0;
--- 313,317 ----
  		 * Copy data out of exbuf into the packet.
  		 */
! 		memmove(&rpkt.data[0], exbuf, itemsize);
  		seqno++;
  		databytes = 0;
***************
*** 683,687 ****
  	extern struct peer *sys_peer;
  
! 	bzero((char *)&addr, sizeof addr);
  	addr.sin_family = AF_INET;
  	items = INFO_NITEMS(inpkt->err_nitems);
--- 683,687 ----
  	extern struct peer *sys_peer;
  
! 	memset((char *)&addr, 0, sizeof addr);
  	addr.sin_family = AF_INET;
  	items = INFO_NITEMS(inpkt->err_nitems);
***************
*** 774,778 ****
  	extern struct peer *sys_peer;
  
! 	bzero((char *)&addr, sizeof addr);
  	addr.sin_family = AF_INET;
  	items = INFO_NITEMS(inpkt->err_nitems);
--- 774,778 ----
  	extern struct peer *sys_peer;
  
! 	memset((char *)&addr, 0, sizeof addr);
  	addr.sin_family = AF_INET;
  	items = INFO_NITEMS(inpkt->err_nitems);
***************
*** 1142,1146 ****
  	items = INFO_NITEMS(inpkt->err_nitems);
  	cp = (struct conf_peer *)inpkt->data;
! 	bzero((char *)&peeraddr, sizeof(struct sockaddr_in));
  	peeraddr.sin_family = AF_INET;
  	peeraddr.sin_port = htons(NTP_PORT);
--- 1142,1146 ----
  	items = INFO_NITEMS(inpkt->err_nitems);
  	cp = (struct conf_peer *)inpkt->data;
! 	memset((char *)&peeraddr, 0, sizeof(struct sockaddr_in));
  	peeraddr.sin_family = AF_INET;
  	peeraddr.sin_port = htons(NTP_PORT);
***************
*** 1452,1457 ****
  	items = INFO_NITEMS(inpkt->err_nitems);
  	cr = (struct conf_restrict *)inpkt->data;
! 	bzero((char *)&matchaddr, sizeof(struct sockaddr_in));
! 	bzero((char *)&matchmask, sizeof(struct sockaddr_in));
  	matchaddr.sin_family = AF_INET;
  	matchmask.sin_family = AF_INET;
--- 1452,1457 ----
  	items = INFO_NITEMS(inpkt->err_nitems);
  	cr = (struct conf_restrict *)inpkt->data;
! 	memset((char *)&matchaddr, 0, sizeof(struct sockaddr_in));
! 	memset((char *)&matchmask, 0, sizeof(struct sockaddr_in));
  	matchaddr.sin_family = AF_INET;
  	matchmask.sin_family = AF_INET;
***************
*** 1870,1874 ****
  	 * Prepare sockaddr_in structure
  	 */
! 	bzero((char *)&laddr, sizeof laddr);
  	laddr.sin_family = AF_INET;
  	laddr.sin_port = ntohs(NTP_PORT);
--- 1870,1874 ----
  	 * Prepare sockaddr_in structure
  	 */
! 	memset((char *)&laddr, 0, sizeof laddr);
  	laddr.sin_family = AF_INET;
  	laddr.sin_port = ntohs(NTP_PORT);
***************
*** 2096,2100 ****
  	struct sockaddr_in addr;
  
! 	bzero((char *)&addr, sizeof addr);
  	addr.sin_family = AF_INET;
  	addr.sin_port = htons(NTP_PORT);
--- 2096,2100 ----
  	struct sockaddr_in addr;
  
! 	memset((char *)&addr, 0, sizeof addr);
  	addr.sin_family = AF_INET;
  	addr.sin_port = htons(NTP_PORT);
***************
*** 2150,2155 ****
  	struct sockaddr_in addr;
  
! 	bzero((char *)&addr, sizeof addr);
! 	bzero((char *)&clock, sizeof clock);
  	addr.sin_family = AF_INET;
  	addr.sin_port = htons(NTP_PORT);
--- 2150,2155 ----
  	struct sockaddr_in addr;
  
! 	memset((char *)&addr, 0, sizeof addr);
! 	memset((char *)&clock, 0, sizeof clock);
  	addr.sin_family = AF_INET;
  	addr.sin_port = htons(NTP_PORT);
***************
*** 2287,2291 ****
  	struct sockaddr_in addr;
  
! 	bzero((char *)&addr, sizeof addr);
  	addr.sin_family = AF_INET;
  	addr.sin_port = htons(NTP_PORT);
--- 2287,2291 ----
  	struct sockaddr_in addr;
  
! 	memset((char *)&addr, 0, sizeof addr);
  	addr.sin_family = AF_INET;
  	addr.sin_port = htons(NTP_PORT);
***************
*** 2304,2308 ****
  		}
  
! 		bzero((char *)&bug, sizeof bug);
  		refclock_buginfo(&addr, &bug);
  		if (bug.nvalues == 0 && bug.ntimes == 0) {
--- 2304,2308 ----
  		}
  
! 		memset((char *)&bug, 0, sizeof bug);
  		refclock_buginfo(&addr, &bug);
  		if (bug.nvalues == 0 && bug.ntimes == 0) {
*** /tmp/RCSA023543	Wed Jan 26 17:56:52 1994
--- xntpd/ntp_restrict.c	Wed Jan 26 16:33:38 1994
***************
*** 82,86 ****
  	 */
  	resfree = 0;
! 	bzero((char *)resinit, sizeof resinit);
  
  	for (i = 1; i < INITRESLIST; i++) {
--- 82,86 ----
  	 */
  	resfree = 0;
! 	memset((char *)resinit, 0, sizeof resinit);
  
  	for (i = 1; i < INITRESLIST; i++) {
***************
*** 235,239 ****
  				rl = (struct restrictlist *) emalloc(
  				    INCRESLIST*sizeof(struct restrictlist));
! 				bzero((char *)rl,
  				    INCRESLIST*sizeof(struct restrictlist));
  
--- 235,239 ----
  				rl = (struct restrictlist *) emalloc(
  				    INCRESLIST*sizeof(struct restrictlist));
! 				memset((char *)rl, 0,
  				    INCRESLIST*sizeof(struct restrictlist));
  
***************
*** 281,285 ****
  			rlprev->next = rl->next;
  			restrictcount--;
! 			bzero((char *)rl, sizeof(struct restrictlist));
  
  			rl->next = resfree;
--- 281,285 ----
  			rlprev->next = rl->next;
  			restrictcount--;
! 			memset((char *)rl, 0, sizeof(struct restrictlist));
  
  			rl->next = resfree;
*** /tmp/RCSA023543	Wed Jan 26 17:56:52 1994
--- xntpd/ntp_util.c	Wed Jan 26 16:33:39 1994
***************
*** 224,230 ****
  		stats_drift_file = emalloc((u_int)(len + 1));
  		stats_temp_file = emalloc((u_int)(len + sizeof(".TEMP")));
! 		bcopy(value, stats_drift_file, len+1);
! 		bcopy(value, stats_temp_file, len);
! 		bcopy(".TEMP", stats_temp_file + len, sizeof(".TEMP"));
  		L_CLR(&old_drift);
  
--- 224,230 ----
  		stats_drift_file = emalloc((u_int)(len + 1));
  		stats_temp_file = emalloc((u_int)(len + sizeof(".TEMP")));
! 		memmove(stats_drift_file, value, len+1);
! 		memmove(stats_temp_file, value, len);
! 		memmove(stats_temp_file + len, ".TEMP", sizeof(".TEMP"));
  		L_CLR(&old_drift);
  
***************
*** 450,454 ****
  		key_file_name = emalloc((u_int)(len + 1));
  	
! 	bcopy(keyfile, key_file_name, len+1);
  
  	authreadkeys(key_file_name);
--- 450,454 ----
  		key_file_name = emalloc((u_int)(len + 1));
  	
! 	memmove(key_file_name, keyfile, len+1);
  
  	authreadkeys(key_file_name);
*** /tmp/RCSA023543	Wed Jan 26 17:56:52 1994
--- xntpd/refclock_as2201.c	Wed Jan 26 16:33:39 1994
***************
*** 251,256 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)gpsunits, sizeof gpsunits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 251,256 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)gpsunits, 0, sizeof gpsunits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 442,446 ****
  		}
  	}
! 	bzero((char *)gps, sizeof(struct gpsunit));
  	gpsunits[unit] = gps;
  
--- 442,446 ----
  		}
  	}
! 	memset((char *)gps, 0, sizeof(struct gpsunit));
  	gpsunits[unit] = gps;
  
***************
*** 480,484 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 	    bcopy(GPSREFID, (char *)&peer->refid, 4);
  	else
  	    peer->refid = htonl(GPSHSREFID);
--- 480,484 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 	    memmove((char *)&peer->refid, GPSREFID, 4);
  	else
  	    peer->refid = htonl(GPSHSREFID);
***************
*** 908,913 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(GPSREFID, (char *)&peer->refid,
! 					    4);
  				else
  					peer->refid = htonl(GPSHSREFID);
--- 908,913 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *)&peer->refid,
! 						GPSREFID, 4);
  				else
  					peer->refid = htonl(GPSHSREFID);
*** /tmp/RCSA023543	Wed Jan 26 17:56:52 1994
--- xntpd/refclock_chu.c	Wed Jan 26 16:33:39 1994
***************
*** 294,299 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)chuunits, sizeof chuunits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 294,299 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)chuunits, 0, sizeof chuunits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 462,466 ****
  		}
  	}
! 	bzero((char *)chu, sizeof(struct chuunit));
  	chuunits[unit] = chu;
  
--- 462,466 ----
  		}
  	}
! 	memset((char *)chu, 0, sizeof(struct chuunit));
  	chuunits[unit] = chu;
  
***************
*** 499,507 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		bcopy(CHUREFID, (char *)&peer->refid, 4);
  	else
  		peer->refid = htonl(CHUHSREFID);
  	unitinuse[unit] = 1;
! 	return 1;
  
  	/*
--- 499,507 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		memmove((char *)&peer->refid, CHUREFID, 4);
  	else
  		peer->refid = htonl(CHUHSREFID);
  	unitinuse[unit] = 1;
! 	return (1);
  
  	/*
***************
*** 1091,1095 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(CHUREFID, (char *)&peer->refid,4);
  				else
  					peer->refid = htonl(CHUHSREFID);
--- 1091,1096 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *)&peer->refid,
! 						CHUREFID, 4);
  				else
  					peer->refid = htonl(CHUHSREFID);
*** /tmp/RCSA023543	Wed Jan 26 17:56:53 1994
--- xntpd/refclock_goes.c	Wed Jan 26 16:33:39 1994
***************
*** 211,216 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)goesunits, sizeof goesunits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 211,216 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)goesunits, 0, sizeof goesunits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 401,405 ****
  		}
  	}
! 	bzero((char *)goes, sizeof(struct goesunit));
  	goesunits[unit] = goes;
  
--- 401,405 ----
  		}
  	}
! 	memset((char *)goes, 0, sizeof(struct goesunit));
  	goesunits[unit] = goes;
  
***************
*** 429,433 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		bcopy(GOESREFID, (char *)&peer->refid, 4);
  	else
  		peer->refid = htonl(GOESHSREFID);
--- 429,433 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		memmove((char *)&peer->refid, GOESREFID, 4);
  	else
  		peer->refid = htonl(GOESHSREFID);
***************
*** 924,929 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(GOESREFID, (char *)&peer->refid,
! 					    4);
  				else
  					peer->refid = htonl(GOESHSREFID);
--- 924,929 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *)&peer->refid,
! 						GOESREFID, 4);
  				else
  					peer->refid = htonl(GOESHSREFID);
*** /tmp/RCSA023543	Wed Jan 26 17:56:53 1994
--- xntpd/refclock_gpstm.c	Wed Jan 26 16:52:22 1994
***************
*** 18,22 ****
  #ifdef SYS_BSDI
  #undef HAVE_BSD_TTYS
- #define HAVE_POSIX_TTYS
  #include <sys/ioctl.h>
  #endif
--- 18,21 ----
***************
*** 30,34 ****
  #endif /* HAVE_SYSV_TTYS */
  
! #if defined(HAVE_POSIX_TTYS)
  #include <termios.h>
  #endif
--- 29,33 ----
  #endif /* HAVE_SYSV_TTYS */
  
! #if defined(HAVE_TERMIOS)
  #include <termios.h>
  #endif
***************
*** 203,208 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)gpstm_units, sizeof gpstm_units);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 202,207 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)gpstm_units, 0, sizeof gpstm_units);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 278,282 ****
      }
  #endif /* HAVE_SYSV_TTYS */
! #if defined(HAVE_POSIX_TTYS)
  	/*
  	 * POSIX serial line parameters (termios interface)
--- 277,281 ----
      }
  #endif /* HAVE_SYSV_TTYS */
! #if defined(HAVE_TERMIOS)
  	/*
  	 * POSIX serial line parameters (termios interface)
***************
*** 331,335 ****
  #endif /* STREAM */
      }
! #endif /* HAVE_POSIX_TTYS */
  #if defined(HAVE_BSD_TTYS)
  	/*
--- 330,334 ----
  #endif /* STREAM */
      }
! #endif /* HAVE_TERMIOS */
  #if defined(HAVE_BSD_TTYS)
  	/*
***************
*** 393,397 ****
  		}
  	}
! 	bzero((char *)gpstm, sizeof(struct gpstm_unit));
  	gpstm_units[unit] = gpstm;
  
--- 392,396 ----
  		}
  	}
! 	memset((char *)gpstm, 0, sizeof(struct gpstm_unit));
  	gpstm_units[unit] = gpstm;
  
***************
*** 420,424 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		bcopy(REFID, (char *)&peer->refid, 4);
  	else
  		peer->refid = htonl(HSREFID);
--- 419,423 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		memmove((char *)&peer->refid, REFID, 4);
  	else
  		peer->refid = htonl(HSREFID);
***************
*** 928,932 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(REFID, (char *)&peer->refid, 4);
  				else
  					peer->refid = htonl(HSREFID);
--- 927,932 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *)&peer->refid,
! 						REFID, 4);
  				else
  					peer->refid = htonl(HSREFID);
*** /tmp/RCSA023543	Wed Jan 26 17:56:53 1994
--- xntpd/refclock_irig.c	Wed Jan 26 16:33:40 1994
***************
*** 170,175 ****
           * Just zero the data arrays
           */
! 	bzero((char *) irigunits, sizeof irigunits);
! 	bzero((char *) unitinuse, sizeof unitinuse);
  
  	/*
--- 170,175 ----
           * Just zero the data arrays
           */
! 	memset((char *) irigunits, 0, sizeof irigunits);
! 	memset((char *) unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 251,255 ****
  		}
  	}
! 	bzero((char *) irig, sizeof(struct irigunit));
  
  	irigunits[unit] = irig;
--- 251,255 ----
  		}
  	}
! 	memset((char *) irig, 0, sizeof(struct irigunit));
  
  	irigunits[unit] = irig;
***************
*** 277,281 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		bcopy(IRIGREFID, (char *) &peer->refid, 4);
  	else
  		peer->refid = htonl(IRIGHSREFID);
--- 277,281 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		memmove((char *) &peer->refid, IRIGREFID, 4);
  	else
  		peer->refid = htonl(IRIGHSREFID);
***************
*** 486,491 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(IRIGREFID, (char *) &peer->refid,
! 					    4);
  				else
  					peer->refid = htonl(IRIGHSREFID);
--- 486,491 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *) &peer->refid,
! 						IRIGREFID, 4);
  				else
  					peer->refid = htonl(IRIGHSREFID);
*** /tmp/RCSA023543	Wed Jan 26 17:56:53 1994
--- xntpd/refclock_leitch.c	Wed Jan 26 16:33:40 1994
***************
*** 145,150 ****
  leitch_init()
  {
! 	bzero((char*)leitchunits,sizeof(leitchunits));
! 	bzero((char*)unitinuse,sizeof(unitinuse));
  }
  
--- 145,150 ----
  leitch_init()
  {
! 	memset((char*)leitchunits, 0, sizeof(leitchunits));
! 	memset((char*)unitinuse, 0, sizeof(unitinuse));
  }
  
***************
*** 271,275 ****
  
  	leitch = &leitchunits[unit];
! 	bzero((char*)leitch,sizeof(*leitch));
  
  #if defined(HAVE_SYSV_TTYS)
--- 271,275 ----
  
  	leitch = &leitchunits[unit];
! 	memset((char*)leitch, 0, sizeof(*leitch));
  
  #if defined(HAVE_SYSV_TTYS)
*** /tmp/RCSA023543	Wed Jan 26 17:56:54 1994
--- xntpd/refclock_local.c	Wed Jan 26 16:33:40 1994
***************
*** 101,106 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)lclunits, sizeof lclunits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  }
  
--- 101,106 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)lclunits, 0, sizeof lclunits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  }
  
***************
*** 149,153 ****
  		}
  	}
! 	bzero((char *)lcl, sizeof(struct lclunit));
  	lclunits[unit] = lcl;
  
--- 149,153 ----
  		}
  	}
! 	memset((char *)lcl, 0, sizeof(struct lclunit));
  	lclunits[unit] = lcl;
  
***************
*** 167,171 ****
  	peer->stratum = (u_char)unit;
  	if (unit <= 1)
! 		bcopy(LCLREFID, (char *)&peer->refid, 4);
  	else
  		peer->refid = htonl(LCLHSREFID);
--- 167,171 ----
  	peer->stratum = (u_char)unit;
  	if (unit <= 1)
! 		memmove((char *)&peer->refid, LCLREFID, 4);
  	else
  		peer->refid = htonl(LCLHSREFID);
*** /tmp/RCSA023576	Wed Jan 26 17:56:54 1994
--- xntpd/refclock_msfees.c	Wed Jan 26 16:33:41 1994
***************
*** 380,385 ****
  	register int i;
  	/* Just zero the data arrays */
! 	bzero((char *)eesunits, sizeof eesunits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	acceptable_slop.l_ui = 0;
--- 380,385 ----
  	register int i;
  	/* Just zero the data arrays */
! 	memset((char *)eesunits, 0, sizeof eesunits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	acceptable_slop.l_ui = 0;
***************
*** 507,511 ****
  		else ees = (struct eesunit *) emalloc(sizeof(struct eesunit));
  	}
! 	bzero((char *)ees, sizeof(struct eesunit));
  	eesunits[unit] = ees;
  
--- 507,511 ----
  		else ees = (struct eesunit *) emalloc(sizeof(struct eesunit));
  	}
! 	memset((char *)ees, 0, sizeof(struct eesunit));
  	eesunits[unit] = ees;
  
***************
*** 548,553 ****
  	if (!io_addclock(&ees->io)) {
  		/* Oh shit.  Just close and return. */
! 		syslog(LOG_ERR, "ees clock: io_addclock(%s): %m",
! 			eesdev);
  		goto screwed;
  	}
--- 548,552 ----
  	if (!io_addclock(&ees->io)) {
  		/* Oh shit.  Just close and return. */
! 		syslog(LOG_ERR, "ees clock: io_addclock(%s): %m", eesdev);
  		goto screwed;
  	}
***************
*** 560,575 ****
  	peer->rootdelay	= 0;	/* ++++ */
  	peer->rootdispersion = 0;	/* ++++ */
! 	if (stratumtouse[unit] <= 1)
! 	{	bcopy(EESREFID, (char *)&peer->refid, 4);
! 		if (unit>0 && unit<10) ((char *)&peer->refid)[3] = '0' + unit;
  	}
- 	else	peer->refid = htonl(EESHSREFID);
  	unitinuse[unit] = 1;
  	syslog(LOG_ERR, "ees clock: %s OK on %d", eesdev, unit);
! 	return 1;
  
  screwed:
! 	if (fd232 != -1) (void) close(fd232);
! 	return 0;
  }
  
--- 559,577 ----
  	peer->rootdelay	= 0;	/* ++++ */
  	peer->rootdispersion = 0;	/* ++++ */
! 	if (stratumtouse[unit] <= 1) {
! 		memmove((char *)&peer->refid, EESREFID, 4);
! 		if (unit > 0 && unit < 10)
! 			((char *)&peer->refid)[3] = '0' + unit;
! 	} else {
! 		peer->refid = htonl(EESHSREFID);
  	}
  	unitinuse[unit] = 1;
  	syslog(LOG_ERR, "ees clock: %s OK on %d", eesdev, unit);
! 	return (1);
  
  screwed:
! 	if (fd232 != -1)
! 		(void) close(fd232);
! 	return (0);
  }
  
***************
*** 860,864 ****
  	sincelast = this_uisec - ees->last_step;
  
! 	bzero(&ppsclockev, sizeof ppsclockev);
  
  	rc = ioctl(ees->io.fd, CIOGETEV, (char *) &ppsclockev);
--- 862,866 ----
  	sincelast = this_uisec - ees->last_step;
  
! 	memset(&ppsclockev, 0, sizeof ppsclockev);
  
  	rc = ioctl(ees->io.fd, CIOGETEV, (char *) &ppsclockev);
***************
*** 1444,1449 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1) {
! 					bcopy(EESREFID, (char *)&peer->refid,
! 					    4);
  					if (unit>0 && unit<10)
  						((char *)&peer->refid)[3] =
--- 1446,1451 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1) {
! 					memmove((char *)&peer->refid,
! 						EESREFID, 4);
  					if (unit>0 && unit<10)
  						((char *)&peer->refid)[3] =
*** /tmp/RCSA023576	Wed Jan 26 17:56:55 1994
--- xntpd/refclock_mx4200.c	Wed Jan 26 16:33:41 1994
***************
*** 263,268 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)mx4200units, sizeof mx4200units);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 263,268 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)mx4200units, 0, sizeof mx4200units);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 487,491 ****
  	}
  
! 	bzero((char *)mx4200, sizeof(struct mx4200unit));
  	mx4200units[unit] = mx4200;
  
--- 487,491 ----
  	}
  
! 	memset((char *)mx4200, 0, sizeof(struct mx4200unit));
  	mx4200units[unit] = mx4200;
  
***************
*** 513,517 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		bcopy(MX4200REFID, (char *)&peer->refid, 4);
  	else
  		peer->refid = htonl(MX4200HSREFID);
--- 513,517 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		memmove((char *)&peer->refid, MX4200REFID, 4);
  	else
  		peer->refid = htonl(MX4200HSREFID);
***************
*** 702,706 ****
  		return;
  	mx4200->lencode = n;
! 	bcopy(dpt, mx4200->lastcode, n);
  
  	/*
--- 702,706 ----
  		return;
  	mx4200->lencode = n;
! 	memmove(mx4200->lastcode, dpt, n);
  
  	/*
***************
*** 1052,1057 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(MX4200REFID, (char *)&peer->refid,
! 					    4);
  				else
  					peer->refid = htonl(MX4200HSREFID);
--- 1052,1057 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *)&peer->refid,
! 						MX4200REFID, 4);
  				else
  					peer->refid = htonl(MX4200HSREFID);
***************
*** 1116,1120 ****
  	mx4200 = mx4200units[unit];
  
! 	bzero((char *)bug, sizeof(*bug));
  	bug->nvalues = 10;
  	bug->ntimes = 2;
--- 1116,1120 ----
  	mx4200 = mx4200units[unit];
  
! 	memset((char *)bug, 0, sizeof(*bug));
  	bug->nvalues = 10;
  	bug->ntimes = 2;
***************
*** 1212,1216 ****
  
  	cp = buf;
! 	bzero((char *)jt, sizeof(*jt));
  
  	if ((cp = strchr(cp, ',')) == NULL)
--- 1212,1216 ----
  
  	cp = buf;
! 	memset((char *)jt, 0, sizeof(*jt));
  
  	if ((cp = strchr(cp, ',')) == NULL)
*** /tmp/RCSA023576	Wed Jan 26 17:56:55 1994
--- xntpd/refclock_omega.c	Wed Jan 26 16:33:42 1994
***************
*** 227,232 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)omegaunits, sizeof omegaunits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 227,232 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)omegaunits, 0, sizeof omegaunits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 417,421 ****
  		}
  	}
! 	bzero((char *)omega, sizeof(struct omegaunit));
  	omegaunits[unit] = omega;
  
--- 417,421 ----
  		}
  	}
! 	memset((char *)omega, 0, sizeof(struct omegaunit));
  	omegaunits[unit] = omega;
  
***************
*** 445,449 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		bcopy(OMEGAREFID, (char *)&peer->refid, 4);
  	else
  		peer->refid = htonl(OMEGAHSREFID);
--- 445,449 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		memmove((char *)&peer->refid, OMEGAREFID, 4);
  	else
  		peer->refid = htonl(OMEGAHSREFID);
***************
*** 928,933 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(OMEGAREFID, (char *)&peer->refid,
! 					    4);
  				else
  					peer->refid = htonl(OMEGAHSREFID);
--- 928,933 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *)&peer->refid,
! 						OMEGAREFID, 4);
  				else
  					peer->refid = htonl(OMEGAHSREFID);
*** /tmp/RCSA023576	Wed Jan 26 17:56:56 1994
--- xntpd/refclock_parse.c	Wed Jan 26 16:33:42 1994
***************
*** 1068,1072 ****
        return;
      }
!   bcopy((caddr_t)&rbufp->recv_space, (caddr_t)&parsetime, sizeof(parsetime_t));
  
    /*
--- 1068,1074 ----
        return;
      }
!   memmove((caddr_t)&parsetime,
! 	  (caddr_t)&rbufp->recv_space,
! 	  sizeof(parsetime_t));
  
    /*
***************
*** 2009,2013 ****
  parse_init()
  {
!   bzero((caddr_t)parseunits, sizeof parseunits);
  }
  
--- 2011,2015 ----
  parse_init()
  {
!   memset((caddr_t)parseunits, 0, sizeof parseunits);
  }
  
***************
*** 2169,2173 ****
      }
  
!   bzero((char *)parse, sizeof(struct parseunit));
    parseunits[unit] = parse;
  
--- 2171,2175 ----
      }
  
!   memset((char *)parse, 0, sizeof(struct parseunit));
    parseunits[unit] = parse;
  
***************
*** 2204,2208 ****
    peer->stratum         = STRATUM_REFCLOCK;
    if (peer->stratum <= 1)
!     bcopy(parse->parse_type->cl_id, (char *)&peer->refid, 4);
    else
      peer->refid = htonl(PARSEHSREFID);
--- 2206,2210 ----
    peer->stratum         = STRATUM_REFCLOCK;
    if (peer->stratum <= 1)
!     memmove((char *)&peer->refid, parse->parse_type->cl_id, 4);
    else
      peer->refid = htonl(PARSEHSREFID);
***************
*** 2233,2237 ****
      {
  #ifndef _PC_VDISABLE
!       bzero((char *)tm.c_cc, sizeof(tm.c_cc));
  #else
        int disablec;
--- 2235,2239 ----
      {
  #ifndef _PC_VDISABLE
!       memset((char *)tm.c_cc, 0, sizeof(tm.c_cc));
  #else
        int disablec;
***************
*** 2587,2591 ****
  	  parse->peer->stratum = (u_char)(in->fudgeval1 & 0xf);
  	  if (parse->peer->stratum <= 1)
! 		bcopy(parse->parse_type->cl_id, (char *)&parse->peer->refid, 4);
  	      else
  		parse->peer->refid = htonl(PARSEHSREFID);
--- 2589,2595 ----
  	  parse->peer->stratum = (u_char)(in->fudgeval1 & 0xf);
  	  if (parse->peer->stratum <= 1)
! 		memmove((char *)&parse->peer->refid,
! 			parse->parse_type->cl_id, 
! 			4);
  	      else
  		parse->peer->refid = htonl(PARSEHSREFID);
***************
*** 3280,3284 ****
      {
        parse->localdata = (void *)malloc(sizeof(poll_timer_t));
!       bzero((char *)parse->localdata, sizeof(poll_timer_t));
    
        pt = (poll_timer_t *)parse->localdata;
--- 3284,3288 ----
      {
        parse->localdata = (void *)malloc(sizeof(poll_timer_t));
!       memset((char *)parse->localdata, 0, sizeof(poll_timer_t));
    
        pt = (poll_timer_t *)parse->localdata;
*** /tmp/RCSA023576	Wed Jan 26 17:56:56 1994
--- xntpd/refclock_pst.c	Wed Jan 26 16:33:42 1994
***************
*** 438,443 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)pstunits, sizeof pstunits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 438,443 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)pstunits, 0, sizeof pstunits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 630,634 ****
  		}
  	}
! 	bzero((char *)pst, sizeof(struct pstunit));
  	pstunits[unit] = pst;
  
--- 630,634 ----
  		}
  	}
! 	memset((char *)pst, 0, sizeof(struct pstunit));
  	pstunits[unit] = pst;
  
***************
*** 663,667 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		bcopy(WWVREFID, (char *)&peer->refid, 4);
  	else
  		peer->refid = htonl(PSTHSREFID);
--- 663,667 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 		memmove((char *)&peer->refid, WWVREFID, 4);
  	else
  		peer->refid = htonl(PSTHSREFID);
***************
*** 1461,1467 ****
  	if (stratumtouse[pst->unit] <= 1) {
  		if (pst->station >= 0)
! 			bcopy(WWVREFID, (char *)&pst->peer->refid, 4);
  		else
! 			bcopy(WWVHREFID, (char *)&pst->peer->refid, 4);
  	}
  
--- 1461,1467 ----
  	if (stratumtouse[pst->unit] <= 1) {
  		if (pst->station >= 0)
! 			memmove((char *)&pst->peer->refid, WWVREFID, 4);
  		else
! 			memmove((char *)&pst->peer->refid, WWVHREFID, 4);
  	}
  
*** /tmp/RCSA023576	Wed Jan 26 17:56:57 1994
--- xntpd/refclock_tpro.c	Wed Jan 26 16:33:43 1994
***************
*** 131,136 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)tprounits, sizeof tprounits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 131,136 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)tprounits, 0, sizeof tprounits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 201,205 ****
  		}
  	}
! 	bzero((char *)tpro, sizeof(struct tprounit));
  	tprounits[unit] = tpro;
  
--- 201,205 ----
  		}
  	}
! 	memset((char *)tpro, 0, sizeof(struct tprounit));
  	tprounits[unit] = tpro;
  
***************
*** 226,230 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 	    bcopy(TPROREFID, (char *)&peer->refid, 4);
  	else
  	    peer->refid = htonl(TPROHSREFID);
--- 226,230 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 	    memmove((char *)&peer->refid, TPROREFID, 4);
  	else
  	    peer->refid = htonl(TPROHSREFID);
***************
*** 416,421 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(TPROREFID, (char *)&peer->refid,
! 					    4);
  				else
  					peer->refid = htonl(TPROHSREFID);
--- 416,421 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *)&peer->refid,
! 						TPROREFID, 4);
  				else
  					peer->refid = htonl(TPROHSREFID);
*** /tmp/RCSA023576	Wed Jan 26 17:56:57 1994
--- xntpd/refclock_wwvb.c	Wed Jan 26 16:33:43 1994
***************
*** 220,225 ****
  	 * Just zero the data arrays
  	 */
! 	bzero((char *)wwvbunits, sizeof wwvbunits);
! 	bzero((char *)unitinuse, sizeof unitinuse);
  
  	/*
--- 220,225 ----
  	 * Just zero the data arrays
  	 */
! 	memset((char *)wwvbunits, 0, sizeof wwvbunits);
! 	memset((char *)unitinuse, 0, sizeof unitinuse);
  
  	/*
***************
*** 408,412 ****
  		}
  	}
! 	bzero((char *)wwvb, sizeof(struct wwvbunit));
  	wwvbunits[unit] = wwvb;
  
--- 408,412 ----
  		}
  	}
! 	memset((char *)wwvb, 0, sizeof(struct wwvbunit));
  	wwvbunits[unit] = wwvb;
  
***************
*** 436,440 ****
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 	    bcopy(WWVBREFID, (char *)&peer->refid, 4);
  	else
  	    peer->refid = htonl(WWVBHSREFID);
--- 436,440 ----
  	peer->stratum = stratumtouse[unit];
  	if (stratumtouse[unit] <= 1)
! 	    memmove((char *)&peer->refid, WWVBREFID, 4);
  	else
  	    peer->refid = htonl(WWVBHSREFID);
***************
*** 957,962 ****
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					bcopy(WWVBREFID, (char *)&peer->refid,
! 					    4);
  				else
  					peer->refid = htonl(WWVBHSREFID);
--- 957,962 ----
  				peer->stratum = stratumtouse[unit];
  				if (stratumtouse[unit] <= 1)
! 					memmove((char *)&peer->refid,
! 						WWVBREFID, 4);
  				else
  					peer->refid = htonl(WWVBHSREFID);
*** /tmp/RCSA023592	Wed Jan 26 17:56:58 1994
--- xntpdc/ntpdc.c	Wed Jan 26 16:33:43 1994
***************
*** 222,227 ****
  	int c;
  	int errflg = 0;
! 	extern int optind;
! 	extern char *optarg;
  
  	delay_time.l_ui = 0;
--- 222,227 ----
  	int c;
  	int errflg = 0;
! 	extern int ntp_optind;
! 	extern char *ntp_optarg;
  
  	delay_time.l_ui = 0;
***************
*** 229,236 ****
  
  	progname = argv[0];
! 	while ((c = getopt_l(argc, argv, "c:dilnps")) != EOF)
  		switch (c) {
  		case 'c':
! 			ADDCMD(optarg);
  			break;
  		case 'd':
--- 229,236 ----
  
  	progname = argv[0];
! 	while ((c = ntp_getopt(argc, argv, "c:dilnps")) != EOF)
  		switch (c) {
  		case 'c':
! 			ADDCMD(ntp_optarg);
  			break;
  		case 'd':
***************
*** 262,270 ****
  		exit(2);
  	}
! 	if (optind == argc) {
  		ADDHOST(DEFHOST);
  	} else {
! 		for (; optind < argc; optind++)
! 			ADDHOST(argv[optind]);
  	}
  
--- 262,270 ----
  		exit(2);
  	}
! 	if (ntp_optind == argc) {
  		ADDHOST(DEFHOST);
  	} else {
! 		for (; ntp_optind < argc; ntp_optind++)
! 			ADDHOST(argv[ntp_optind]);
  	}
  
***************
*** 440,444 ****
  	*rdata = datap = pktdata;
  	lastseq = 999;	/* too big to be a sequence number */
! 	bzero(haveseq, sizeof(haveseq));
  	FD_ZERO(&fds);
  
--- 440,444 ----
  	*rdata = datap = pktdata;
  	lastseq = 999;	/* too big to be a sequence number */
! 	memset(haveseq, 0, sizeof(haveseq));
  	FD_ZERO(&fds);
  
***************
*** 601,605 ****
  	if ((datap + datasize) > (pktdata + pktdatasize))
  		growpktdata();
! 	bcopy((char *)rpkt.data, datap, datasize);
  	datap += datasize;
  	if (firstpkt) {
--- 601,605 ----
  	if ((datap + datasize) > (pktdata + pktdatasize))
  		growpktdata();
! 	memmove(datap, (char *)rpkt.data, datasize);
  	datap += datasize;
  	if (firstpkt) {
***************
*** 635,639 ****
  	int datasize;
  
! 	bzero((char *)&qpkt, sizeof qpkt);
  
  	qpkt.rm_vn_mode = RM_VN_MODE(0, 0);
--- 635,639 ----
  	int datasize;
  
! 	memset((char *)&qpkt, 0, sizeof qpkt);
  
  	qpkt.rm_vn_mode = RM_VN_MODE(0, 0);
***************
*** 643,647 ****
  	datasize = qitems * qsize;
  	if (datasize != 0 && qdata != NULL) {
! 		bcopy(qdata, (char *)qpkt.data, datasize);
  		qpkt.err_nitems = ERR_NITEMS(0, qitems);
  		qpkt.mbz_itemsize = MBZ_ITEMSIZE(qsize);
--- 643,647 ----
  	datasize = qitems * qsize;
  	if (datasize != 0 && qdata != NULL) {
! 		memmove((char *)qpkt.data, qdata, datasize);
  		qpkt.err_nitems = ERR_NITEMS(0, qitems);
  		qpkt.mbz_itemsize = MBZ_ITEMSIZE(qsize);
***************
*** 1092,1096 ****
  		return 1;
  	} else if ((hp = gethostbyname(host)) != 0) {
! 		bcopy(hp->h_addr, (char *)num, sizeof(U_LONG));
  		if (fullhost != 0)
  			(void) strcpy(fullhost, hp->h_name);
--- 1092,1096 ----
  		return 1;
  	} else if ((hp = gethostbyname(host)) != 0) {
! 		memmove((char *)num, hp->h_addr, sizeof(U_LONG));
  		if (fullhost != 0)
  			(void) strcpy(fullhost, hp->h_name);
*** /tmp/RCSA023592	Wed Jan 26 17:56:58 1994
--- xntpdc/ntpdc_ops.c	Wed Jan 26 16:33:44 1994
***************
*** 443,447 ****
  	if (pp->stratum <= 1) {
  		junk[4] = 0;
! 		bcopy((char *)&pp->refid, junk, 4);
  		str = junk;
  	} else {
--- 443,447 ----
  	if (pp->stratum <= 1) {
  		junk[4] = 0;
! 		memmove(junk, (char *)&pp->refid, 4);
  		str = junk;
  	} else {
***************
*** 789,793 ****
  	if (is->stratum <= 1) {
  		junk[4] = 0;
! 		bcopy((char *)&is->refid, junk, 4);
  		str = junk;
  	} else {
--- 789,793 ----
  	if (is->stratum <= 1) {
  		junk[4] = 0;
! 		memmove(junk, (char *)&is->refid, 4);
  		str = junk;
  	} else {
***************
*** 2193,2197 ****
  
  	err = 0;
! 	bzero((char *)&fudgedata, sizeof fudgedata);
  	fudgedata.clockadr = pcmd->argval[0].netnum;
  
--- 2193,2197 ----
  
  	err = 0;
! 	memset((char *)&fudgedata, 0, sizeof fudgedata);
  	fudgedata.clockadr = pcmd->argval[0].netnum;
  
*** /tmp/RCSA023598	Wed Jan 26 17:56:59 1994
--- xntpres/xntpres.c	Wed Jan 26 16:33:44 1994
***************
*** 149,153 ****
  	char *cp;
  	FILE *in;
! 	extern int optind;
  
  	progname = argv[0];
--- 149,153 ----
  	char *cp;
  	FILE *in;
! 	extern int ntp_optind;
  
  	progname = argv[0];
***************
*** 181,185 ****
  	syslog(LOG_NOTICE, Version);
  
! 	while ((c = getopt_l(argc, argv, "dr")) != EOF)
  		switch (c) {
  		case 'd':
--- 181,185 ----
  	syslog(LOG_NOTICE, Version);
  
! 	while ((c = ntp_getopt(argc, argv, "dr")) != EOF)
  		switch (c) {
  		case 'd':
***************
*** 193,197 ****
  			break;
  		}
! 	if (errflg || (optind + 3) != argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [-d] [-r] keyid keyfile conffile\n", progname);
--- 193,197 ----
  			break;
  		}
! 	if (errflg || (ntp_optind + 3) != argc) {
  		(void) fprintf(stderr,
  		    "usage: %s [-d] [-r] keyid keyfile conffile\n", progname);
***************
*** 200,210 ****
  	}
  
! 	if (!atouint(argv[optind], &req_keyid)) {
! 		syslog(LOG_ERR, "undecodeable keyid %s", argv[optind]);
  		exit(1);
  	}
  
! 	keyfile = argv[optind+1];
! 	conffile = argv[optind+2];
  
  	/*
--- 200,210 ----
  	}
  
! 	if (!atouint(argv[ntp_optind], &req_keyid)) {
! 		syslog(LOG_ERR, "undecodeable keyid %s", argv[ntp_optind]);
  		exit(1);
  	}
  
! 	keyfile = argv[ntp_optind+1];
! 	conffile = argv[ntp_optind+2];
  
  	/*
***************
*** 354,358 ****
  	len = strlen(name) + 1;
  	cp = emalloc((unsigned)len);
! 	bcopy(name, cp, len);
  
  	ce = (struct conf_entry *)emalloc(sizeof(struct conf_entry));
--- 354,358 ----
  	len = strlen(name) + 1;
  	cp = emalloc((unsigned)len);
! 	memmove(cp, name, len);
  
  	ce = (struct conf_entry *)emalloc(sizeof(struct conf_entry));
***************
*** 409,413 ****
  			return 1;
  #endif
! 		return 0;
  	}
  
--- 409,413 ----
  			return 1;
  #endif
! 		return (0);
  	}
  
***************
*** 417,423 ****
  	 * only return one.
  	 */
! 	(void) bcopy(hp->h_addr, (char *)&(entry->ce_peeraddr),
! 	    sizeof(struct in_addr));
! 	return 1;
  }
  
--- 417,424 ----
  	 * only return one.
  	 */
! 	memmove((char *)&(entry->ce_peeraddr),
! 		hp->h_addr,
! 		sizeof(struct in_addr));
! 	return (1);
  }
  
***************
*** 440,444 ****
  	}
  
! 	bzero((char *)&saddr, sizeof(saddr));
  	saddr.sin_family = AF_INET;
  	saddr.sin_port = htons(NTP_PORT);		/* trash */
--- 441,445 ----
  	}
  
! 	memset((char *)&saddr, 0, sizeof(saddr));
  	saddr.sin_family = AF_INET;
  	saddr.sin_port = htons(NTP_PORT);		/* trash */
***************
*** 500,504 ****
  	 * Make up a request packet with the configuration info
  	 */
! 	bzero((char *)&reqpkt, sizeof(reqpkt));
  
  	reqpkt.rm_vn_mode = RM_VN_MODE(0, 0);
--- 501,505 ----
  	 * Make up a request packet with the configuration info
  	 */
! 	memset((char *)&reqpkt, 0, sizeof(reqpkt));
  
  	reqpkt.rm_vn_mode = RM_VN_MODE(0, 0);
***************
*** 508,512 ****
  	reqpkt.err_nitems = ERR_NITEMS(0, 1);	/* one item */
  	reqpkt.mbz_itemsize = MBZ_ITEMSIZE(sizeof(struct conf_peer));
! 	bcopy((char *)conf, reqpkt.data, sizeof(struct conf_peer));
  	reqpkt.keyid = htonl(req_keyid);
  
--- 509,513 ----
  	reqpkt.err_nitems = ERR_NITEMS(0, 1);	/* one item */
  	reqpkt.mbz_itemsize = MBZ_ITEMSIZE(sizeof(struct conf_peer));
! 	memmove(reqpkt.data, (char *)conf, sizeof(struct conf_peer));
  	reqpkt.keyid = htonl(req_keyid);
  

