diff -c TODO:1.1.1.3 TODO:3.5
*** TODO:1.1.1.3	Wed Jan 26 21:46:47 1994
--- TODO	Wed Jan 26 21:46:48 1994
***************
*** 1,5 ****
  #
! # TODO,v 3.4 1994/01/23 17:19:06 kardel Exp
  #
  This file contains problems known to the authors that still need to be done.
  We would appreciate if you could spare some of your time to look through
--- 1,5 ----
  #
! # TODO,v 3.5 1994/01/25 19:03:55 kardel Exp
  #
  This file contains problems known to the authors that still need to be done.
  We would appreciate if you could spare some of your time to look through
diff -c doc/xntpd.8:1.1.1.11 doc/xntpd.8:3.21
*** doc/xntpd.8:1.1.1.11	Wed Jan 26 21:47:54 1994
--- doc/xntpd.8	Wed Jan 26 21:47:55 1994
***************
*** 74,79 ****
--- 74,85 ----
  ] [
  .B -t
  .I trustedkey
+ ] [
+ .B -v
+ .I variable
+ ] [
+ .B -V
+ .I variable
  ]
  .SH DESCRIPTION
  .I Xntpd
***************
*** 140,145 ****
--- 146,155 ----
  specify a directory to be used for creating statistics files
  .Ip -t 8
  add a key number to the trusted key list
+ .Ip -v 8
+ add a system variable
+ .Ip -V 8
+ add a system variable listed by default
  .SH "CONFIGURATION FILE OPTIONS"
  .IR Xntpd 's
  configuration file is relatively free format.  Comments, which may be
***************
*** 494,499 ****
--- 504,534 ----
  This command is obsolete and not available in this version of
  .I xntpd.
  .PP
+ .B setvar
+ .I variable
+ .I [default]
+ .PP
+ This command adds an additional system variable. These variables can be
+ used to distribute additional information such as the access policy. If
+ the variable of the from <name>=<value> is followed by the
+ .I default
+ keyword the variable will be listed as part of the default system
+ variables (ntpq rv command). These additional variables serve informational
+ purposes only. They are not related to the protocol other that they can be
+ listed. The known protocol variables will always overide any variables defined
+ via the
+ .I setvar
+ mechanism.
+ .PP
+ There are three special variables that contain the names of all variable of
+ the same group. The
+ .I sys_var_list
+ holds the names of all system variables. The
+ .I peer_var_list
+ holds the names of all peer variables and the
+ .I clock_var_list
+ hold the names of the reference clock variables.
+ .PP
  .B resolver
  .I /path/xntpres
  .PP
***************
*** 1093,1101 ****
  time.
  On the availability of PPS information the
  .I time2
! fudge factor show the difference betwteen the PPS time stamp and the reception
! time stamp of the serial signal. This parameter is read only attempts to
! set this parameter will be ignored.
  The
  .I flag0
  enables input filtering. This a median filter with continuous sampling. The
--- 1128,1140 ----
  time.
  On the availability of PPS information the
  .I time2
! fudge factor defines the skew between the PPS time stamp and the reception
! time stamp of the PPS signal. This parameter is usually 0 as usually
! the PPS signal is believed in time and OS delays should be corrected
! in the machine specific section of the kernel driver.
! .I time2
! needs only be set when the actial PPS signal is delayed for some
! reason.
  The
  .I flag0
  enables input filtering. This a median filter with continuous sampling. The
***************
*** 1109,1121 ****
  .I ntpq
  timecode variable
  .PP
! The timecode variable in the ntpq read clock variable command contains several
! fields. The first field is the local time in Unix format. The second field is
! the offset to UTC (format HHMM). The currently active receiver flags are listed
! next. Additional feature flags of the receiver are optionally listed in paranthesis.
! The actual time code is enclosed in angle brackets < >. A qualification of the
! decoded time code format is following the time code. The last piece of information
! is the overall running time and the accumulated times for the clock event states.
  .PP
  Unit encoding
  .PP
--- 1148,1172 ----
  .I ntpq
  timecode variable
  .PP
! The ntpq read clock variables command list several variables. These
! hold followinf information:
! .I refclock_time
! is the local time with the offset to UTC (format HHMM).
! The currently active receiver flags are listed in
! .I refclock_status.
! Additional feature flags of the receiver are optionally listed in paranthesis.
! The actual time code is listed in
! .I timecode.
! A qualification of the decoded time code format is following in
! .I refclock_format.
! The last piece of information is the overall running time and the accumulated
! times for the clock event states in
! .I refclock_states.
! When PPS information is present additional variable are available.
! .I refclock_ppstime
! lists then the PPS timestamp and
! .I refclock_ppsskew
! lists the difference between RS232 derived timestamp and the PPS timestamp.
  .PP
  Unit encoding
  .PP
diff -c include/ntp_control.h:1.1.1.5 include/ntp_control.h:3.6
*** include/ntp_control.h:1.1.1.5	Wed Jan 26 21:48:21 1994
--- include/ntp_control.h	Wed Jan 26 21:48:21 1994
***************
*** 163,171 ****
  #define	CS_SYSTEM	17
  #define	CS_KEYID	18
  #define	CS_REFSKEW	19
! #define	CS_VERSION	20
  
! #define	CS_MAXCODE	CS_VERSION
  
  /*
   * Peer variables we understand
--- 163,171 ----
  #define	CS_SYSTEM	17
  #define	CS_KEYID	18
  #define	CS_REFSKEW	19
! #define CS_VARLIST	20
  
! #define	CS_MAXCODE	CS_VARLIST
  
  /*
   * Peer variables we understand
***************
*** 204,212 ****
  #define	CP_SENT		32
  #define	CP_FILTERROR	33
  #define	CP_FLASH	34
! #define	CP_DISP		35
! #define	CP_MAXCODE	CP_DISP
  
  /*
   * Clock variables we understand
   */
--- 204,213 ----
  #define	CP_SENT		32
  #define	CP_FILTERROR	33
  #define	CP_FLASH	34
! #define CP_VARLIST	35
  
+ #define	CP_MAXCODE	CP_VARLIST
+ 
  /*
   * Clock variables we understand
   */
***************
*** 222,229 ****
  #define	CC_FUDGEVAL2	10
  #define	CC_FLAGS	11
  #define	CC_DEVICE	12
  
! #define	CC_MAXCODE	CC_DEVICE
  
  /*
   * Definition of the structure used internally to hold trap information.
--- 223,231 ----
  #define	CC_FUDGEVAL2	10
  #define	CC_FLAGS	11
  #define	CC_DEVICE	12
+ #define CC_VARLIST	13
  
! #define	CC_MAXCODE	CC_VARLIST
  
  /*
   * Definition of the structure used internally to hold trap information.
diff -c include/ntp_filegen.h:1.1.1.3 include/ntp_filegen.h:3.7
*** include/ntp_filegen.h:1.1.1.3	Wed Jan 26 21:48:22 1994
--- include/ntp_filegen.h	Wed Jan 26 21:48:22 1994
***************
*** 1,5 ****
  /*
!  * ntp_filegen.h,v 3.6 1993/09/01 21:51:24 kardel Exp
   *
   * definitions for NTP file generations support
   *
--- 1,5 ----
  /*
!  * ntp_filegen.h,v 3.7 1994/01/25 19:04:16 kardel Exp
   *
   * definitions for NTP file generations support
   *
diff -c include/ntp_machine.h:1.1.1.9 include/ntp_machine.h:1.24
*** include/ntp_machine.h:1.1.1.9	Wed Jan 26 21:48:27 1994
--- include/ntp_machine.h	Wed Jan 26 21:48:27 1994
***************
*** 123,134 ****
  
    HAVE_UNISTD_H     - Maybe should be part of NTP_POSIX_SOURCE ?
  
  You could just put the defines on the DEFS line in machines/<os> file.
  I don't since there are lost of different types compiler that a systemm might
  have, some that can do proto typing and others that cannot on the saem system.
  I get a chanse to twiddle some of the configuration paramasters at compile
  time based on compler/machine combinatsions by using this include file.
! See convex, aix and sun configurations see how complex it get.
  
  */
    
--- 123,138 ----
  
    HAVE_UNISTD_H     - Maybe should be part of NTP_POSIX_SOURCE ?
  
+ DEFINITIONS FOR SYSTEM && PROCESSOR
+   STR_SYSTEM        - value of system variable
+   STR_PROCESSOR     - value of processor variable
+ 
  You could just put the defines on the DEFS line in machines/<os> file.
  I don't since there are lost of different types compiler that a systemm might
  have, some that can do proto typing and others that cannot on the saem system.
  I get a chanse to twiddle some of the configuration paramasters at compile
  time based on compler/machine combinatsions by using this include file.
! See convex, aix and sun configurations see how complex it gets.
  
  */
    
***************
*** 152,157 ****
--- 156,164 ----
  #endif
  #endif /*_BSD */
  #define	HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/AIX"
+ #endif
  #endif /* RS6000 */
  
  /*
***************
*** 166,171 ****
--- 173,181 ----
  #define	RETSIGTYPE	void
  #define	NTP_SYSCALL_GET	132
  #define	NTP_SYSCALL_ADJ	147
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/SunOS 4.x"
+ #endif
  #endif
  
  /*
***************
*** 182,188 ****
--- 192,201 ----
  #define NTP_POSIX_SOURCE
  #define HAVE_ATT_SETPGRP
  #define HAVE_ATT_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/SINIX-M"
  #endif
+ #endif
  
  /*
   * SunOS 5.1 or SunOS 5.2 or Solaris 2.1 or Solaris 2.2
***************
*** 198,203 ****
--- 211,219 ----
  #define HAVE_ATT_SETPGRP
  #define HAVE_ATT_NICE
  #define UDP_WILDCARD_DELIVERY
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/Solaris 2.x"
+ #endif
  #endif
  
  /*
***************
*** 221,227 ****
--- 237,246 ----
  #define NTP_POSIX_SOURCE
  #define HAVE_ATT_SETPGRP
  #endif
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/ConvexOS"
  #endif
+ #endif
  
  /*
   * IRIX 4.X and IRIX 5.x
***************
*** 235,240 ****
--- 254,262 ----
  #define HAVE_ATT_SETPGRP
  #define HAVE_BSD_NICE
  #define NTP_POSIX_SOURCE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/IRIX"
+ #endif
  #endif
  
  /*
***************
*** 247,253 ****
--- 269,278 ----
  #define HAVE_BSD_NICE
  #define	RETSIGTYPE	void
  #define	NTP_SYSCALLS_STD
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/Ultrix"
  #endif
+ #endif
  
  /*
   * AUX
***************
*** 272,277 ****
--- 297,305 ----
  #define HAVE_BSD_TTYS
  #define LOG_NTP LOG_LOCAL1
  #define HAVE_SIGNALED_IO
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/AUX"
+ #endif
  #endif
  
  /*
***************
*** 283,289 ****
--- 311,320 ----
  #define HAVE_BSD_NICE
  #define HAVE_N_UN
  #undef NTP_POSIX_SOURCE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/Next"
  #endif
+ #endif
  
  /*
   * HPUX
***************
*** 301,306 ****
--- 332,340 ----
  #else
  #define HAVE_READKMEM
  #endif
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/HPUX"
+ #endif
  #endif
  
  /*
***************
*** 311,316 ****
--- 345,353 ----
  #define HAVE_LIBKVM
  #define NTP_POSIX_SOURCE
  #define HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/BSDI"
+ #endif
  #define HAVE_BSD_TTYS
  #endif
  
***************
*** 327,332 ****
--- 364,372 ----
   * along with a standard name one day ! */
  #define ntp_adjtime __adjtimex
  #define HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/Linux"
+ #endif
  #endif
  
  /*
***************
*** 338,344 ****
--- 378,387 ----
  #define HAVE_READKMEM
  #define NTP_POSIX_SOURCE
  #define HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/*BSD"
  #endif
+ #endif
  
  /*
   * DECOSF1
***************
*** 349,354 ****
--- 392,400 ----
  #define NTP_POSIX_SOURCE
  #define	NTP_SYSCALLS_STD
  #define	HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/DECOSF1"
+ #endif
  #endif
  
  /*
***************
*** 358,364 ****
--- 404,413 ----
  #define HAVE_READKMEM 
  #define S_CHAR_DEFINED 
  #define HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/I386"
  #endif
+ #endif
  
  /*
   * Mips
***************
*** 366,371 ****
--- 415,423 ----
  #if defined(SYS_MIPS)
  #define NOKMEM 
  #define HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/Mips"
+ #endif
  #endif
  
  /*
***************
*** 373,379 ****
--- 425,434 ----
   */
  #if defined(SYS_SEQUENT)
  #define HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/Sequent Dynix 3"
  #endif
+ #endif
  
  /*
   * PTX
***************
*** 407,412 ****
--- 462,470 ----
  typedef unsigned short u_short;
  typedef unsigned long u_long;
  #endif
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/Sequent PTX"
+ #endif
  #endif
  
  
***************
*** 417,423 ****
--- 475,484 ----
  #define NO_SIGNED_CHAR_DECL 
  #define HAVE_READKMEM
  #define HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/Sony"
  #endif
+ #endif
  
  /*
   * VAX
***************
*** 426,431 ****
--- 487,495 ----
  #define NO_SIGNED_CHAR_DECL 
  #define HAVE_READKMEM 
  #define HAVE_BSD_NICE
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/VAX"
+ #endif
  #endif
  
  /* 
***************
*** 445,455 ****
  #define LOCK_PROCESS
  #define SYSV_TIMEOFDAY
  #define SIZE_RETURNED_IN_BUFFER
! #endif
! 
! #ifdef STREAM			/* STREAM implies TERMIOS */
! #ifndef HAVE_TERMIOS
! #define HAVE_TERMIOS
  #endif
  #endif
  
--- 509,516 ----
  #define LOCK_PROCESS
  #define SYSV_TIMEOFDAY
  #define SIZE_RETURNED_IN_BUFFER
! #ifndef STR_SYSTEM
! #define STR_SYSTEM "UNIX/SysVR4"
  #endif
  #endif
  
***************
*** 464,469 ****
--- 525,539 ----
  #define NTP_SYSCALLS_STD
  #define USE_PROTOTYPES
  #define UDP_WILDCARD_DELIVERY
+ #ifndef STR_SYSTEM
+ #define STR_SYSTEM "UNIX/DOMAINOS"
+ #endif
+ #endif
+ 
+ #ifdef STREAM			/* STREAM implies TERMIOS */
+ #ifndef HAVE_TERMIOS
+ #define HAVE_TERMIOS
+ #endif
  #endif
  
  #ifndef	RETSIGTYPE
diff -c include/ntp_refclock.h:1.1.1.8 include/ntp_refclock.h:3.8
*** include/ntp_refclock.h:1.1.1.8	Wed Jan 26 21:48:28 1994
--- include/ntp_refclock.h	Wed Jan 26 21:48:28 1994
***************
*** 75,84 ****
  	LONG fudgeval2;
  	u_char currentstatus;
  	u_char lastevent;
! 	u_char unused[1];
  };
  
- 
  /*
   * Reference clock I/O structure.  Used to provide an interface between
   * the reference clock drivers and the I/O module.
--- 75,84 ----
  	LONG fudgeval2;
  	u_char currentstatus;
  	u_char lastevent;
! 	u_char unused;
! 	struct ctl_var *kv_list;	/* additional variables */
  };
  
  /*
   * Reference clock I/O structure.  Used to provide an interface between
   * the reference clock drivers and the I/O module.
diff -c include/ntpd.h:1.1.1.6 include/ntpd.h:1.5
*** include/ntpd.h:1.1.1.6	Wed Jan 26 21:48:35 1994
--- include/ntpd.h	Wed Jan 26 21:48:35 1994
***************
*** 1,4 ****
! /* ntpd.h,v 3.1 1993/07/06 01:07:03 jbj Exp
   * ntpd.h - Prototypes for xntpd.
   */
  
--- 1,4 ----
! /*
   * ntpd.h - Prototypes for xntpd.
   */
  
***************
*** 21,26 ****
--- 21,55 ----
  extern	void	process_control	P((struct recvbuf *, int));
  extern	void	report_event	P((int, struct peer *));
  
+ /* ntp_control.c */
+ /*
+  * Structure for translation tables between internal system
+  * variable indices and text format.
+  */
+ struct ctl_var {
+ 	u_short code;
+ 	u_short flags;
+ 	char *text;
+ };
+ /*
+  * Flag values
+  */
+ #define	CAN_READ	0x01
+ #define	CAN_WRITE	0x02
+ 
+ #define DEF		0x20
+ #define	PADDING		0x40
+ #define	EOV		0x80
+ 
+ #define	RO	(CAN_READ)
+ #define	WO	(CAN_WRITE)
+ #define	RW	(CAN_READ|CAN_WRITE)
+ 
+ extern  char *  add_var P((struct ctl_var **, unsigned long, int));
+ extern  void    free_varlist P((struct ctl_var *));
+ extern  void    set_var P((struct ctl_var **, char *, unsigned long, int));
+ extern  void    set_sys_var P((char *, unsigned long, int));
+ 
  /* ntp_intres.c */
  extern	void	ntp_intres	P((void));
  
diff -c include/parse.h:1.1.1.6 include/parse.h:3.13
*** include/parse.h:1.1.1.6	Wed Jan 26 21:48:36 1994
--- include/parse.h	Wed Jan 26 21:48:36 1994
***************
*** 1,7 ****
  /*
!  * /src/NTP/REPOSITORY/v3/include/parse.h,v 3.12 1994/01/23 17:23:05 kardel Exp
   *
!  * parse.h,v 3.12 1994/01/23 17:23:05 kardel Exp
   *
   * Copyright (c) 1989,1990,1991,1992,1993,1994
   * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg
--- 1,7 ----
  /*
!  * /src/NTP/REPOSITORY/v3/include/parse.h,v 3.13 1994/01/25 19:04:21 kardel Exp
   *
!  * parse.h,v 3.13 1994/01/25 19:04:21 kardel Exp
   *
   * Copyright (c) 1989,1990,1991,1992,1993,1994
   * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg
***************
*** 15,21 ****
  #ifndef __PARSE_H__
  #define __PARSE_H__
  #if	!(defined(lint) || defined(__GNUC__))
!   static char parsehrcsid[]="parse.h,v 3.12 1994/01/23 17:23:05 kardel Exp FAU";
  #endif
  
  #include "ntp_types.h"
--- 15,21 ----
  #ifndef __PARSE_H__
  #define __PARSE_H__
  #if	!(defined(lint) || defined(__GNUC__))
!   static char parsehrcsid[]="parse.h,v 3.13 1994/01/25 19:04:21 kardel Exp FAU";
  #endif
  
  #include "ntp_types.h"
***************
*** 365,370 ****
--- 365,373 ----
   * History:
   *
   * parse.h,v
+  * Revision 3.13  1994/01/25  19:04:21  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.12  1994/01/23  17:23:05  kardel
   * 1994 reconcilation
   *
diff -c include/parse_conf.h:1.1.1.5 include/parse_conf.h:3.5
*** include/parse_conf.h:1.1.1.5	Wed Jan 26 21:48:37 1994
--- include/parse_conf.h	Wed Jan 26 21:48:37 1994
***************
*** 1,7 ****
  /*
!  * /src/NTP/REPOSITORY/v3/include/parse_conf.h,v 3.4 1994/01/23 17:23:07 kardel Exp
   *
!  * parse_conf.h,v 3.4 1994/01/23 17:23:07 kardel Exp
   *
   * Copyright (c) 1993,1994
   * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg
--- 1,7 ----
  /*
!  * /src/NTP/REPOSITORY/v3/include/parse_conf.h,v 3.5 1994/01/25 19:04:23 kardel Exp
   *
!  * parse_conf.h,v 3.5 1994/01/25 19:04:23 kardel Exp
   *
   * Copyright (c) 1993,1994
   * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg
***************
*** 15,21 ****
  #ifndef __PARSE_CONF_H__
  #define __PARSE_CONF_H__
  #if	!(defined(lint) || defined(__GNUC__))
!   static char dcfhrcsid[]="parse_conf.h,v 3.4 1994/01/23 17:23:07 kardel Exp FAU";
  #endif
  
  /*
--- 15,21 ----
  #ifndef __PARSE_CONF_H__
  #define __PARSE_CONF_H__
  #if	!(defined(lint) || defined(__GNUC__))
!   static char dcfhrcsid[]="parse_conf.h,v 3.5 1994/01/25 19:04:23 kardel Exp FAU";
  #endif
  
  /*
diff -c include/sys/parsestreams.h:1.1.1.6 include/sys/parsestreams.h:3.11
*** include/sys/parsestreams.h:1.1.1.6	Wed Jan 26 21:48:44 1994
--- include/sys/parsestreams.h	Wed Jan 26 21:48:44 1994
***************
*** 1,7 ****
  /*
!  * /src/NTP/REPOSITORY/v3/include/sys/parsestreams.h,v 3.10 1994/01/23 17:23:12 kardel Exp
   *
!  * parsestreams.h,v 3.10 1994/01/23 17:23:12 kardel Exp
   *
   * Copyright (c) 1989,1990,1991,1992,1993,1994
   * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg
--- 1,7 ----
  /*
!  * /src/NTP/REPOSITORY/v3/include/sys/parsestreams.h,v 3.11 1994/01/25 19:04:30 kardel Exp
   *
!  * parsestreams.h,v 3.11 1994/01/25 19:04:30 kardel Exp
   *
   * Copyright (c) 1989,1990,1991,1992,1993,1994
   * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg
***************
*** 13,19 ****
   */
  
  #if	!(defined(lint) || defined(__GNUC__))
!   static char parse77hrcsid[]="parsestreams.h,v 3.10 1994/01/23 17:23:12 kardel Exp";
  #endif
  
  #undef PARSEKERNEL
--- 13,19 ----
   */
  
  #if	!(defined(lint) || defined(__GNUC__))
!   static char parse77hrcsid[]="parsestreams.h,v 3.11 1994/01/25 19:04:30 kardel Exp";
  #endif
  
  #undef PARSEKERNEL
diff -c kernel/Makefile.tmpl:1.1.1.3 kernel/Makefile.tmpl:3.6
*** kernel/Makefile.tmpl:1.1.1.3	Wed Jan 26 21:48:49 1994
--- kernel/Makefile.tmpl	Wed Jan 26 21:48:49 1994
***************
*** 1,7 ****
  #
! # /src/NTP/REPOSITORY/v3/kernel/Makefile.tmpl,v 3.5 1994/01/23 17:37:53 kardel Exp
  #
- #
  # parse routine that could be used in two places
  #
  COMPILER= cc
--- 1,6 ----
  #
! # /src/NTP/REPOSITORY/v3/kernel/Makefile.tmpl,v 3.6 1994/01/25 19:04:35 kardel Exp
  #
  # parse routine that could be used in two places
  #
  COMPILER= cc
diff -c lib/systime.c:1.1.1.10 lib/systime.c:1.7
*** lib/systime.c:1.1.1.10	Wed Jan 26 21:50:00 1994
--- lib/systime.c	Wed Jan 26 21:50:00 1994
***************
*** 238,273 ****
  #endif
  	}
  
- 	sys_clock_offset.l_ui = offset_i;
- 	sys_clock_offset.l_uf = offset_f;
- 
  	if (adjtime(&adjtv, &oadjtv) < 0) {
  		syslog(LOG_ERR, "Can't do time adjustment: %m");
  		rval = 0;
! 	} else
  		rval = 1;
  
  #ifdef DEBUGRS6000
! 	syslog(LOG_ERR, "adj_systime(%s): offset = %s%s\n",
! 		    mfptoa((adj<0?-1:0), adj, 9), isneg?"-":"",
! 		    umfptoa(offset_i, offset_f, 9));
! 	syslog(LOG_ERR, "%d %d %d %d\n", (int) adjtv.tv_sec,
! 		(int) adjtv.tv_usec, (int) oadjtv.tv_sec, (int)
! 		oadjtv.tv_usec);
  #endif /* DEBUGRS6000 */
  
! 	if ((oadjtv.tv_sec != 0 || oadjtv.tv_usec != 0) && (max_no_complete > 0)) {
! 		sTVTOTS(&oadjtv, &oadjts);
! 		L_ADD(&sys_clock_offset, &oadjts);
! 		syslog(LOG_WARNING, "Previous time adjustment didn't complete");
  #ifdef DEBUG
! 		if (debug > 4)
! 			syslog(LOG_DEBUG,
! 			    "Previous adjtime() incomplete, residual = %s\n",
! 			    tvtoa(&oadjtv));
  #endif
! 		if (--max_no_complete == 0) syslog(LOG_WARNING,
! 			"*** No more 'Prev time adj didn't complete'");
  	}
  	return(rval);
  }
--- 238,277 ----
  #endif
  	}
  
  	if (adjtime(&adjtv, &oadjtv) < 0) {
  		syslog(LOG_ERR, "Can't do time adjustment: %m");
  		rval = 0;
! 	} else {
! 		sys_clock_offset.l_ui = offset_i;
! 		sys_clock_offset.l_uf = offset_f;
  		rval = 1;
  
  #ifdef DEBUGRS6000
! 		syslog(LOG_ERR, "adj_systime(%s): offset = %s%s\n",
! 			mfptoa((adj<0?-1:0), adj, 9), isneg?"-":"",
! 			umfptoa(offset_i, offset_f, 9));
! 		syslog(LOG_ERR, "%d %d %d %d\n", (int) adjtv.tv_sec,
! 			(int) adjtv.tv_usec, (int) oadjtv.tv_sec, (int)
! 			oadjtv.tv_usec);
  #endif /* DEBUGRS6000 */
  
! 		if (oadjtv.tv_sec != 0 || oadjtv.tv_usec != 0) {
! 			sTVTOTS(&oadjtv, &oadjts);
! 			L_ADD(&sys_clock_offset, &oadjts);
! 			if (max_no_complete > 0) {
! 				syslog(LOG_WARNING,
! 				    "Previous time adjustment didn't complete");
  #ifdef DEBUG
! 				if (debug > 4)
! 					syslog(LOG_DEBUG,
! 					    "Previous adjtime() incomplete, residual = %s\n",
! 					    tvtoa(&oadjtv));
  #endif
! 				if (--max_no_complete == 0)
! 					syslog(LOG_WARNING,
! 					    "*** No more 'Prev time adj didn't complete'");
! 			}
! 		}
  	}
  	return(rval);
  }
diff -c ntpq/ntpq.c:1.1.1.20 ntpq/ntpq.c:3.20
*** ntpq/ntpq.c:1.1.1.20	Wed Jan 26 21:50:59 1994
--- ntpq/ntpq.c	Wed Jan 26 21:50:59 1994
***************
*** 2577,2582 ****
--- 2577,2583 ----
  	register char *cp;
  	register char *np;
  	register char *cpend;
+ 	int quoted = 0;
  	static char name[MAXVARLEN];
  	static char value[MAXVALLEN];
  
***************
*** 2623,2630 ****
  	while (cp < cpend && (isspace(*cp) && *cp != '\r' && *cp != '\n'))
  		cp++;
  	np = value;
! 	while (cp < cpend && *cp != ',')
! 		*np++ = *cp++;
  	while (np > value && isspace(*(np-1)))
  		np--;
  	*np = '\0';
--- 2624,2634 ----
  	while (cp < cpend && (isspace(*cp) && *cp != '\r' && *cp != '\n'))
  		cp++;
  	np = value;
! 	while (cp < cpend && ((*cp != ',') || quoted))
! 	  {
! 	    quoted ^= ((*np++ = *cp++) == '"');
! 	  }
! 
  	while (np > value && isspace(*(np-1)))
  		np--;
  	*np = '\0';
diff -c parse/Makefile.kernel:1.1.1.2 parse/Makefile.kernel:3.8
*** parse/Makefile.kernel:1.1.1.2	Wed Jan 26 21:51:11 1994
--- parse/Makefile.kernel	Wed Jan 26 21:51:11 1994
***************
*** 30,46 ****
  	ld -r -o parse parsesolaris.o libparse_kernel.a ../lib/libntp.a
  	@echo "--- Install 'parse' in /kernel/strmod for automatic loading"
  
! mparsestreams.o: parsestreams.c microtime.o ../lib/libntp.a libparse_kernel.a ../include/parse.h ../include/sys/parsestreams.h
  	cc -c -DMICROTIME $(DEFS) -I../include parsestreams.c
  	ld -r -o $@ parsestreams.o ../lib/libntp.a libparse_kernel.a \
  		    microtime.o
  	rm -f parsestreams.o
! 	@echo "--- You may load mparsestreams.o via 'modload mparsestreams.o' into the kernel"
  
! parsestreams.o: parsestreams.c ../lib/libntp.a libparse_kernel.a ../include/parse.h ../include/sys/parsestreams.h
  	cc -c $(DEFS) -I../include parsestreams.c
! 	ld -r -o $@ $@ ../lib/libntp.a libparse_kernel.a
! 	@echo "--- You may load parsestreams.o via 'modload parsestreams.o' into the kernel"
  
  microtime.o: $(MICROTIME) assym.s
  	cc -E -I. $(MICROTIME) | sed -e '/\.global _uniqtime/d' > $@.i
--- 30,51 ----
  	ld -r -o parse parsesolaris.o libparse_kernel.a ../lib/libntp.a
  	@echo "--- Install 'parse' in /kernel/strmod for automatic loading"
  
! mparsestreams.o: mparsestreams.o.$(KARCH)
! 	@echo "--- You may load mparsestreams.o.$(KARCH) via 'modload mparsestreams.o.$(KARCH)' into the kernel"
! 
! mparsestreams.o.$(KARCH): parsestreams.c microtime.o ../lib/libntp.a libparse_kernel.a ../include/parse.h ../include/sys/parsestreams.h
  	cc -c -DMICROTIME $(DEFS) -I../include parsestreams.c
  	ld -r -o $@ parsestreams.o ../lib/libntp.a libparse_kernel.a \
  		    microtime.o
  	rm -f parsestreams.o
! 
! parsestreams.o: parsestreams.o.$(KARCH)
! 	@echo "--- You may load parsestreams.o.$(KARCH) via 'modload parsestreams.o.$(KARCH)' into the kernel"
  
! parsestreams.o.$(KARCH): parsestreams.c ../lib/libntp.a libparse_kernel.a ../include/parse.h ../include/sys/parsestreams.h
  	cc -c $(DEFS) -I../include parsestreams.c
! 	ld -r -o $@ parsestreams.o ../lib/libntp.a libparse_kernel.a
! 	rm -f parsestreams.o
  
  microtime.o: $(MICROTIME) assym.s
  	cc -E -I. $(MICROTIME) | sed -e '/\.global _uniqtime/d' > $@.i
diff -c parse/clk_dcf7000.c:1.1.1.7 parse/clk_dcf7000.c:3.10
*** parse/clk_dcf7000.c:1.1.1.7	Wed Jan 26 21:51:16 1994
--- parse/clk_dcf7000.c	Wed Jan 26 21:51:17 1994
***************
*** 1,8 ****
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_DCF7000)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_dcf7000.c,v 3.9 1994/01/23 17:21:51 kardel Exp
   *  
!  * clk_dcf7000.c,v 3.9 1994/01/23 17:21:51 kardel Exp
   *
   * ELV DCF7000 module
   *
--- 1,8 ----
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_DCF7000)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_dcf7000.c,v 3.10 1994/01/25 19:05:07 kardel Exp
   *  
!  * clk_dcf7000.c,v 3.10 1994/01/25 19:05:07 kardel Exp
   *
   * ELV DCF7000 module
   *
diff -c parse/clk_meinberg.c:1.1.1.7 parse/clk_meinberg.c:3.11
*** parse/clk_meinberg.c:1.1.1.7	Wed Jan 26 21:51:17 1994
--- parse/clk_meinberg.c	Wed Jan 26 21:51:18 1994
***************
*** 1,8 ****
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_MEINBERG)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_meinberg.c,v 3.10 1994/01/23 17:21:54 kardel Exp
   *  
!  * clk_meinberg.c,v 3.10 1994/01/23 17:21:54 kardel Exp
   *
   * Meinberg clock support
   *
--- 1,8 ----
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_MEINBERG)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_meinberg.c,v 3.11 1994/01/25 19:05:10 kardel Exp
   *  
!  * clk_meinberg.c,v 3.11 1994/01/25 19:05:10 kardel Exp
   *
   * Meinberg clock support
   *
***************
*** 414,419 ****
--- 414,422 ----
   * History:
   *
   * clk_meinberg.c,v
+  * Revision 3.11  1994/01/25  19:05:10  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.10  1994/01/23  17:21:54  kardel
   * 1994 reconcilation
   *
diff -c parse/clk_rawdcf.c:1.1.1.7 parse/clk_rawdcf.c:3.9
*** parse/clk_rawdcf.c:1.1.1.7	Wed Jan 26 21:51:19 1994
--- parse/clk_rawdcf.c	Wed Jan 26 21:51:19 1994
***************
*** 1,8 ****
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_RAWDCF)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_rawdcf.c,v 3.8 1994/01/22 11:24:11 kardel Exp
   *  
!  * clk_rawdcf.c,v 3.8 1994/01/22 11:24:11 kardel Exp
   *
   * Raw DCF77 pulse clock support
   *
--- 1,8 ----
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_RAWDCF)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_rawdcf.c,v 3.9 1994/01/25 19:05:12 kardel Exp
   *  
!  * clk_rawdcf.c,v 3.9 1994/01/25 19:05:12 kardel Exp
   *
   * Raw DCF77 pulse clock support
   *
***************
*** 529,534 ****
--- 529,537 ----
   * History:
   *
   * clk_rawdcf.c,v
+  * Revision 3.9  1994/01/25  19:05:12  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.8  1994/01/22  11:24:11  kardel
   * fixed PPS handling
   *
diff -c parse/clk_schmid.c:1.1.1.7 parse/clk_schmid.c:3.10
*** parse/clk_schmid.c:1.1.1.7	Wed Jan 26 21:51:20 1994
--- parse/clk_schmid.c	Wed Jan 26 21:51:20 1994
***************
*** 1,8 ****
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_SCHMID)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_schmid.c,v 3.9 1994/01/23 17:21:56 kardel Exp
   *  
!  * clk_schmid.c,v 3.9 1994/01/23 17:21:56 kardel Exp
   *
   * Schmid clock support
   *
--- 1,8 ----
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_SCHMID)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_schmid.c,v 3.10 1994/01/25 19:05:15 kardel Exp
   *  
!  * clk_schmid.c,v 3.10 1994/01/25 19:05:15 kardel Exp
   *
   * Schmid clock support
   *
***************
*** 168,173 ****
--- 168,176 ----
   * History:
   *
   * clk_schmid.c,v
+  * Revision 3.10  1994/01/25  19:05:15  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.9  1994/01/23  17:21:56  kardel
   * 1994 reconcilation
   *
diff -c parse/clk_trimble.c:1.1.1.2 parse/clk_trimble.c:3.7
*** parse/clk_trimble.c:1.1.1.2	Wed Jan 26 21:51:21 1994
--- parse/clk_trimble.c	Wed Jan 26 21:51:21 1994
***************
*** 1,6 ****
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_TRIMSV6)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_trimble.c,v 3.6 1993/10/30 09:44:45 kardel Exp
   *
   * Trimble SV6 clock support
   */
--- 1,6 ----
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS)) && defined(CLOCK_TRIMSV6)
  /*
!  * /src/NTP/REPOSITORY/v3/parse/clk_trimble.c,v 3.7 1994/01/25 19:05:17 kardel Exp
   *
   * Trimble SV6 clock support
   */
***************
*** 106,111 ****
--- 106,114 ----
   * History:
   *
   * clk_trimble.c,v
+  * Revision 3.7  1994/01/25  19:05:17  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.6  1993/10/30  09:44:45  kardel
   * conditional compilation flag cleanup
   *
diff -c parse/parse.c:1.1.1.7 parse/parse.c:3.19
*** parse/parse.c:1.1.1.7	Wed Jan 26 21:51:24 1994
--- parse/parse.c	Wed Jan 26 21:51:24 1994
***************
*** 1,8 ****
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS))
  /*
!  * /src/NTP/REPOSITORY/v3/parse/parse.c,v 3.18 1994/01/23 17:21:59 kardel Exp
   *  
!  * parse.c,v 3.18 1994/01/23 17:21:59 kardel Exp
   *
   * Parser module for reference clock
   *
--- 1,8 ----
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS))
  /*
!  * /src/NTP/REPOSITORY/v3/parse/parse.c,v 3.19 1994/01/25 19:05:20 kardel Exp
   *  
!  * parse.c,v 3.19 1994/01/25 19:05:20 kardel Exp
   *
   * Parser module for reference clock
   *
***************
*** 22,28 ****
   */
  
  #if	!(defined(lint) || defined(__GNUC__))
! static char rcsid[] = "parse.c,v 3.18 1994/01/23 17:21:59 kardel Exp";
  #endif
  
  #include "sys/types.h"
--- 22,28 ----
   */
  
  #if	!(defined(lint) || defined(__GNUC__))
! static char rcsid[] = "parse.c,v 3.19 1994/01/25 19:05:20 kardel Exp";
  #endif
  
  #include "sys/types.h"
***************
*** 1139,1144 ****
--- 1139,1147 ----
   * History:
   *
   * parse.c,v
+  * Revision 3.19  1994/01/25  19:05:20  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.18  1994/01/23  17:21:59  kardel
   * 1994 reconcilation
   *
diff -c parse/parse_conf.c:1.1.1.7 parse/parse_conf.c:3.13
*** parse/parse_conf.c:1.1.1.7	Wed Jan 26 21:51:25 1994
--- parse/parse_conf.c	Wed Jan 26 21:51:25 1994
***************
*** 1,8 ****
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS))
  /*
!  * /src/NTP/REPOSITORY/v3/parse/parse_conf.c,v 3.12 1994/01/23 17:22:02 kardel Exp
   *  
!  * parse_conf.c,v 3.12 1994/01/23 17:22:02 kardel Exp
   *
   * Parser configuration module for reference clocks
   *
--- 1,8 ----
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS))
  /*
!  * /src/NTP/REPOSITORY/v3/parse/parse_conf.c,v 3.13 1994/01/25 19:05:23 kardel Exp
   *  
!  * parse_conf.c,v 3.13 1994/01/25 19:05:23 kardel Exp
   *
   * Parser configuration module for reference clocks
   *
***************
*** 81,86 ****
--- 81,89 ----
   * History:
   *
   * parse_conf.c,v
+  * Revision 3.13  1994/01/25  19:05:23  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.12  1994/01/23  17:22:02  kardel
   * 1994 reconcilation
   *
diff -c parse/parsesolaris.c:1.1.1.4 parse/parsesolaris.c:3.9
*** parse/parsesolaris.c:1.1.1.4	Wed Jan 26 21:51:26 1994
--- parse/parsesolaris.c	Wed Jan 26 21:51:27 1994
***************
*** 1,7 ****
  /*
!  * /src/NTP/REPOSITORY/v3/parse/parsesolaris.c,v 3.8 1994/01/23 17:22:04 kardel Exp
   *  
!  * parsesolaris.c,v 3.8 1994/01/23 17:22:04 kardel Exp
   *
   * STREAMS module for reference clocks
   * (SunOS5.x - not fully tested - buyer beware ! - OS KILLERS may still be
--- 1,7 ----
  /*
!  * /src/NTP/REPOSITORY/v3/parse/parsesolaris.c,v 3.9 1994/01/25 19:05:26 kardel Exp
   *  
!  * parsesolaris.c,v 3.9 1994/01/25 19:05:26 kardel Exp
   *
   * STREAMS module for reference clocks
   * (SunOS5.x - not fully tested - buyer beware ! - OS KILLERS may still be
***************
*** 19,25 ****
   */
  
  #ifndef lint
! static char rcsid[] = "parsesolaris.c,v 3.8 1994/01/23 17:22:04 kardel Exp";
  #endif
  
  /*
--- 19,25 ----
   */
  
  #ifndef lint
! static char rcsid[] = "parsesolaris.c,v 3.9 1994/01/25 19:05:26 kardel Exp";
  #endif
  
  /*
***************
*** 139,145 ****
  /*ARGSUSED*/
  int _init(void)
  {
!   static char revision[] = "3.8";
    char *s, *S, *t;
    
    /*
--- 139,145 ----
  /*ARGSUSED*/
  int _init(void)
  {
!   static char revision[] = "3.9";
    char *s, *S, *t;
    
    /*
***************
*** 1179,1184 ****
--- 1179,1187 ----
   * History:
   *
   * parsesolaris.c,v
+  * Revision 3.9  1994/01/25  19:05:26  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.8  1994/01/23  17:22:04  kardel
   * 1994 reconcilation
   *
diff -c parse/parsestreams.c:1.1.1.6 parse/parsestreams.c:3.12
*** parse/parsestreams.c:1.1.1.6	Wed Jan 26 21:51:28 1994
--- parse/parsestreams.c	Wed Jan 26 21:51:28 1994
***************
*** 1,7 ****
  /*
!  * /src/NTP/REPOSITORY/v3/parse/parsestreams.c,v 3.11 1994/01/23 17:22:07 kardel Exp
   *  
!  * parsestreams.c,v 3.11 1994/01/23 17:22:07 kardel Exp
   *
   * STREAMS module for reference clocks
   * (SunOS4.x)
--- 1,7 ----
  /*
!  * /src/NTP/REPOSITORY/v3/parse/parsestreams.c,v 3.12 1994/01/25 19:05:30 kardel Exp
   *  
!  * parsestreams.c,v 3.12 1994/01/25 19:05:30 kardel Exp
   *
   * STREAMS module for reference clocks
   * (SunOS4.x)
***************
*** 16,22 ****
   */
  
  #ifndef lint
! static char rcsid[] = "parsestreams.c,v 3.11 1994/01/23 17:22:07 kardel Exp";
  #endif
  
  #include "sys/types.h"
--- 16,22 ----
   */
  
  #ifndef lint
! static char rcsid[] = "parsestreams.c,v 3.12 1994/01/25 19:05:30 kardel Exp";
  #endif
  
  #include "sys/types.h"
***************
*** 195,201 ****
  	}
        else
          {
! 	  static char revision[] = "3.11";
  	  char *s, *S, *t;
  	  
  	  strncpy(ifm->f_name, mname, FMNAMESZ);
--- 195,201 ----
  	}
        else
          {
! 	  static char revision[] = "3.12";
  	  char *s, *S, *t;
  	  
  	  strncpy(ifm->f_name, mname, FMNAMESZ);
***************
*** 1258,1263 ****
--- 1258,1266 ----
   * History:
   *
   * parsestreams.c,v
+  * Revision 3.12  1994/01/25  19:05:30  kardel
+  * 94/01/23 reconcilation
+  *
   * Revision 3.11  1994/01/23  17:22:07  kardel
   * 1994 reconcilation
   *
diff -c parse/util/Makefile.tmpl:1.1.1.2 parse/util/Makefile.tmpl:3.12
*** parse/util/Makefile.tmpl:1.1.1.2	Wed Jan 26 21:51:31 1994
--- parse/util/Makefile.tmpl	Wed Jan 26 21:51:31 1994
***************
*** 1,5 ****
  #
! # /src/NTP/REPOSITORY/v3/parse/util/Makefile.tmpl,v 3.11 1993/11/17 13:34:12 kardel Exp
  #
  COMPILER= cc
  DEFS=
--- 1,5 ----
  #
! # /src/NTP/REPOSITORY/v3/parse/util/Makefile.tmpl,v 3.12 1994/01/25 19:05:39 kardel Exp
  #
  COMPILER= cc
  DEFS=
diff -c parse/util/dcfd.c:1.1.1.4 parse/util/dcfd.c:3.15
*** parse/util/dcfd.c:1.1.1.4	Wed Jan 26 21:51:33 1994
--- parse/util/dcfd.c	Wed Jan 26 21:51:33 1994
***************
*** 1,7 ****
  /*
!  * /src/NTP/REPOSITORY/v3/parse/util/dcfd.c,v 3.13 1994/01/23 17:22:15 kardel Exp
   *  
!  * dcfd.c,v 3.13 1994/01/23 17:22:15 kardel Exp
   *
   * DCF77 100/200ms pulse synchronisation daemon program (via 50Baud serial line)
   *
--- 1,7 ----
  /*
!  * /src/NTP/REPOSITORY/v3/parse/util/dcfd.c,v 3.15 1994/01/25 19:05:42 kardel Exp
   *  
!  * dcfd.c,v 3.15 1994/01/25 19:05:42 kardel Exp
   *
   * DCF77 100/200ms pulse synchronisation daemon program (via 50Baud serial line)
   *
***************
*** 733,740 ****
     * assume that we convert timecode within the unix/UTC epoch -
     * prolonges validity of 2 digit years
     */
!   if (clock->year < 1900)
!     clock->year += 100;		/* XXX this will do it till <2092 */
  
    /*
     * must have been a really negative year code - drop it
--- 733,740 ----
     * assume that we convert timecode within the unix/UTC epoch -
     * prolonges validity of 2 digit years
     */
!   if (clock->year < 1994)
!     clock->year += 100;		/* XXX this will do it till <2094 */
  
    /*
     * must have been a really negative year code - drop it
diff -c parse/util/testdcf.c:1.1.1.5 parse/util/testdcf.c:3.9
*** parse/util/testdcf.c:1.1.1.5	Wed Jan 26 21:51:35 1994
--- parse/util/testdcf.c	Wed Jan 26 21:51:35 1994
***************
*** 1,7 ****
  /*
!  * /src/NTP/REPOSITORY/v3/parse/util/testdcf.c,v 3.8 1994/01/23 17:22:20 kardel Exp
   *  
!  * testdcf.c,v 3.8 1994/01/23 17:22:20 kardel Exp
   *
   * simple DCF77 100/200ms pulse test program (via 50Baud serial line)
   *
--- 1,7 ----
  /*
!  * /src/NTP/REPOSITORY/v3/parse/util/testdcf.c,v 3.9 1994/01/25 19:05:45 kardel Exp
   *  
!  * testdcf.c,v 3.9 1994/01/25 19:05:45 kardel Exp
   *
   * simple DCF77 100/200ms pulse test program (via 50Baud serial line)
   *
diff -c scripts/Guess.sh:1.1.1.6 scripts/Guess.sh:1.11
*** scripts/Guess.sh:1.1.1.6	Wed Jan 26 21:52:11 1994
--- scripts/Guess.sh	Wed Jan 26 21:52:12 1994
***************
*** 19,25 ****
  		sinix-m)
  			guess=sinix-m
  			;;
! 		sunos)  case "$3" in
  			4.1*) guess="sunos4" ;;
  			5.1)   guess="sunos5.1" ;;
  			5.*)   guess="sunos5.2" ;;
--- 19,26 ----
  		sinix-m)
  			guess=sinix-m
  			;;
! 		sunos|solaris)
! 			case "$3" in
  			4.1*) guess="sunos4" ;;
  			5.1)   guess="sunos5.1" ;;
  			5.*)   guess="sunos5.2" ;;
***************
*** 59,65 ****
  			guess="netbsd"
  			;;
  		# now the fun starts - there are vendors that
! 		# do not really identify their OS un uname.
  		# Fine - now I look at our version and hope
  		# that nobody else had this marvellous idea.
  		# I am not willing to mention the vendor explicitly
--- 60,66 ----
  			guess="netbsd"
  			;;
  		# now the fun starts - there are vendors that
! 		# do not really identify their OS in uname.
  		# Fine - now I look at our version and hope
  		# that nobody else had this marvellous idea.
  		# I am not willing to mention the vendor explicitly
diff -c xntpd/ntp_config.c:1.1.1.18 xntpd/ntp_config.c:3.21
*** xntpd/ntp_config.c:1.1.1.18	Wed Jan 26 21:52:59 1994
--- xntpd/ntp_config.c	Wed Jan 26 21:53:00 1994
***************
*** 93,98 ****
--- 93,99 ----
  #define CONFIG_PPS		24
  #define	CONFIG_PIDFILE		25
  #define	CONFIG_LOGFILE		26
+ #define CONFIG_SETVAR		27
  
  #define	CONF_MOD_VERSION	1
  #define	CONF_MOD_KEY		2
***************
*** 177,182 ****
--- 178,184 ----
  	{ "statistics",		CONFIG_STATISTICS },
  	{ "pidfile",		CONFIG_PIDFILE },
  	{ "logfile",		CONFIG_LOGFILE },
+ 	{ "setvar",		CONFIG_SETVAR },
  	{ "",			CONFIG_UNKNOWN }
  };
  
***************
*** 316,322 ****
  #endif
  extern char *FindConfig();
         char *progname;
! static char *xntp_options = "abc:de:f:k:l:p:r:s:t:";
  
  static int	gettokens	P((FILE *, char *, char **, int *));
  static int	matchkey	P((char *, struct keyword *));
--- 318,324 ----
  #endif
  extern char *FindConfig();
         char *progname;
! static char *xntp_options = "abc:de:f:k:l:p:r:s:t:v:V:";
  
  static int	gettokens	P((FILE *, char *, char **, int *));
  static int	matchkey	P((char *, struct keyword *));
***************
*** 374,381 ****
  		}
  	
  	if (errflg || optind != argc) {
! 		(void) fprintf(stderr,
! 		    "usage: %s [ -bd ] [ -c config_file ]\n", progname);
  		exit(2);
  	}
  	optind = 0;		/* reset optind to restart getopt_l */
--- 376,385 ----
  		}
  	
  	if (errflg || optind != argc) {
! 		(void) fprintf(stderr, "usage: %s [ -abd ] [ -c config_file ] [ -e encryption delay ]\n", progname);
! 		(void) fprintf(stderr, "\t\t[ -f frequency file ] [ -k key file ] [ -l log file ]\n");
! 		(void) fprintf(stderr, "\t\t[ -p pid file ] [ -r broadcast delay ] [ -s status directory ]\n");
! 		(void) fprintf(stderr, "\t\t[ -t trusted key ] [ -v sys variable ] [ -V default sys variable ]\n");
  		exit(2);
  	}
  	optind = 0;		/* reset optind to restart getopt_l */
***************
*** 428,433 ****
--- 432,438 ----
  	char keyfile[MAXFILENAME];
  	extern int optind;
  	extern char *optarg;
+ 	extern char *Version;
  	extern U_LONG info_auth_keyid;
  	FILEGEN *filegen;
  
***************
*** 443,448 ****
--- 448,459 ----
  	res_fp = NULL;
  	have_resolver = have_keyfile = 0;
  
+ 	/*
+ 	 * install a non default variable with this daemon version
+ 	 */
+ 	(void) sprintf(line, "daemon_version=\"%s\"", Version);
+ 	set_sys_var(line, strlen(line)+1, RO);
+ 
  #ifdef RESOLVE_INTERNAL
  	resolve_internal = 1;
  #endif
***************
*** 546,551 ****
--- 557,566 ----
  			} while (0);
  			break;
  			
+ 		case 'v':
+ 		case 'V':
+ 			set_sys_var(optarg, strlen(optarg)+1, RW | ((c == 'V') ? DEF : 0));
+ 			break;
  			
  		default:
  			errflg++;
***************
*** 1386,1392 ****
  				    (u_char)peerkey, (u_char)peerflags);
  			}
  			break;
! 			
  		}
  	}
  	(void) fclose(fp);
--- 1401,1419 ----
  				    (u_char)peerkey, (u_char)peerflags);
  			}
  			break;
! 
! 		case CONFIG_SETVAR:
! 			if (ntokens < 2)
! 			  {
! 			    syslog(LOG_ERR,
! 				       "no value for setvar command - line ignored");
! 			  }
! 			else
! 			  {
! 			    set_sys_var(tokens[1], strlen(tokens[1])+1, RW |
! 					((((ntokens > 2) && !strcmp(tokens[2], "default"))) ? DEF : 0));
! 			  }
! 			break;
  		}
  	}
  	(void) fclose(fp);
***************
*** 1445,1450 ****
--- 1472,1478 ----
  	register char *cp;
  	register int eol;
  	register int ntok;
+ 	register int quoted = 0;
  
  	/*
  	 * Find start of first token
***************
*** 1469,1476 ****
  	ntok = 0;
  	while (!eol) {
  		tokenlist[ntok++] = cp;
! 		while (!ISEOL(*cp) && !ISSPACE(*cp))
! 			cp++;
  		if (ISEOL(*cp)) {
  			*cp = '\0';
  			eol = 1;
--- 1497,1505 ----
  	ntok = 0;
  	while (!eol) {
  		tokenlist[ntok++] = cp;
! 		while (!ISEOL(*cp) && (!ISSPACE(*cp) || quoted))
! 			quoted ^= (*cp++ == '"');
! 
  		if (ISEOL(*cp)) {
  			*cp = '\0';
  			eol = 1;
diff -c xntpd/ntp_control.c:1.1.1.15 xntpd/ntp_control.c:3.21
*** xntpd/ntp_control.c:1.1.1.15	Wed Jan 26 21:53:01 1994
--- xntpd/ntp_control.c	Wed Jan 26 21:53:02 1994
***************
*** 1,4 ****
! /* ntp_control.c,v 3.1 1993/07/06 01:11:13 jbj Exp
   * ntp_control.c - respond to control messages and send async traps
   */
  #include <stdio.h>
--- 1,4 ----
! /*
   * ntp_control.c - respond to control messages and send async traps
   */
  #include <stdio.h>
***************
*** 61,66 ****
--- 61,67 ----
  static	void	ctl_putclock	P((int, struct refclockstat *, int));
  #endif	/* REFCLOCK */
  static	struct ctl_var *ctl_getitem	P((struct ctl_var *, char **));
+ static  unsigned long count_var P((struct ctl_var *));
  static	void	control_unspec	P((struct recvbuf *, int));
  static	void	read_status	P((struct recvbuf *, int));
  static	void	read_variables	P((struct recvbuf *, int));
***************
*** 83,113 ****
  	{ NO_REQUEST,		0 }
  };
  
- 
- /*
-  * Structure for translation tables between internal system
-  * variable indices and text format.
-  */
- struct ctl_var {
- 	u_short code;
- 	u_short flags;
- 	char *text;
- };
- 
  /*
-  * Flag values
-  */
- #define	CAN_READ	0x1
- #define	CAN_WRITE	0x2
- #define	PADDING		0x80
- #define	EOV		0x40
- 
- #define	RO	(CAN_READ)
- #define	WO	(CAN_WRITE)
- #define	RW	(CAN_READ|CAN_WRITE)
- 
- 
- /*
   * System variable values.  The array can be indexed by
   * the variable index to find the textual name.
   */
--- 84,90 ----
***************
*** 132,141 ****
  	{ CS_SYSTEM,	RO,	"system" },	/* 17 */
  	{ CS_KEYID,	RO,	"keyid" },	/* 18 */
  	{ CS_REFSKEW,	RO,	"refskew" },	/* 19 */
! 	{ CS_VERSION,	RO,	"daemon_version" },	/* 20 */
  	{ 0,		EOV,	""	}
  };
  
  /*
   * System variables we print by default (in fuzzball order, more-or-less)
   */
--- 109,120 ----
  	{ CS_SYSTEM,	RO,	"system" },	/* 17 */
  	{ CS_KEYID,	RO,	"keyid" },	/* 18 */
  	{ CS_REFSKEW,	RO,	"refskew" },	/* 19 */
! 	{ CS_VARLIST,	RO,	"sys_var_list" },/* 20 */
  	{ 0,		EOV,	""	}
  };
  
+ static	struct ctl_var *ext_sys_var = (struct ctl_var *)0;
+ 
  /*
   * System variables we print by default (in fuzzball order, more-or-less)
   */
***************
*** 153,159 ****
  	CS_OFFSET,
  	CS_DRIFT,
  	CS_COMPLIANCE,
- 	CS_VERSION,
  	0
  };
  
--- 132,137 ----
***************
*** 197,202 ****
--- 175,181 ----
  	{ CP_SENT,	RO,	"sent" },	/* 32 */
  	{ CP_FILTERROR,	RO,	"filterror" },	/* 33 */
  	{ CP_FLASH,	RO,	"flash" },	/* 34 */
+ 	{ CP_VARLIST,	RO,	"peer_var_list" }, /* 35 */
  	{ 0,		EOV,	""	}
  };
  
***************
*** 255,260 ****
--- 234,240 ----
  	{ CC_FUDGEVAL2,	RO,	"fudgeval2" },	/* 10 */
  	{ CC_FLAGS,	RO,	"flags" },	/* 11 */
  	{ CC_DEVICE,	RO,	"device" },	/* 12 */
+ 	{ CC_VARLIST,	RO,	"clock_var_list" },/* 13 */
  	{ 0,		EOV,	""	}
  };
  
***************
*** 283,290 ****
--- 263,277 ----
  /*
   * System and processor definitions.  These will change for the gizmo board.
   */
+ #ifndef STR_SYSTEM
  #define	STR_SYSTEM	"UNIX"
+ #endif
+ #ifndef STR_PROCESSOR
  #define	STR_PROCESSOR	"unknown"
+ #endif
+ 
+ static char str_system[] = STR_SYSTEM;
+ static char str_processor[] = STR_PROCESSOR;
  
  /*
   * Trap structures.  We only allow a few of these, and send
***************
*** 1221,1227 ****
  ctl_putsys(varid)
  	int varid;
  {
- 	extern char *Version;
  	l_fp tmp;
  
  	switch (varid) {
--- 1208,1213 ----
***************
*** 1280,1291 ****
  		ctl_putuint(sys_var[CS_LEAPWARNING].text, (U_LONG)leap_warning);
  		break;
  	case CS_PROCESSOR:
! 		ctl_putstr(sys_var[CS_PROCESSOR].text, STR_PROCESSOR,
! 		    sizeof(STR_PROCESSOR) - 1);
  		break;
  	case CS_SYSTEM:
! 		ctl_putstr(sys_var[CS_SYSTEM].text, STR_SYSTEM,
! 		    sizeof(STR_SYSTEM) - 1);
  		break;
  	case CS_KEYID:
  		ctl_putuint(sys_var[CS_KEYID].text, (U_LONG)0);
--- 1266,1277 ----
  		ctl_putuint(sys_var[CS_LEAPWARNING].text, (U_LONG)leap_warning);
  		break;
  	case CS_PROCESSOR:
! 		ctl_putstr(sys_var[CS_PROCESSOR].text, str_processor,
! 		    sizeof(str_processor) - 1);
  		break;
  	case CS_SYSTEM:
! 		ctl_putstr(sys_var[CS_SYSTEM].text, str_system,
! 		    sizeof(str_system) - 1);
  		break;
  	case CS_KEYID:
  		ctl_putuint(sys_var[CS_KEYID].text, (U_LONG)0);
***************
*** 1293,1301 ****
  	case CS_REFSKEW:
  		ctl_putlfp(sys_var[CS_REFSKEW].text, &sys_refskew);
  		break;
! 	case CS_VERSION:
! 		ctl_putstr(sys_var[CS_VERSION].text, Version,
! 		    strlen(Version));
  		break;
  	}
  }
--- 1279,1338 ----
  	case CS_REFSKEW:
  		ctl_putlfp(sys_var[CS_REFSKEW].text, &sys_refskew);
  		break;
! 	case CS_VARLIST:
! 		{
! 		  char buf[CTL_MAX_DATA_LEN];
! 		  register char *s, *ss, *t, *be;
! 		  register int i;
! 		  register struct ctl_var *k;
! 
! 		  s = buf;
! 		  be = buf + sizeof(buf) - strlen(sys_var[CS_VARLIST].text) - 4;
! 		  if (s > be)
! 		    break;	/* really long var name 8-( - Killer */
! 		  
! 		  strcpy(s, sys_var[CS_VARLIST].text);
! 		  strcat(s, "=\"");
! 		  s += strlen(s);
! 		  t = s;
! 
! 		  for (k = sys_var; !(k->flags &EOV); k++)
! 		    {
! 		      i = strlen(k->text);
! 		      if (s+i+1 >= be)
! 			break;
! 		      if (s != t)
! 			*s++ = ',';
! 		      strcpy(s, k->text);
! 		      s += i;
! 		    }
! 
! 		  for (k = ext_sys_var; k && !(k->flags &EOV); k++)
! 		    {
! 		      ss = k->text;
! 		      if (!ss)
! 			continue;
! 
! 		      while (*ss && *ss != '=')
! 			ss++;
! 
! 		      i = ss - k->text;
! 		      if (s+i+1 >= be)
! 			break;
! 		      if (s != t)
! 			*s++ = ',';
! 		      strncpy(s, k->text, i);
! 		      s += i;
! 		    }
! 
! 		  if (s+2 >= be)
! 		    break;
! 		  
! 		  *s++ = '"';
! 		  *s = '\0';
! 
! 		  ctl_putdata(buf, s - buf, 0);
! 		}
  		break;
  	}
  }
***************
*** 1428,1433 ****
--- 1465,1507 ----
  	case CP_SENT:
  		ctl_putuint(peer_var[CP_SENT].text, peer->sent);
  		break;
+ 	case CP_VARLIST:
+ 		{
+ 		  char buf[CTL_MAX_DATA_LEN];
+ 		  register char *s, *t, *be;
+ 		  register int i;
+ 		  register struct ctl_var *k;
+ 
+ 		  s = buf;
+ 		  be = buf + sizeof(buf) - strlen(peer_var[CP_VARLIST].text) - 4;
+ 		  if (s > be)
+ 		    break;	/* really long var name 8-( - Killer */
+ 		  
+ 		  strcpy(s, peer_var[CP_VARLIST].text);
+ 		  strcat(s, "=\"");
+ 		  s += strlen(s);
+ 		  t = s;
+ 
+ 		  for (k = peer_var; !(k->flags &EOV); k++)
+ 		    {
+ 		      i = strlen(k->text);
+ 		      if (s+i+1 >= be)
+ 			break;
+ 		      if (s != t)
+ 			*s++ = ',';
+ 		      strcpy(s, k->text);
+ 		      s += i;
+ 		    }
+ 
+ 		  if (s+2 >= be)
+ 		    break;
+ 		  
+ 		  *s++ = '"';
+ 		  *s = '\0';
+ 
+ 		  ctl_putdata(buf, s - buf, 0);
+ 		}
+ 		break;
  	}
  }
  
***************
*** 1501,1506 ****
--- 1575,1636 ----
  			    strlen(clock->clockdesc));
  		}
  		break;
+ 	case CC_VARLIST:
+ 		{
+ 		  char buf[CTL_MAX_DATA_LEN];
+ 		  register char *s, *ss, *t, *be;
+ 		  register int i;
+ 		  register struct ctl_var *k;
+ 
+ 		  s = buf;
+ 		  be = buf + sizeof(buf) - strlen(clock_var[CC_VARLIST].text) - 4;
+ 		  if (s > be)
+ 		    break;	/* really long var name 8-( - Killer */
+ 		  
+ 		  strcpy(s, clock_var[CC_VARLIST].text);
+ 		  strcat(s, "=\"");
+ 		  s += strlen(s);
+ 		  t = s;
+ 
+ 		  for (k = clock_var; !(k->flags &EOV); k++)
+ 		    {
+ 		      i = strlen(k->text);
+ 		      if (s+i+1 >= be)
+ 			break;
+ 		      if (s != t)
+ 			*s++ = ',';
+ 		      strcpy(s, k->text);
+ 		      s += i;
+ 		    }
+ 
+ 		  for (k = clock->kv_list; k && !(k->flags &EOV); k++)
+ 		    {
+ 		      ss = k->text;
+ 		      if (!ss)
+ 			continue;
+ 		      
+ 		      while (*ss && *ss != '=')
+ 			ss++;
+ 
+ 		      i = ss - k->text;
+ 		      if (s+i+1 >= be)
+ 			break;
+ 		      if (s != t)
+ 			*s++ = ',';
+ 		      strncpy(s, k->text, i);
+ 		      s += i;
+ 		      *s = '\0';
+ 		    }
+ 
+ 		  if (s+2 >= be)
+ 		    break;
+ 		  
+ 		  *s++ = '"';
+ 		  *s = '\0';
+ 
+ 		  ctl_putdata(buf, s - buf, 0);
+ 		}
+ 		break;
  	}
  }
  #endif
***************
*** 1517,1522 ****
--- 1647,1653 ----
  {
  	register struct ctl_var *v;
  	register char *cp, *tp;
+ 	static struct ctl_var eol = { 0, EOV, };
  	static char buf[128];
  
  	/*
***************
*** 1528,1533 ****
--- 1659,1667 ----
  
  	if (reqpt >= reqend)
  		return 0;
+ 
+ 	if (var_list == (struct ctl_var *)0)
+ 	  return &eol;
  	
  	/*
  	 * Look for a first character match on the tag.  If we find
***************
*** 1538,1548 ****
  	while (!(v->flags & EOV)) {
  		if (!(v->flags & PADDING) && *cp == *(v->text)) {
  			tp = v->text;
! 			while (*tp != '\0' && cp < reqend && *cp == *tp) {
  				cp++;
  				tp++;
  			}
! 			if (*tp == '\0') {
  				while (cp < reqend && isspace(*cp))
  					cp++;
  				if (cp == reqend || *cp == ',') {
--- 1672,1682 ----
  	while (!(v->flags & EOV)) {
  		if (!(v->flags & PADDING) && *cp == *(v->text)) {
  			tp = v->text;
! 			while (*tp != '\0' && *tp != '=' && cp < reqend && *cp == *tp) {
  				cp++;
  				tp++;
  			}
! 			if ((*tp == '\0') || (*tp == '=')) {
  				while (cp < reqend && isspace(*cp))
  					cp++;
  				if (cp == reqend || *cp == ',') {
***************
*** 1685,1692 ****
  	register struct ctl_var *v;
  	register int i;
  	char *valuep;
! 	u_char wants[(CS_MAXCODE>CP_MAXCODE) ? (CS_MAXCODE+1) : (CP_MAXCODE+1)];
! 	int gotvar;
  
  	if (res_associd == 0) {
  		/*
--- 1819,1826 ----
  	register struct ctl_var *v;
  	register int i;
  	char *valuep;
! 	u_char *wants;
! 	int gotvar = (CS_MAXCODE>CP_MAXCODE) ? (CS_MAXCODE+1) : (CP_MAXCODE+1);
  
  	if (res_associd == 0) {
  		/*
***************
*** 1696,1707 ****
  		rpkt.status = htons(ctlsysstatus());
  		if (res_authokay)
  			ctl_sys_num_events = 0;
! 		bzero((char *)wants, CS_MAXCODE+1);
  		gotvar = 0;
  		while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
  			if (v->flags & EOV) {
! 				ctl_error(CERR_UNKNOWNVAR);
! 				return;
  			}
  			wants[v->code] = 1;
  			gotvar = 1;
--- 1830,1853 ----
  		rpkt.status = htons(ctlsysstatus());
  		if (res_authokay)
  			ctl_sys_num_events = 0;
! 		gotvar += count_var(ext_sys_var);
! 		wants = (u_char *)emalloc(gotvar);
! 		bzero((char *)wants, gotvar);
  		gotvar = 0;
  		while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
  			if (v->flags & EOV) {
! 			        if ((v = ctl_getitem(ext_sys_var, &valuep)) != 0) {
! 				        if (v->flags & EOV) {
! 					        ctl_error(CERR_UNKNOWNVAR);
! 						free((char *)wants);
! 						return;
! 					}
! 					wants[CS_MAXCODE+1+v->code] = 1;
! 					gotvar = 1;
! 					continue;
! 			       	} else {
! 				        break; /* shouldn't happen ! */
! 				}
  			}
  			wants[v->code] = 1;
  			gotvar = 1;
***************
*** 1710,1721 ****
  			for (i = 1; i <= CS_MAXCODE; i++)
  				if (wants[i])
  					ctl_putsys(i);
  		} else {
  			register u_char *cs;
  
  			for (cs = def_sys_var; *cs != 0; cs++)
! 				ctl_putsys((int)*cs);
  		}
  	} else {
  		register struct peer *peer;
  
--- 1856,1876 ----
  			for (i = 1; i <= CS_MAXCODE; i++)
  				if (wants[i])
  					ctl_putsys(i);
+ 			for (i = 0; ext_sys_var && !(ext_sys_var[i].flags & EOV); i++)
+ 			        if (wants[i+CS_MAXCODE+1])
+ 				        ctl_putdata(ext_sys_var[i].text,
+ 						    strlen(ext_sys_var[i].text), 0);
  		} else {
  			register u_char *cs;
+ 			register struct ctl_var *kv;
  
  			for (cs = def_sys_var; *cs != 0; cs++)
! 			        ctl_putsys((int)*cs);
! 			for (kv = ext_sys_var; kv && !(kv->flags & EOV); kv++)
! 			        if (kv->flags & DEF)
! 				        ctl_putdata(kv->text, strlen(kv->text), 0);
  		}
+ 		free((char *)wants);
  	} else {
  		register struct peer *peer;
  
***************
*** 1732,1742 ****
  		rpkt.status = htons(ctlpeerstatus(peer));
  		if (res_authokay)
  			peer->num_events = 0;
! 		bzero((char*)wants, CP_MAXCODE+1);
  		gotvar = 0;
  		while ((v = ctl_getitem(peer_var, &valuep)) != 0) {
  			if (v->flags & EOV) {
  				ctl_error(CERR_UNKNOWNVAR);
  				return;
  			}
  			wants[v->code] = 1;
--- 1887,1899 ----
  		rpkt.status = htons(ctlpeerstatus(peer));
  		if (res_authokay)
  			peer->num_events = 0;
! 		wants = (u_char *)emalloc(gotvar);
! 		bzero((char*)wants, gotvar);
  		gotvar = 0;
  		while ((v = ctl_getitem(peer_var, &valuep)) != 0) {
  			if (v->flags & EOV) {
  				ctl_error(CERR_UNKNOWNVAR);
+ 				free((char *)wants);
  				return;
  			}
  			wants[v->code] = 1;
***************
*** 1752,1757 ****
--- 1909,1915 ----
  			for (cp = def_peer_var; *cp != 0; cp++)
  				ctl_putpeer((int)*cp, peer);
  		}
+ 		free((char *)wants);
  	}
  	ctl_flushpkt(0);
  }
***************
*** 1768,1773 ****
--- 1926,1932 ----
  	int restrict;
  {
  	register struct ctl_var *v;
+ 	register int ext_var;
  	char *valuep;
  	LONG val;
  	u_char leapind, leapwarn;
***************
*** 1795,1831 ****
  	 * Look through the variables.  Dump out at the first sign of trouble.
  	 */
  	while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
  		if (v->flags & EOV) {
! 			ctl_error(CERR_UNKNOWNVAR);
! 			return;
  		}
  		if (!(v->flags & CAN_WRITE)) {
  			ctl_error(CERR_PERMISSION);
  			return;
  		}
! 		if (*valuep == '\0' || !atoint(valuep, &val)) {
  			ctl_error(CERR_BADFMT);
  			return;
  		}
! 		if ((val & ~LEAP_NOTINSYNC) != 0) {
  			ctl_error(CERR_BADVALUE);
  			return;
  		}
  
! 		/*
! 		 * This one seems sane.  Save it.
! 		 */
! 		switch(v->code) {
! 		case CS_LEAP:
! 		case CS_LEAPIND:
! 			leapind = (u_char)val;
! 			break;
! 		case CS_LEAPWARNING:
! 			leapwarn = (u_char)val;
! 			break;
! 		default:
! 			ctl_error(CERR_UNSPEC);		/* our fault, really */
! 			return;
  		}
  	}
  
--- 1954,2013 ----
  	 * Look through the variables.  Dump out at the first sign of trouble.
  	 */
  	while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
+ 		ext_var = 0;
  		if (v->flags & EOV) {
! 			if ((v = ctl_getitem(ext_sys_var, &valuep)) != 0) {
! 				if (v->flags & EOV) {
! 					ctl_error(CERR_UNKNOWNVAR);
! 					return;
! 				}
! 				ext_var = 1;
! 			} else {
! 				break;
! 			}
  		}
  		if (!(v->flags & CAN_WRITE)) {
  			ctl_error(CERR_PERMISSION);
  			return;
  		}
! 		if (!ext_var && (*valuep == '\0' || !atoint(valuep, &val))) {
  			ctl_error(CERR_BADFMT);
  			return;
  		}
! 		if (!ext_var && (val & ~LEAP_NOTINSYNC) != 0) {
  			ctl_error(CERR_BADVALUE);
  			return;
  		}
  
! 		if (ext_var) {
! 			char *s = emalloc(strlen(v->text)+strlen(valuep)+2);
! 		        char *t, *tt = s;
! 
! 		        t = v->text;
! 			while (*t && *t != '=')
! 			  *tt++ = *t++;
! 			
! 			*tt++ = '=';
! 			strcat(tt, valuep);
! 
! 			set_sys_var(s, strlen(s)+1, v->flags);
! 			free(s);
! 		} else {
! 			/*
! 			 * This one seems sane.  Save it.
! 			 */
! 			switch(v->code) {
! 			case CS_LEAP:
! 			case CS_LEAPIND:
! 				leapind = (u_char)val;
! 				break;
! 			case CS_LEAPWARNING:
! 				leapwarn = (u_char)val;
! 				break;
! 			default:
! 				ctl_error(CERR_UNSPEC);		/* our fault, really */
! 			  	return;
! 			}
  		}
  	}
  
***************
*** 1861,1867 ****
  	register int i;
  	register struct peer *peer;
  	char *valuep;
! 	u_char wants[CC_MAXCODE+1];
  	int gotvar;
  	struct refclockstat clock;
  
--- 2043,2049 ----
  	register int i;
  	register struct peer *peer;
  	char *valuep;
! 	u_char *wants;
  	int gotvar;
  	struct refclockstat clock;
  
***************
*** 1898,1915 ****
  	/*
  	 * If we got here we have a peer which is a clock.  Get his status.
  	 */
  	refclock_control(&peer->srcadr, (struct refclockstat *)0, &clock);
  
  	/*
  	 * Look for variables in the packet.
  	 */
  	rpkt.status = htons(ctlclkstatus(&clock));
  	gotvar = 0;
! 	bzero((char*)wants, CC_MAXCODE+1);
! 	while ((v = ctl_getitem(sys_var, &valuep)) != 0) {
  		if (v->flags & EOV) {
! 			ctl_error(CERR_UNKNOWNVAR);
! 			return;
  		}
  		wants[v->code] = 1;
  		gotvar = 1;
--- 2080,2112 ----
  	/*
  	 * If we got here we have a peer which is a clock.  Get his status.
  	 */
+ 	clock.kv_list = (struct ctl_var *)0;
+ 	
  	refclock_control(&peer->srcadr, (struct refclockstat *)0, &clock);
  
  	/*
  	 * Look for variables in the packet.
  	 */
  	rpkt.status = htons(ctlclkstatus(&clock));
+ 	gotvar = CC_MAXCODE+1+count_var(clock.kv_list);
+ 	wants = (u_char *)emalloc(gotvar);
+ 	bzero((char*)wants, gotvar);
  	gotvar = 0;
! 	while ((v = ctl_getitem(clock_var, &valuep)) != 0) {
  		if (v->flags & EOV) {
! 		        if ((v = ctl_getitem(clock.kv_list, &valuep)) != 0) {
! 			        if (v->flags & EOV) {
! 				        ctl_error(CERR_UNKNOWNVAR);
! 					free((char*)wants);
! 					free_varlist(clock.kv_list);
! 					return;
! 				}
! 				wants[CC_MAXCODE+1+v->code] = 1;
! 				gotvar = 1;
! 				continue;
! 			} else {
! 			        break; /* shouldn't happen ! */
! 			}
  		}
  		wants[v->code] = 1;
  		gotvar = 1;
***************
*** 1919,1930 ****
--- 2116,2139 ----
  		for (i = 1; i <= CC_MAXCODE; i++)
  			if (wants[i])
  				ctl_putclock(i, &clock, 1);
+ 		for (i = 0; !(clock.kv_list[i].flags & EOV); i++)
+ 			if (wants[i+CC_MAXCODE+1])
+ 			        ctl_putdata(clock.kv_list[i].text,
+ 					    strlen(clock.kv_list[i].text), 0);
  	} else {
  		register u_char *cc;
+ 		register struct ctl_var *kv;
  
  		for (cc = def_clock_var; *cc != 0; cc++)
  			ctl_putclock((int)*cc, &clock, 0);
+ 		for (kv = clock.kv_list; kv && !(kv->flags & EOV); kv++)
+ 		  	if (kv->flags & DEF)
+ 			        ctl_putdata(kv->text, strlen(kv->text), 0);
  	}
+ 
+ 	free((char*)wants);
+ 	free_varlist(clock.kv_list);
+ 
  	ctl_flushpkt(0);
  #endif
  }
***************
*** 2237,2249 ****
  		 */
  		if (err == EVNT_CLOCKEXCPT) {
  		        struct refclockstat clock;
! 				refclock_control(&peer->srcadr,
  					 (struct refclockstat *)0,
  					 &clock);
  			ctl_puthex("refclockstatus",
  				   (U_LONG)ctlclkstatus(&clock));
  			for (i = 1; i <= CC_MAXCODE; i++)
  			        	ctl_putclock(i, &clock, 0);
  		}
  #endif /*REFCLOCK*/
  	} else {
--- 2446,2468 ----
  		 */
  		if (err == EVNT_CLOCKEXCPT) {
  		        struct refclockstat clock;
! 			struct ctl_var *kv;
! 
! 			clock.kv_list = (struct ctl_var *)0;
! 
! 			refclock_control(&peer->srcadr,
  					 (struct refclockstat *)0,
  					 &clock);
  			ctl_puthex("refclockstatus",
  				   (U_LONG)ctlclkstatus(&clock));
+ 
  			for (i = 1; i <= CC_MAXCODE; i++)
  			        	ctl_putclock(i, &clock, 0);
+ 			for (kv = clock.kv_list; kv && !(kv->flags & EOV); kv++)
+ 			        if (kv->flags & DEF)
+ 			                ctl_putdata(kv->text, strlen(kv->text), 0);
+ 
+ 			free_varlist(clock.kv_list);
  		}
  #endif /*REFCLOCK*/
  	} else {
***************
*** 2262,2274 ****
--- 2481,2504 ----
  			 */
  			if (err == EVNT_PEERCLOCK) {
  			        struct refclockstat clock;
+ 				struct ctl_var *kv;
+ 
+ 				clock.kv_list = (struct ctl_var *)0;
+ 				
   				refclock_control(&peer->srcadr,
  						 (struct refclockstat *)0,
  						 &clock);
+ 
  				ctl_puthex("refclockstatus",
  					   (U_LONG)ctlclkstatus(&clock));
+ 
  				for (i = 1; i <= CC_MAXCODE; i++)
   			        	ctl_putclock(i, &clock, 0);
+ 				for (kv = clock.kv_list; kv && !(kv->flags & EOV); kv++)
+ 				        if (kv->flags & DEF)
+ 					        ctl_putdata(kv->text, strlen(kv->text), 0);
+ 
+ 				free_varlist(clock.kv_list);
  			}
  #endif /*REFCLOCK*/
  	}
***************
*** 2303,2305 ****
--- 2533,2647 ----
  	numctlbadop = 0;
  	numasyncmsgs = 0;
  }
+ 
+ static unsigned long
+ count_var(k)
+   struct ctl_var *k;
+ {
+   register unsigned long c;
+ 
+   c = 0;
+   while (k && !(k++->flags & EOV))
+     c++;
+ 
+   return c;
+ }
+ 
+ char *
+ add_var(kv, size, def)
+      struct ctl_var **kv;
+      unsigned long size;
+      int def;
+ {
+   register unsigned long c;
+   register struct ctl_var *k;
+ 
+   c = count_var(*kv);
+ 
+   k = *kv;
+   *kv  = (struct ctl_var *)emalloc((c+2)*sizeof(struct ctl_var));
+   if (k)
+     {
+       bcopy((char *)k, (char *)*kv, sizeof(struct ctl_var)*c);
+       free((char *)k);
+     }
+ 
+   (*kv)[c].code  = c;
+   (*kv)[c].text  = (char *)emalloc(size);
+   (*kv)[c].flags = def;
+   (*kv)[c+1].code  = 0;
+   (*kv)[c+1].text  = (char *)0;
+   (*kv)[c+1].flags = EOV;
+   return (*kv)[c].text;
+ }
+ 
+ void
+ set_var(kv, data, size, def)
+      struct ctl_var **kv;
+      char *data;
+      unsigned long size;
+      int def;
+ {
+   register struct ctl_var *k;
+   register char *s, *t;
+ 
+   if (!data || !size)
+     return;
+ 
+   if ((k = *kv))
+     {
+       while (!(k->flags & EOV))
+ 	{
+ 	  s = data;
+ 	  t = k->text;
+ 	  if (t)
+ 	    {
+ 	      while (*t != '=' && *s - *t == 0)
+ 		{
+ 		  s++;
+ 		  t++;
+ 		}
+ 	      if (*s == *t && ((*t == '=') || !*t))
+ 		{
+ 		  free(k->text);
+ 		  k->text = (char *)emalloc(size);
+ 		  bcopy(data, k->text, size);
+ 		  k->flags = def;
+ 		  return;
+ 		}
+ 	    }
+ 	  else
+ 	    {
+ 	      k->text = (char *)emalloc(size);
+ 	      bcopy(data, k->text, size);
+ 	      k->flags = def;
+ 	      return;
+ 	    }
+ 	  k++;
+ 	}
+     }
+   t = add_var(kv, size, def);
+   bcopy(data, t, size);
+ }
+ 
+ void
+ set_sys_var(data, size, def)
+      char *data;
+      unsigned long size;
+      int def;
+ {
+   set_var(&ext_sys_var, data, size, def);
+ }
+ 
+ void
+ free_varlist(kv)
+      struct ctl_var *kv;
+ {
+   struct ctl_var *k;
+   if (kv)
+     {
+       for (k = kv; !(k->flags & EOV); k++)
+ 	free(k->text);
+       free((char *)kv);
+     }
+ }
diff -c xntpd/ntp_filegen.c:1.1.1.5 xntpd/ntp_filegen.c:3.12
*** xntpd/ntp_filegen.c:1.1.1.5	Wed Jan 26 21:53:04 1994
--- xntpd/ntp_filegen.c	Wed Jan 26 21:53:04 1994
***************
*** 1,5 ****
  /*
!  * ntp_filegen.c,v 3.10 1993/12/03 03:55:35 pruy Exp
   *
   *  implements file generations support for NTP
   *  logfiles and statistic files
--- 1,5 ----
  /*
!  * ntp_filegen.c,v 3.12 1994/01/25 19:06:11 kardel Exp
   *
   *  implements file generations support for NTP
   *  logfiles and statistic files
diff -c xntpd/ntp_request.c:1.1.1.13 xntpd/ntp_request.c:3.13
*** xntpd/ntp_request.c:1.1.1.13	Wed Jan 26 21:53:18 1994
--- xntpd/ntp_request.c	Wed Jan 26 21:53:18 1994
***************
*** 2111,2116 ****
--- 2111,2119 ----
  			req_ack(srcadr, inter, inpkt, INFO_ERR_NODATA);
  			return;
  		}
+ 
+ 		clock.kv_list = (struct ctl_var *)0;
+ 
  		refclock_control(&addr, (struct refclockstat *)0, &clock);
  
  		ic->clockadr = addr.sin_addr.s_addr;
***************
*** 2128,2133 ****
--- 2131,2138 ----
  		ic->fudgeval1 = htonl(clock.fudgeval1);
  		ic->fudgeval2 = htonl(clock.fudgeval2);
  
+ 		free_varlist(clock.kv_list);
+ 
  		ic = (struct info_clock *)more_pkt();
  	}
  	flush_pkt();
diff -c xntpd/refclock_parse.c:1.1.1.9 xntpd/refclock_parse.c:3.45
*** xntpd/refclock_parse.c:1.1.1.9	Wed Jan 26 21:53:39 1994
--- xntpd/refclock_parse.c	Wed Jan 26 21:53:39 1994
***************
*** 1,8 ****
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS))
  /*
!  * /src/NTP/REPOSITORY/v3/xntpd/refclock_parse.c,v 3.43 1994/01/23 16:28:39 kardel Exp
   *
!  * refclock_parse.c,v 3.43 1994/01/23 16:28:39 kardel Exp
   *
   * generic reference clock driver for receivers
   *
--- 1,8 ----
  #if defined(REFCLOCK) && (defined(PARSE) || defined(PARSEPPS))
  /*
!  * /src/NTP/REPOSITORY/v3/xntpd/refclock_parse.c,v 3.45 1994/01/25 19:06:27 kardel Exp
   *
!  * refclock_parse.c,v 3.45 1994/01/25 19:06:27 kardel Exp
   *
   * generic reference clock driver for receivers
   *
***************
*** 129,135 ****
  #include "parse.h"
  
  #if !defined(NO_SCCSID) && !defined(lint) && !defined(__GNUC__)
! static char rcsid[]="refclock_parse.c,v 3.43 1994/01/23 16:28:39 kardel Exp";
  #endif
  
  /**===========================================================================
--- 129,135 ----
  #include "parse.h"
  
  #if !defined(NO_SCCSID) && !defined(lint) && !defined(__GNUC__)
! static char rcsid[]="refclock_parse.c,v 3.45 1994/01/25 19:06:27 kardel Exp";
  #endif
  
  /**===========================================================================
***************
*** 243,248 ****
--- 243,249 ----
     * clock specific configuration
     */
    l_fp                basedelay;        /* clock local phase offset */
+   l_fp                ppsdelay;         /* clock local pps phase offset */
  
    /*
     * clock state handling/reporting
***************
*** 295,300 ****
--- 296,302 ----
  #define NO_END		(void (*)())0
  #define NO_DATA		(void *)0
  #define NO_FORMAT	""
+ #define NO_PPSDELAY     0
  
  #define DCF_ID		"DCF"	/* generic DCF */
  #define DCF_A_ID	"DCFa"	/* AM demodulation */
***************
*** 497,502 ****
--- 499,505 ----
    void   *cl_data;		/* local data area for "poll" mechanism */
    u_fp    cl_rootdelay;		/* rootdelay */
    U_LONG  cl_basedelay;		/* current offset - unsigned l_fp fractional part */
+   U_LONG  cl_ppsdelay;		/* current PPS offset - unsigned l_fp fractional part */
    char   *cl_id;		/* ID code (usually "DCF") */
    char   *cl_description;	/* device name */
    char   *cl_format;		/* fixed format */
***************
*** 516,521 ****
--- 519,525 ----
      NO_DATA,
      DCFPZF535_ROOTDELAY,
      DCFPZF535_BASEDELAY,
+     NO_PPSDELAY,
      DCF_P_ID,
      DCFPZF535_DESCRIPTION,
      NO_FORMAT,
***************
*** 534,539 ****
--- 538,544 ----
      NO_DATA,
      DCFPZF535OCXO_ROOTDELAY,
      DCFPZF535OCXO_BASEDELAY,
+     NO_PPSDELAY,
      DCF_P_ID,
      DCFPZF535OCXO_DESCRIPTION,
      NO_FORMAT,
***************
*** 552,557 ****
--- 557,563 ----
      NO_DATA,
      DCFUA31_ROOTDELAY,
      DCFUA31_BASEDELAY,
+     NO_PPSDELAY,
      DCF_A_ID,
      DCFUA31_DESCRIPTION,
      NO_FORMAT,
***************
*** 570,575 ****
--- 576,582 ----
      NO_DATA,
      DCF7000_ROOTDELAY,
      DCF7000_BASEDELAY,
+     NO_PPSDELAY,
      DCF_A_ID,
      DCF7000_DESCRIPTION,
      NO_FORMAT,
***************
*** 588,593 ****
--- 595,601 ----
      WSDCF_DATA,
      WSDCF_ROOTDELAY,
      WSDCF_BASEDELAY,
+     NO_PPSDELAY,
      DCF_A_ID,
      WSDCF_DESCRIPTION,
      WSDCF_FORMAT,
***************
*** 606,611 ****
--- 614,620 ----
      NO_DATA,
      RAWDCF_ROOTDELAY,
      CONRAD_BASEDELAY,
+     NO_PPSDELAY,
      DCF_A_ID,
      CONRAD_DESCRIPTION,
      RAWDCF_FORMAT,
***************
*** 624,629 ****
--- 633,639 ----
      NO_DATA,
      RAWDCF_ROOTDELAY,
      TIMEBRICK_BASEDELAY,
+     NO_PPSDELAY,
      DCF_A_ID,
      TIMEBRICK_DESCRIPTION,
      RAWDCF_FORMAT,
***************
*** 642,647 ****
--- 652,658 ----
      GPS166_DATA,
      GPS166_ROOTDELAY,
      GPS166_BASEDELAY,
+     NO_PPSDELAY,
      GPS166_ID,
      GPS166_DESCRIPTION,
      GPS166_FORMAT,
***************
*** 660,665 ****
--- 671,677 ----
      TRIMBLESV6_DATA,
      TRIMBLESV6_ROOTDELAY,
      TRIMBLESV6_BASEDELAY,
+     NO_PPSDELAY,
      TRIMBLESV6_ID,
      TRIMBLESV6_DESCRIPTION,
      TRIMBLESV6_FORMAT,
***************
*** 2198,2203 ****
--- 2210,2218 ----
    parse->basedelay.l_ui = 0;	/* we can only pre-configure delays less than 1 second */
    parse->basedelay.l_uf = parse->parse_type->cl_basedelay;
  
+   parse->ppsdelay.l_ui  = 0;	/* we can only pre-configure delays less than 1 second */
+   parse->ppsdelay.l_uf  = parse->parse_type->cl_ppsdelay;
+ 
    peer->rootdelay       = parse->parse_type->cl_rootdelay;
    peer->sstclktype      = parse->parse_type->cl_type;
    peer->precision       = sys_precision;
***************
*** 2554,2559 ****
--- 2569,2575 ----
        out->badformat     = out->baddata    = 0;
        out->timereset     = 0;
        out->currentstatus = out->lastevent = CEVNT_NOMINAL;
+       out->kv_list       = (struct ctl_var *)0;
      }
  
    if (unit >= MAXUNITS)
***************
*** 2579,2585 ****
  
        if (in->haveflags & CLK_HAVETIME2)
  	{
! 	  /* not USED */
  	}
  
        if (in->haveflags & CLK_HAVEVAL1)
--- 2595,2601 ----
  
        if (in->haveflags & CLK_HAVETIME2)
  	{
! 	  parse->ppsdelay = in->fudgetime2;
  	}
  
        if (in->haveflags & CLK_HAVEVAL1)
***************
*** 2619,2637 ****
    if (out)
      {
        register unsigned LONG sum = 0;
!       register char *t;
        register struct tm *tm;
        register short utcoff;
        register char sign;
        register int i;
        time_t tim;
  
!       out->haveflags = CLK_HAVETIME1|CLK_HAVEVAL1|CLK_HAVEFLAG1|CLK_HAVEFLAG2|CLK_HAVEFLAG3;
        out->clockdesc = parse->parse_type->cl_description;
  
        out->fudgetime1 = parse->basedelay;
  
!       L_CLR(&out->fudgetime2);
  
        out->fudgeval1 = (LONG)parse->peer->stratum;
  
--- 2635,2655 ----
    if (out)
      {
        register unsigned LONG sum = 0;
!       register char *t, *tt;
        register struct tm *tm;
        register short utcoff;
        register char sign;
        register int i;
        time_t tim;
  
!       outstatus[0] = '\0';
! 
!       out->haveflags = CLK_HAVETIME1|CLK_HAVETIME2|CLK_HAVEVAL1|CLK_HAVEFLAG1|CLK_HAVEFLAG2|CLK_HAVEFLAG3;
        out->clockdesc = parse->parse_type->cl_description;
  
        out->fudgetime1 = parse->basedelay;
  
!       out->fudgetime2 = parse->ppsdelay;
  
        out->fudgeval1 = (LONG)parse->peer->stratum;
  
***************
*** 2657,2667 ****
  		*/
  	       off = parse->time.parse_stime.fp;
  	       L_SUB(&off, &parse->time.parse_ptime.fp); /* true offset */
! 	       out->fudgetime2 = off;
! 	       out->haveflags |= CLK_HAVETIME2;
  	     }
  	 }
  
        /*
         * all this for just finding out the +-xxxx part (there are always
         * new and changing fields in the standards 8-().
--- 2675,2691 ----
  		*/
  	       off = parse->time.parse_stime.fp;
  	       L_SUB(&off, &parse->time.parse_ptime.fp); /* true offset */
! 	       tt = add_var(&out->kv_list, 40, RO);
! 	       sprintf(tt, "refclock_ppsskew=%s", lfptoms(&off, 6));
  	     }
  	 }
  
+       if (PARSE_PPS(parse->time.parse_state))
+ 	{
+ 	  tt = add_var(&out->kv_list, 80, RO|DEF);
+ 	  sprintf(tt, "refclock_ppstime=\"%s\"", prettydate(&parse->time.parse_ptime.fp));
+ 	}
+ 
        /*
         * all this for just finding out the +-xxxx part (there are always
         * new and changing fields in the standards 8-().
***************
*** 2686,2702 ****
  	  sign = '+';
  	}
  
!       tim = parse->time.parse_time.fp.l_ui - JAN_1970;
!       strcpy(outstatus, ctime(&tim));
!       t = strrchr(outstatus, '\n');
!       if (!t)
  	{
! 	  t = outstatus + strlen(outstatus);
!     	}
        else
  	{
! 	  sprintf(t, " %c%02d%02d", sign, utcoff / 60, utcoff % 60);
! 	  t += strlen(t);
  	}
  
        if (!PARSE_GETTIMECODE(parse, &tmpctl))
--- 2710,2729 ----
  	  sign = '+';
  	}
  
!       tt = add_var(&out->kv_list, 128, RO|DEF);
!       sprintf(tt, "refclock_time=\"");
!       tt += strlen(tt);
! 
!       if (parse->time.parse_time.fp.l_ui == 0)
  	{
! 	  strcpy(tt, "<UNDEFINED>\"");
! 	}
        else
  	{
! 	  strcpy(tt, prettydate(&parse->time.parse_time.fp));
! 	  t = tt + strlen(tt);
! 	  
! 	  sprintf(t, " (%c%02d%02d)\"", sign, utcoff / 60, utcoff % 60);
  	}
  
        if (!PARSE_GETTIMECODE(parse, &tmpctl))
***************
*** 2705,2731 ****
  	}
        else
  	{
  	  /*
  	   * copy PPS flags from last read transaction (informational only)
  	   */
  	  tmpctl.parsegettc.parse_state |= parse->time.parse_state &
  					   (PARSEB_PPS|PARSEB_S_PPS);
  
! 	  if (t)
! 	    {
! 	      *t = ' ';
! 	      (void) parsestate(tmpctl.parsegettc.parse_state, t+1);
! 	    }
! 	  else
! 	    {
! 	      strcat(outstatus, " ");
! 	      (void) parsestate(tmpctl.parsegettc.parse_state, outstatus + strlen(outstatus));
! 	    }
! 	  strcat(outstatus," <");
  	  if (tmpctl.parsegettc.parse_count)
! 	    mkascii(outstatus+strlen(outstatus), sizeof(outstatus) - strlen(outstatus) - 1,
  		    tmpctl.parsegettc.parse_buffer, tmpctl.parsegettc.parse_count - 1);
! 	  strcat(outstatus,">");
  	  parse->badformat += tmpctl.parsegettc.parse_badformat;
  	}
  	
--- 2732,2755 ----
  	}
        else
  	{
+ 	  tt = add_var(&out->kv_list, 128, RO|DEF);
+ 	  sprintf(tt, "refclock_status=\"");
+ 	  tt += strlen(tt);
+ 
  	  /*
  	   * copy PPS flags from last read transaction (informational only)
  	   */
  	  tmpctl.parsegettc.parse_state |= parse->time.parse_state &
  					   (PARSEB_PPS|PARSEB_S_PPS);
  
! 	  (void) parsestate(tmpctl.parsegettc.parse_state, tt);
! 
! 	  strcat(tt, "\"");
! 
  	  if (tmpctl.parsegettc.parse_count)
! 	    mkascii(outstatus+strlen(outstatus), sizeof(outstatus)- strlen(outstatus) - 1,
  		    tmpctl.parsegettc.parse_buffer, tmpctl.parsegettc.parse_count - 1);
! 
  	  parse->badformat += tmpctl.parsegettc.parse_badformat;
  	}
  	
***************
*** 2737,2752 ****
  	}
        else
  	{
! 	  strcat(outstatus," (");
! 	  strncat(outstatus, tmpctl.parseformat.parse_buffer, tmpctl.parseformat.parse_count);
! 	  strcat(outstatus,")");
  	}
  
        /*
         * gather state statistics
         */
  
!       t = outstatus + strlen(outstatus);
  
        for (i = 0; i <= CEVNT_MAX; i++)
  	{
--- 2761,2780 ----
  	}
        else
  	{
! 	  tt = add_var(&out->kv_list, 80, RO|DEF);
! 	  sprintf(tt, "refclock_format=\"");
! 
! 	  strncat(tt, tmpctl.parseformat.parse_buffer, tmpctl.parseformat.parse_count);
! 	  strcat(tt,"\"");
  	}
  
        /*
         * gather state statistics
         */
  
!       tt = add_var(&out->kv_list, 200, RO|DEF);
!       strcpy(tt, "refclock_states=\"");
!       tt += strlen(tt);
  
        for (i = 0; i <= CEVNT_MAX; i++)
  	{
***************
*** 2769,2787 ****
  
  	  if (stime)
  	    {
! 	      sprintf(t, "%s%s%s: %s (%d.%02d%%)",
! 		      sum ? "; " : " [",
                        (parse->status == i) ? "*" : "",
  		      clockstatus(i),
  		      l_mktime(stime),
  		      percent / 100, percent % 100);
  	      sum += stime;
! 	      t   += strlen(t);
  	    }
  	}
  
!       sprintf(t, "; running time: %s]", l_mktime(sum));
  
        out->lencode       = strlen(outstatus);
        out->lastcode      = outstatus;
        out->timereset     = parse->timestarted;
--- 2797,2824 ----
  
  	  if (stime)
  	    {
! 	      sprintf(tt, "%s%s%s: %s (%d.%02d%%)",
! 		      sum ? "; " : "",
                        (parse->status == i) ? "*" : "",
  		      clockstatus(i),
  		      l_mktime(stime),
  		      percent / 100, percent % 100);
  	      sum += stime;
! 	      tt  += strlen(tt);
  	    }
  	}
  
!       sprintf(tt, "; running time: %s\"", l_mktime(sum));
! 
!       tt = add_var(&out->kv_list, 32, RO);
!       sprintf(tt, "refclock_id=\"%s\"", parse->parse_type->cl_id);
  
+       tt = add_var(&out->kv_list, 80, RO);
+       sprintf(tt, "refclock_iomode=\"%s\"", parse->binding->bd_description);
+ 
+       tt = add_var(&out->kv_list, 128, RO);
+       sprintf(tt, "refclock_driver_version=\"refclock_parse.c,v 3.45 1994/01/25 19:06:27 kardel Exp\"");
+ 
        out->lencode       = strlen(outstatus);
        out->lastcode      = outstatus;
        out->timereset     = parse->timestarted;
***************
*** 3086,3091 ****
--- 3123,3130 ----
         */
        offset = parsetime->parse_ptime.fp;
  
+       L_ADD(&offset, &parse->ppsdelay);
+ 
        if (PARSE_TIMECODE(parsetime->parse_state))
  	{
  	  if (M_ISGEQ(off.l_i, off.l_f, -1, 0x80000000) &&
***************
*** 3353,3358 ****
--- 3392,3403 ----
   * History:
   *
   * refclock_parse.c,v
+  * Revision 3.45  1994/01/25  19:06:27  kardel
+  * 94/01/23 reconcilation
+  *
+  * Revision 3.44  1994/01/25  17:32:23  kardel
+  * settable extended variables
+  *
   * Revision 3.43  1994/01/23  16:28:39  kardel
   * HAVE_TERMIOS introduced
   *
diff -c -r1.1.1.8 lib/numtohost.c
*** lib/numtohost.c:1.1.1.8	1994/01/26 20:12:51
--- lib/numtohost.c	1994/01/26 21:17:01
***************
*** 1,6 ****
--- 1,7 ----
  /* numtohost.c,v 3.1 1993/07/06 01:08:40 jbj Exp
   * numtohost - convert network number to host name.
   */
+ #include "ntp_types.h"
  #include "ntp_string.h"
  #include <netdb.h>
  
